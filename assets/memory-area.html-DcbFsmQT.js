import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c as r,a as n,b as a,d as s,w as c,e}from"./app-Dl67cLp_.js";const u={},d={class:"hint-container tip"},k=n("p",{class:"hint-container-title"},"这是一则或许对你有用的小广告",-1),m=n("strong",null,"面试专版",-1),v=n("strong",null,"知识星球",-1),g=e(`<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul></blockquote><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="运行时数据区域" tabindex="-1"><a class="header-anchor" href="#运行时数据区域"><span>运行时数据区域</span></a></h2><p>Java虚拟机会在每个Java程序运行时开辟新的数据区域。</p><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p><p><strong>JDK 1.7</strong>：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" tabindex="0"><figcaption>Java 运行时数据区域（JDK1.7）</figcaption></figure><p><strong>JDK 1.8</strong>：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" tabindex="0"><figcaption>Java 运行时数据区域（JDK1.8 ）</figcaption></figure><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#java-虚拟机栈"><span>Java 虚拟机栈</span></a></h3><p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png" alt="Java 虚拟机栈" tabindex="0"><figcaption>Java 虚拟机栈</figcaption></figure><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/local-variables-table.png" alt="局部变量表" tabindex="0"><figcaption>局部变量表</figcaption></figure><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/jvmimage-20220331175738692.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/《深入理解虚拟机》第三版的第2章-虚拟机栈.png" alt="" tabindex="0"><figcaption></figcaption></figure><h3 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>对象实例内容：</p><ol><li>对象头。即对象的哈希码、GC信息（标记位、GC分代信息）、锁状态</li><li>实例字段 <ul><li>对象属性</li><li>字段类型</li></ul></li><li>引用类型字段</li><li>数组实例</li><li>虚方法表</li></ol><p>线程安全问题：</p><ol><li>堆内存共享 <ol><li>所有线程共享一个堆内存区域，因此一个线程创建的对象实例可以被其他线程访问和修改</li><li>在一个线程中创建并初始化的对象，在其他线程中是可见的，只要它们有对该对象的引用。</li></ol></li><li>线程安全问题 <ol><li>如果多个线程同时访问和修改同一个对象的实例字段，且这些操作没有适当的同步机制，可能会发生数据竞争，导致不可预测的结果。</li><li>由于Java内存模型的原因，某个线程对对象实例字段的修改，可能不会立即被其他线程看到，除非这些修改操作经过同步。</li></ol></li><li>同步机制 <ol><li>可见性保证。将变量声明为volatile，可以确保对该变量的修改会立即被其他线程可见。</li><li>互斥锁。使用synchronized块或方法，确保同一时刻只有一个线程可以执行同步代码块，防止数据竞争。</li><li>使用并发包（java.util.concurrent）中的类</li></ol></li></ol><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt="堆内存结构" tabindex="0"><figcaption>堆内存结构</figcaption></figure><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> （我会在方法区这部分内容详细介绍到）。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>MaxTenuringThreshold of <span class="token number">20</span> is invalid<span class="token punctuation">;</span> must be between <span class="token number">0</span> and <span class="token number">15</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**为什么年龄只能是 0-15? **</p><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p><p>这里我们简单结合对象布局来详细介绍一下。</p><p>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。其中，对象头包括两部分：标记字段（Mark Word）和类型指针（Klass Word）。关于对象内存布局的详细介绍，后文会介绍到，这里就不重复提了。</p><p>这个年龄信息就是在标记字段中存放的（标记字段还存放了对象自身的其他信息比如哈希码、锁状态信息等等）。<code>markOop.hpp</code>定义了标记字（mark word）的结构：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-markOop.hpp..png" alt="标记字段结构" tabindex="0"><figcaption>标记字段结构</figcaption></figure><p>可以看到对象年龄占用的大小确实是 4 位。</p>`,65),b={href:"https://github.com/Snailclimb/JavaGuide/issues/552",target:"_blank",rel:"noopener noreferrer"},h=n("code",null,"MaxTenuringThreshold",-1),f=e(`<p><strong>动态年龄计算的代码如下</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
 //survivor_capacity是survivor空间的大小
size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);//TargetSurvivorRatio 为50
size_t total = 0;
uint age = 1;
while (age &lt; table_size) {
total += sizes[age];//sizes数组是每个年龄段对象大小
if (total &gt; desired_survivor_size) break;
age++;
}
uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;
  ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),_=n("p",null,[a("堆这里最容易出现的就是 "),n("code",null,"OutOfMemoryError"),a(" 错误，并且出现这种错误之后的表现形式还会有几种，比如：")],-1),j=n("li",null,[n("strong",null,[n("code",null,"java.lang.OutOfMemoryError: GC Overhead Limit Exceeded")]),a("：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。")],-1),J=n("strong",null,[n("code",null,"java.lang.OutOfMemoryError: Java heap space")],-1),y=n("code",null,"-Xmx",-1),w={href:"https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size",target:"_blank",rel:"noopener noreferrer"},x=n("li",null,"……",-1),S=e(`<h3 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h3><p>自Java8，元空间取代永久代（即方法区）</p><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p>存储的数据：</p><ol><li>类的元数据：每个加载的类的结构信息</li><li>方法数据：方法的签名、方法的字节码</li></ol><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现" tabindex="0"><figcaption>HotSpot 虚拟机方法区的两种实现</figcaption></figure><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/20210425134508117.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p>4、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">PermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 初始大小</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxPermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的初始（和最小大小）</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxMetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//设置 Metaspace 的最大大小</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池"><span>运行时常量池</span></a></h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用" tabindex="0"><figcaption>符号引用和直接引用</figcaption></figure><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="字符串常量池" tabindex="-1"><a class="header-anchor" href="#字符串常量池"><span>字符串常量池</span></a></h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 在堆中创建字符串对象”ab“</span>
<span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.6.png" alt="method-area-jdk1.6" tabindex="0"><figcaption>method-area-jdk1.6</figcaption></figure><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.7.png" alt="method-area-jdk1.7" tabindex="0"><figcaption>method-area-jdk1.7</figcaption></figure><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>`,42),O={href:"https://www.zhihu.com/question/57109429/answer/151717241",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/fenixsoft/jvm_book",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/fenixsoft/jvm_book/issues/112",target:"_blank",rel:"noopener noreferrer"},C=e(`<blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h3 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存"><span>直接内存</span></a></h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）<strong>与</strong>缓存区（Buffer）<strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为</strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><h2 id="hotspot-虚拟机对象探秘" tabindex="-1"><a class="header-anchor" href="#hotspot-虚拟机对象探秘"><span>HotSpot 虚拟机对象探秘</span></a></h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建" tabindex="-1"><a class="header-anchor" href="#对象的创建"><span>对象的创建</span></a></h3><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><h4 id="step1-类加载检查" tabindex="-1"><a class="header-anchor" href="#step1-类加载检查"><span>Step1:类加载检查</span></a></h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="step2-分配内存" tabindex="-1"><a class="header-anchor" href="#step2-分配内存"><span>Step2:分配内存</span></a></h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞： <ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表： <ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="step3-初始化零值" tabindex="-1"><a class="header-anchor" href="#step3-初始化零值"><span>Step3:初始化零值</span></a></h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="step4-设置对象头" tabindex="-1"><a class="header-anchor" href="#step4-设置对象头"><span>Step4:设置对象头</span></a></h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="step5-执行-init-方法" tabindex="-1"><a class="header-anchor" href="#step5-执行-init-方法"><span>Step5:执行 init 方法</span></a></h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局"><span>对象的内存布局</span></a></h3><figure><img src="http://47.94.135.15:81/JVM/JVM_Memory_object.webp" alt="Java对象内存布局" tabindex="0"><figcaption>Java对象内存布局</figcaption></figure><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）<strong>和</strong>对齐填充（Padding）</strong>。</p><p>对象头包括两部分信息：</p><ol><li>标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li>类型指针（Klass Word）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ol><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><hr><p>当我们在Java代码中，使用new创建一个对象实例的时候，（hotspot虚拟机）JVM层面实际上会创建一个 instanceOopDesc对象。</p><blockquote><p>Hotspot虚拟机采用OOP-Klass模型来描述Java对象实例，OOP(Ordinary Object Point)指的是普通对象指针，Klass用来描述对象实例的具体类型。Hotspot采用<strong>instanceOopDesc</strong>和<strong>arrayOopDesc</strong>来描述对象头，arrayOopDesc对象用来描述数组类型</p></blockquote><p>instanceOopDesc继承自oopDesc oopDesc的定义包含两个成员，分别是 _mark和 _metadata</p><p><strong>oopDesc定义</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> oopDesc <span class="token punctuation">{</span>
  friend <span class="token keyword">class</span> <span class="token class-name">VMStructs</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">volatile</span> markOop  _mark<span class="token punctuation">;</span>
  union _metadata <span class="token punctuation">{</span>
    <span class="token class-name">Klass</span><span class="token operator">*</span>      _klass<span class="token punctuation">;</span>
    narrowKlass _compressed_klass<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> _metadata<span class="token punctuation">;</span>
  <span class="token comment">// Fast access to barrier set.  Must be initialized.</span>
  <span class="token keyword">static</span> <span class="token class-name">BarrierSet</span><span class="token operator">*</span> _bs<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Mark Word</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> markOopDesc<span class="token operator">:</span> <span class="token keyword">public</span> oopDesc <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment">// Conversion</span>
  uintptr_t <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// Constants</span>
  <span class="token keyword">enum</span> <span class="token punctuation">{</span> age_bits                 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>  <span class="token comment">//分代年龄</span>
         lock_bits                <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment">//锁标识</span>
         biased_lock_bits         <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">//是否为偏向锁</span>
         max_hash_bits            <span class="token operator">=</span> <span class="token class-name">BitsPerWord</span> <span class="token operator">-</span> age_bits <span class="token operator">-</span> lock_bits <span class="token operator">-</span> biased_lock_bits<span class="token punctuation">,</span>
         hash_bits                <span class="token operator">=</span> max_hash_bits <span class="token operator">&gt;</span> <span class="token number">31</span> <span class="token operator">?</span> <span class="token number">31</span> <span class="token operator">:</span> max_hash_bits<span class="token punctuation">,</span> <span class="token comment">//对象的hashcode</span>
         cms_bits                 <span class="token operator">=</span> <span class="token function">LP64_ONLY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">NOT_LP64</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         epoch_bits               <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">//偏向锁的时间戳</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，那么围绕这个锁的一系列操作都和Mark word有关系。Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。</p><figure><img src="http://47.94.135.15:81/JVM/mark_word32.webp" alt="mark_word32位" tabindex="0"><figcaption>mark_word32位</figcaption></figure><figure><img src="http://47.94.135.15:81/JVM/mark_word64.webp" alt="mark_word64位" tabindex="0"><figcaption>mark_word64位</figcaption></figure><blockquote><p>锁标志位的表示意义<br> 1、锁标识 lock=00 表示轻量级锁<br> 2、锁标识 lock=10 表示重量级锁<br> 3、偏向锁标识 biased_lock=1表示偏向锁<br> 4、偏向锁标识 biased_lock=0且锁标识=01表示无锁状态</p></blockquote><p>为什么Java对象可以和oopDesc对应，进而可以成为锁对象？<br> 1、Java中的每个对象都派生自Object类，而每个Java Object在JVM内部都有一个native的C++对象 oop/oopDesc进行对应。<br> 2、线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor可以认为是一个同步对象，所有的Java对象是天生携带monitor.</p><blockquote><p>instanceOop是用于表示Java对象的实例数据结构，在Java虚拟机中，它负责存储对象的字段信息、类型信息等。而monitor则是用于实现对象同步和锁机制的一部分，它通常是作为instanceOop的一部分被管理的，但并不直接包含在instanceOop的内部。</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ObjectMonitor</span><span class="token operator">*</span> <span class="token function">monitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token function">has_monitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;check&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Use xor instead of &amp;~ to provide one extra tag-bit check.</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">ObjectMonitor</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">^</span> monitor_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


 <span class="token keyword">class</span> <span class="token class-name">ObjectMonitor</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token class-name">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _header       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//markOop对象头</span>
    _count        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    _waiters      <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token comment">//等待线程数</span>
    _recursions   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//重入次数</span>
    _object       <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    _owner        <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//获得ObjectMonitor对象的线程</span>
    _WaitSet      <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//处于wait状态的线程，会被加入到waitSet</span>
    _WaitSetLock  <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _Responsible  <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
    _succ         <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
    _cxq          <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
    <span class="token class-name">FreeNext</span>      <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
    _EntryList    <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span> <span class="token comment">//处于等待锁BLOCKED状态的线程</span>
    _SpinFreq     <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _SpinClock    <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    <span class="token class-name">OwnerIsThread</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    _previous_owner_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//监视器前一个拥有线程的ID</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>


<span class="token operator">!</span><span class="token punctuation">[</span>同步锁的逻辑<span class="token punctuation">]</span><span class="token punctuation">(</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">47.94</span><span class="token number">.135</span><span class="token number">.15</span><span class="token operator">:</span><span class="token number">81</span><span class="token operator">/</span><span class="token constant">JVM</span><span class="token operator">/</span>markoop_monitor<span class="token punctuation">.</span>webp<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识</p><p>同步块的实现使用 monitorenter和 monitorexit指令，而同步方法是依靠方法修饰符上的flag ACC_SYNCHRONIZED来完成。其本质是对一个对象监视器(monitor)进行获取，这个获取过程是排他的，也就是同一个时刻只能有一个线程获得由synchronized所保护对象的监视器。所谓的监视器，实际上可以理解为一个同步工具，它是由Java对象进行描述的。在Hotspot中，是通过ObjectMonitor来实现，每个对象中都会内置一个ObjectMonitor对象</p><h3 id="锁的升级" tabindex="-1"><a class="header-anchor" href="#锁的升级"><span>锁的升级</span></a></h3><p>无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态</p><h4 id="无锁状态" tabindex="-1"><a class="header-anchor" href="#无锁状态"><span>无锁状态</span></a></h4><p>1、锁的进入</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">IRT_ENTRY_NO_ASYNC</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token class-name">InterpreterRuntime</span><span class="token operator">::</span><span class="token function">monitorenter</span><span class="token punctuation">(</span><span class="token class-name">JavaThread</span><span class="token operator">*</span> thread<span class="token punctuation">,</span> <span class="token class-name">BasicObjectLock</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">)</span>
#ifdef <span class="token constant">ASSERT</span>
  thread<span class="token operator">-&gt;</span><span class="token function">last_frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interpreter_frame_verify_monitor</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
#endif
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">UseBiasedLocking</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span>
    <span class="token class-name">ObjectSynchronizer</span><span class="token operator">::</span><span class="token function">fast_enter</span><span class="token punctuation">(</span>h_obj<span class="token punctuation">,</span> elem<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token constant">CHECK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">ObjectSynchronizer</span><span class="token operator">::</span><span class="token function">slow_enter</span><span class="token punctuation">(</span>h_obj<span class="token punctuation">,</span> elem<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">CHECK</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
#ifdef <span class="token constant">ASSERT</span>
  thread<span class="token operator">-&gt;</span><span class="token function">last_frame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interpreter_frame_verify_monitor</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
#endif
<span class="token constant">IRT_END</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>UseBiasedLocking是在JVM启动的时候，是否启动偏向锁的标识<br> 1、如果支持偏向锁,则执行 ObjectSynchronizer::fast_enter的逻辑<br> 2、如果不支持偏向锁,则执行 ObjectSynchronizer::slow_enter逻辑，绕过偏向锁，直接进入轻量级锁</p></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token class-name">ObjectSynchronizer</span><span class="token operator">::</span><span class="token function">fast_enter</span><span class="token punctuation">(</span><span class="token class-name">Handle</span> obj<span class="token punctuation">,</span> <span class="token class-name">BasicLock</span><span class="token operator">*</span> lock<span class="token punctuation">,</span> bool attempt_rebias<span class="token punctuation">,</span> <span class="token constant">TRAPS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">UseBiasedLocking</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//判断是否开启了偏向锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">SafepointSynchronize</span><span class="token operator">::</span><span class="token function">is_at_safepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果不处于全局安全点</span>
      <span class="token comment">//通过\`revoke_and_rebias\`这个函数尝试获取偏向锁</span>
      <span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token class-name">Condition</span> cond <span class="token operator">=</span> <span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token function">revoke_and_rebias</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attempt_rebias<span class="token punctuation">,</span> <span class="token constant">THREAD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cond <span class="token operator">==</span> <span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token constant">BIAS_REVOKED_AND_REBIASED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果是撤销与重偏向直接返回</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//如果在安全点，撤销偏向锁</span>
      <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>attempt_rebias<span class="token punctuation">,</span> <span class="token string">&quot;can not rebias toward VM thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token function">revoke_at_safepoint</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token operator">-&gt;</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">has_bias_pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;biases should be revoked by now&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

 slow_enter <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> lock<span class="token punctuation">,</span> <span class="token constant">THREAD</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>fast_enter解释<br> 1、再次检查偏向锁是否开启<br> 2、当处于不安全点时，通过 revoke_and_rebias尝试获取偏向锁，如果成功则直接返回，如果失败则进入轻量级锁获取过程<br> 3、revoke_and_rebias这个偏向锁的获取逻辑在 biasedLocking.cpp中<br> 如果偏向锁未开启，则进入 slow_enter获取轻量级锁的流程</p></blockquote><h4 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁"><span>偏向锁</span></a></h4><p>概念：<br> 如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。</p><p>偏向锁的获取：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token class-name">Condition</span> <span class="token class-name">BiasedLocking</span><span class="token operator">::</span><span class="token function">revoke_and_rebias</span><span class="token punctuation">(</span><span class="token class-name">Handle</span> obj<span class="token punctuation">,</span> bool attempt_rebias<span class="token punctuation">,</span> <span class="token constant">TRAPS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">SafepointSynchronize</span><span class="token operator">::</span><span class="token function">is_at_safepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;must not be called while at safepoint&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  markOop mark <span class="token operator">=</span> obj<span class="token operator">-&gt;</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取锁对象的对象头</span>
  <span class="token comment">//判断mark是否为可偏向状态，即mark的偏向锁标志位为1，锁标志位为 01，线程id为null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>mark<span class="token operator">-&gt;</span><span class="token function">is_biased_anonymously</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>attempt_rebias<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//这个分支是进行对象的hashCode计算时会进入，在一个非全局安全点进行偏向锁撤销</span>
    markOop biased_value       <span class="token operator">=</span> mark<span class="token punctuation">;</span>
    <span class="token comment">//创建一个非偏向的markword</span>
    markOop unbiased_prototype <span class="token operator">=</span> markOopDesc<span class="token operator">::</span><span class="token function">prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">set_age</span><span class="token punctuation">(</span>mark<span class="token operator">-&gt;</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//Atomic:cmpxchg_ptr是CAS操作，通过cas重新设置偏向锁状态</span>
    markOop res_mark <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> <span class="token class-name">Atomic</span><span class="token operator">::</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>unbiased_prototype<span class="token punctuation">,</span> obj<span class="token operator">-&gt;</span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res_mark <span class="token operator">==</span> biased_value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果CAS成功，返回偏向锁撤销状态</span>
      <span class="token keyword">return</span> <span class="token constant">BIAS_REVOKED</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mark<span class="token operator">-&gt;</span><span class="token function">has_bias_pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果锁对象为可偏向状态（biased_lock:1, lock:01，不管线程id是否为空）,尝试重新偏向</span>
    <span class="token class-name">Klass</span><span class="token operator">*</span> k <span class="token operator">=</span> obj<span class="token operator">-&gt;</span><span class="token function">klass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    markOop prototype_header <span class="token operator">=</span> k<span class="token operator">-&gt;</span><span class="token function">prototype_header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果已经有线程对锁对象进行了全局锁定，则取消偏向锁操作</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prototype_header<span class="token operator">-&gt;</span><span class="token function">has_bias_pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      markOop biased_value       <span class="token operator">=</span> mark<span class="token punctuation">;</span>
      <span class="token comment">//CAS 更新对象头markword为非偏向锁</span>
      markOop res_mark <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> <span class="token class-name">Atomic</span><span class="token operator">::</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>prototype_header<span class="token punctuation">,</span> obj<span class="token operator">-&gt;</span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>obj<span class="token operator">-&gt;</span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">has_bias_pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;even if we raced, should still be revoked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token constant">BIAS_REVOKED</span><span class="token punctuation">;</span> <span class="token comment">//返回偏向锁撤销状态</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype_header<span class="token operator">-&gt;</span><span class="token function">bias_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> mark<span class="token operator">-&gt;</span><span class="token function">bias_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//如果偏向锁过期，则进入当前分支</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>attempt_rebias<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果允许尝试获取偏向锁</span>
        <span class="token keyword">assert</span><span class="token punctuation">(</span><span class="token constant">THREAD</span><span class="token operator">-&gt;</span><span class="token function">is_Java_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        markOop biased_value       <span class="token operator">=</span> mark<span class="token punctuation">;</span>
        markOop rebiased_prototype <span class="token operator">=</span> markOopDesc<span class="token operator">::</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">JavaThread</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token constant">THREAD</span><span class="token punctuation">,</span> mark<span class="token operator">-&gt;</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prototype_header<span class="token operator">-&gt;</span><span class="token function">bias_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//通过CAS 操作， 将本线程的 ThreadID 、时间错、分代年龄尝试写入对象头中</span>
        markOop res_mark <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> <span class="token class-name">Atomic</span><span class="token operator">::</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>rebiased_prototype<span class="token punctuation">,</span> obj<span class="token operator">-&gt;</span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res_mark <span class="token operator">==</span> biased_value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//CAS成功，则返回撤销和重新偏向状态</span>
          <span class="token keyword">return</span> <span class="token constant">BIAS_REVOKED_AND_REBIASED</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//不尝试获取偏向锁，则取消偏向锁</span>
        <span class="token comment">//通过CAS操作更新分代年龄</span>
        markOop biased_value       <span class="token operator">=</span> mark<span class="token punctuation">;</span>
        markOop unbiased_prototype <span class="token operator">=</span> markOopDesc<span class="token operator">::</span><span class="token function">prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">set_age</span><span class="token punctuation">(</span>mark<span class="token operator">-&gt;</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        markOop res_mark <span class="token operator">=</span> <span class="token punctuation">(</span>markOop<span class="token punctuation">)</span> <span class="token class-name">Atomic</span><span class="token operator">::</span><span class="token function">cmpxchg_ptr</span><span class="token punctuation">(</span>unbiased_prototype<span class="token punctuation">,</span> obj<span class="token operator">-&gt;</span><span class="token function">mark_addr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mark<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res_mark <span class="token operator">==</span> biased_value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果CAS操作成功，返回偏向锁撤销状态</span>
          <span class="token keyword">return</span> <span class="token constant">BIAS_REVOKED</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//省略</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，表示哪个线程获得了偏向锁<br> 偏向锁的获取逻辑：<br> 1、首先获取目标对象的Mark Word，根据锁的标识为和epoch去判断当前是否处于可偏向的状态<br> 2、如果为可偏向状态，则通过CAS操作将自己的线程ID写入到MarkWord，如果CAS操作成功，则表示当前线程成功获取到偏向锁，继续执行同步代码块<br> 3、如果是已偏向状态，先检测MarkWord中存储的threadID和当前访问的线程的threadID是否相等，如果相等，表示当前线程已经获得了偏向锁，则不需要再获得锁直接执行同步代码；如果不相等，则证明当前锁偏向于其他线程，需要撤销偏向锁。</p><blockquote><p>CAS:表示自旋锁，由于线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说性能开销很大。同时，很多对象锁的锁定状态只会持续很短的时间，因此引入了自旋锁，所谓自旋就是一个无意义的死循环，在循环体内不断的重行竞争锁。当然，自旋的次数会有限制，超出指定的限制会升级到阻塞锁。</p></blockquote><p>偏向锁的撤销<br> 当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，撤销偏向锁的过程需要等待一个全局安全点(所有工作线程都停止字节码的执行)。<br> 1、首先，暂停拥有偏向锁的线程，然后检查偏向锁的线程是否为存活状态<br> 2、如果线程已经死了，直接把对象头设置为无锁状态<br> 3、如果还活着，当达到全局安全点时获得偏向锁的线程会被挂起，接着偏向锁升级为轻量级锁，然后唤醒被阻塞在全局安全点的线程继续往下执行同步代码</p><h4 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁"><span>轻量级锁</span></a></h4><p>偏向锁撤销以后对象会可能会处于两种状态<br> 1、一种是不可偏向的无锁状态，简单来说就是已经获得偏向锁的线程已经退出了同步代码块，那么这个时候会撤销偏向锁，并升级为轻量级锁<br> 2、一种是不可偏向的已锁状态，简单来说就是已经获得偏向锁的线程正在执行同步代码块，那么这个时候会升级到轻量级锁并且被原持有锁的线程获得锁</p><p>轻量级锁加锁：<br> 1、JVM会先在当前线程的栈帧中创建用于存储锁记录的空间(LockRecord)<br> 2、将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word.<br> 3、线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针<br> 4、如果替换成功，表示当前线程获得轻量级锁，如果失败，表示存在其他线程竞争锁，那么当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀升级为重量级锁</p><p>轻量级锁解锁：<br> 1、尝试CAS操作将所记录中的Mark Word替换回到对象头中<br> 2、如果成功，表示没有竞争发生<br> 3、如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁</p><blockquote><p>一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于重量级锁状态，其他线程尝试获取锁时，都会被阻塞，也就是 BLOCKED状态。当持有锁的线程释放锁之后会唤醒这些现场，被唤醒之后的线程会进行新一轮的竞争</p></blockquote><h4 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁"><span>重量级锁</span></a></h4><p>重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）</p><blockquote><p>为什么重量级锁消耗比较大?<br> 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的</p></blockquote><h3 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位"><span>对象的访问定位</span></a></h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄" tabindex="-1"><a class="header-anchor" href="#句柄"><span>句柄</span></a></h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄" tabindex="0"><figcaption>对象的访问定位-使用句柄</figcaption></figure><h4 id="直接指针" tabindex="-1"><a class="header-anchor" href="#直接指针"><span>直接指针</span></a></h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针" tabindex="0"><figcaption>对象的访问定位-直接指针</figcaption></figure><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,86),D=n("li",null,"《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》",-1),A=n("li",null,"《自己动手写 Java 虚拟机》",-1),q={href:"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html",target:"_blank",rel:"noopener noreferrer"},z={href:"https://chenxitag.com/archives/368",target:"_blank",rel:"noopener noreferrer"},L={href:"https://www.zhihu.com/question/55994121/answer/147296098",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.zhihu.com/question/57109429/answer/151717241",target:"_blank",rel:"noopener noreferrer"},B={href:"http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/",target:"_blank",rel:"noopener noreferrer"},V={href:"https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou",target:"_blank",rel:"noopener noreferrer"},N={href:"https://stackoverflow.com/questions/9095748/method-area-and-permgen",target:"_blank",rel:"noopener noreferrer"},K=e(`<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2);function H(G,R){const p=o("RouteLink"),t=o("ExternalLinkIcon");return l(),r("div",null,[n("div",d,[k,n("ul",null,[n("li",null,[m,a("：准备 Java 面试的小伙伴可以考虑面试专版："),n("strong",null,[s(p,{to:"/zhuanlan/java-mian-shi-zhi-bei.html"},{default:c(()=>[a("《Java 面试指北 》")]),_:1})]),a(" (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。")]),n("li",null,[v,a("：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 "),n("strong",null,[s(p,{to:"/about-the-author/zhishixingqiu-two-years.html"},{default:c(()=>[a("JavaGuide 官方知识星球")]),_:1})]),a("。")])])]),g,n("blockquote",null,[n("p",null,[n("strong",null,[a("🐛 修正（参见："),n("a",b,[a("issue552"),s(t)]),a("）")]),a("：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 "),h,a(" 中更小的一个值，作为新的晋升年龄阈值”。")]),f]),_,n("ol",null,[j,n("li",null,[J,a(" :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过"),y,a("参数配置，若没有特别配置，将会使用默认值，详见："),n("a",w,[a("Default Java 8 max heap size"),s(t)]),a(")")]),x]),S,n("p",null,[a("相关问题："),n("a",O,[a("JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎"),s(t)])]),n("p",null,[a("最后再来分享一段周志明老师在"),n("a",M,[a("《深入理解 Java 虚拟机（第 3 版）》样例代码&勘误"),s(t)]),a(" GitHub 仓库的 "),n("a",E,[a("issue#112"),s(t)]),a(" 中说过的话：")]),C,n("ul",null,[D,A,n("li",null,[a("Chapter 2. The Structure of the Java Virtual Machine："),n("a",q,[a("https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html"),s(t)])]),n("li",null,[a("JVM 栈帧内部结构-动态链接："),n("a",z,[a("https://chenxitag.com/archives/368"),s(t)])]),n("li",null,[a('Java 中 new String("字面量") 中 "字面量" 是何时进入字符串常量池的? - 木女孩的回答 - 知乎：'),n("a",L,[a("https://www.zhihu.com/question/55994121/answer/147296098"),s(t)])]),n("li",null,[a("JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎："),n("a",T,[a("https://www.zhihu.com/question/57109429/answer/151717241"),s(t)])]),n("li",null,[n("a",B,[a("http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/"),s(t)])]),n("li",null,[n("a",V,[a("https://dzone.com/articles/jvm-permgen-–-where-art-thou"),s(t)])]),n("li",null,[n("a",N,[a("https://stackoverflow.com/questions/9095748/method-area-and-permgen"),s(t)])])]),K])}const X=i(u,[["render",H],["__file","memory-area.html.vue"]]),U=JSON.parse(`{"path":"/java/jvm/memory-area.html","title":"Java内存区域详解（重点）","lang":"zh-CN","frontmatter":{"title":"Java内存区域详解（重点）","category":"Java","tag":["JVM"],"gitInclude":["../../snippets/small-advertisement.snippet.md","../../snippets/article-footer.snippet.md"],"description":"这是一则或许对你有用的小广告 面试专版：准备 Java 面试的小伙伴可以考虑面试专版： (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。 知识星球：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 。 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。 本文基于《深入理解 Java 虚拟机：JVM 高...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/learning/java/jvm/memory-area.html"}],["meta",{"property":"og:site_name","content":"Mua'dib Guide "}],["meta",{"property":"og:title","content":"Java内存区域详解（重点）"}],["meta",{"property":"og:description","content":"这是一则或许对你有用的小广告 面试专版：准备 Java 面试的小伙伴可以考虑面试专版： (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。 知识星球：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 。 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。 本文基于《深入理解 Java 虚拟机：JVM 高..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-07T16:48:30.000Z"}],["meta",{"property":"article:author","content":"Guide"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:modified_time","content":"2024-06-07T16:48:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java内存区域详解（重点）\\",\\"image\\":[\\"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/stack-area.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/local-variables-table.png\\",\\"https://oss.javaguide.cn/github/javaguide/jvmimage-20220331175738692.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-markOop.hpp..png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-implementation.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/20210425134508117.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/symbol-reference-and-direct-reference.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.6.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/method-area-jdk1.7.png\\",\\"http://47.94.135.15:81/JVM/JVM_Memory_object.webp\\",\\"http://47.94.135.15:81/JVM/mark_word32.webp\\",\\"http://47.94.135.15:81/JVM/mark_word64.webp\\",\\"http://47.94.135.15:81/JVM/markoop_monitor.webp\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png\\",\\"https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png\\"],\\"dateModified\\":\\"2024-06-07T16:48:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guide\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"运行时数据区域","slug":"运行时数据区域","link":"#运行时数据区域","children":[{"level":3,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":3,"title":"Java 虚拟机栈","slug":"java-虚拟机栈","link":"#java-虚拟机栈","children":[]},{"level":3,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":3,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":3,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":3,"title":"运行时常量池","slug":"运行时常量池","link":"#运行时常量池","children":[]},{"level":3,"title":"字符串常量池","slug":"字符串常量池","link":"#字符串常量池","children":[]},{"level":3,"title":"直接内存","slug":"直接内存","link":"#直接内存","children":[]}]},{"level":2,"title":"HotSpot 虚拟机对象探秘","slug":"hotspot-虚拟机对象探秘","link":"#hotspot-虚拟机对象探秘","children":[{"level":3,"title":"对象的创建","slug":"对象的创建","link":"#对象的创建","children":[]},{"level":3,"title":"对象的内存布局","slug":"对象的内存布局","link":"#对象的内存布局","children":[]},{"level":3,"title":"锁的升级","slug":"锁的升级","link":"#锁的升级","children":[]},{"level":3,"title":"对象的访问定位","slug":"对象的访问定位","link":"#对象的访问定位","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1636463233000,"updatedTime":1717778910000,"contributors":[{"name":"guide","email":"koushuangbwcx@163.com","commits":23},{"name":"Guide","email":"koushuangbwcx@163.com","commits":18},{"name":"Mr.Hope","email":"mister-hope@outlook.com","commits":7},{"name":"tonygong","email":"280880907@163.com","commits":3},{"name":"ZhoucpSAMA","email":"53161244+ZhoucpSAMA@users.noreply.github.com","commits":2},{"name":"Dayu","email":"zxy690@qq.com","commits":1},{"name":"Gale","email":"1372363493@qq.com","commits":1},{"name":"Guide哥","email":"koushuangbwcx@163.com","commits":1},{"name":"Sheldon7777","email":"51614703+Sheldon7777@users.noreply.github.com","commits":1},{"name":"paigeman","email":"53284808+paigeman@users.noreply.github.com","commits":1},{"name":"sam","email":"sam2008ext@gmail.com","commits":1},{"name":"seven17777777","email":"167538235+seven17777777@users.noreply.github.com","commits":1},{"name":"target","email":"26007894+geomonlin@users.noreply.github.com","commits":1},{"name":"呼卓宇","email":"32487460+huzhuoyu@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":36.25,"words":10874},"filePathRelative":"java/jvm/memory-area.md","localizedDate":"2021年11月9日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">这是一则或许对你有用的小广告</p>\\n<ul>\\n<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href=\\"/learning/zhuanlan/java-mian-shi-zhi-bei.html\\" target=\\"_blank\\">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>\\n<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href=\\"/learning/about-the-author/zhishixingqiu-two-years.html\\" target=\\"_blank\\">JavaGuide 官方知识星球</a></strong>。</li>\\n</ul>\\n</div>","autoDesc":true}`);export{X as comp,U as data};
