import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as l,c,a as e,b as a,d as s,e as r}from"./app-ChWUTpfW.js";const o="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%911-DBtcn6an.png",p="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%912-5DKn1Vs2.png",d="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%913-BtbXNFrh.png",u="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%914-CO762S26.png",h="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%915-C2ncqkhW.png",g="/learning/assets/%E7%BA%A2%E9%BB%91%E6%A0%916-Bx2lji_P.png",m={},k=r(`<h2 id="红黑树介绍" tabindex="-1"><a class="header-anchor" href="#红黑树介绍"><span>红黑树介绍</span></a></h2><p>红黑树（Red Black Tree）是一种自平衡二叉查找树。它是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p><p>由于其自平衡的特性，保证了最坏情形下在 O(logn) 时间复杂度内完成查找、增加、删除等操作，性能表现稳定。</p><p>在 JDK 中，<code>TreeMap</code>、<code>TreeSet</code> 以及 JDK1.8 的 <code>HashMap</code> 底层都用到了红黑树。</p><h2 id="为什么需要红黑树" tabindex="-1"><a class="header-anchor" href="#为什么需要红黑树"><span>为什么需要红黑树？</span></a></h2><p>红黑树的诞生就是为了解决二叉查找树的缺陷。</p><p>二叉查找树是一种基于比较的数据结构，它的每个节点都有一个键值，而且左子节点的键值小于父节点的键值，右子节点的键值大于父节点的键值。这样的结构可以方便地进行查找、插入和删除操作，因为只需要比较节点的键值就可以确定目标节点的位置。但是，二叉查找树有一个很大的问题，就是它的形状取决于节点插入的顺序。如果节点是按照升序或降序的方式插入的，那么二叉查找树就会退化成一个线性结构，也就是一个链表。这样的情况下，二叉查找树的性能就会大大降低，时间复杂度就会从 O(logn) 变为 O(n)。</p><p>红黑树的诞生就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><h2 id="红黑树特点" tabindex="-1"><a class="header-anchor" href="#红黑树特点"><span><strong>红黑树特点</strong></span></a></h2><ol><li>每个节点非红即黑。黑色决定平衡，红色不决定平衡。这对应了 2-3 树中一个节点内可以存放 1~2 个节点。</li><li>根节点总是黑色的。</li><li>每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）。通常这条规则也叫不会有连续的红色节点。一个节点最多临时会有 3 个节点，中间是黑色节点，左右是红色节点。</li><li>从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li></ol><p>正是这些特点才保证了红黑树的平衡，让红黑树的高度不会超过 2log(n+1)。</p><h2 id="红黑树数据结构" tabindex="-1"><a class="header-anchor" href="#红黑树数据结构"><span>红黑树数据结构</span></a></h2><p>建立在 BST 二叉搜索树的基础上，AVL、2-3 树、红黑树都是自平衡二叉树（统称 B-树）。但相比于 AVL 树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。</p><h2 id="红黑树结构实现" tabindex="-1"><a class="header-anchor" href="#红黑树结构实现"><span>红黑树结构实现</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> value<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> parent<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>

    <span class="token comment">// AVL 树所需属性</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>
    <span class="token comment">// 红黑树所需属性</span>
    <span class="token keyword">public</span> <span class="token class-name">Color</span> color <span class="token operator">=</span> <span class="token class-name">Color</span><span class="token punctuation">.</span><span class="token constant">RED</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-左倾染色" tabindex="-1"><a class="header-anchor" href="#_1-左倾染色"><span>1.左倾染色</span></a></h3><figure><img src="`+o+'" alt="幻灯片1" tabindex="0"><figcaption>幻灯片1</figcaption></figure><ul><li>染色时根据当前节点的爷爷节点，找到当前节点的叔叔节点。</li><li>再把父节点染黑、叔叔节点染黑，爷爷节点染红。但爷爷节点染红是临时的，当平衡树高操作后会把根节点染黑。</li></ul><h3 id="_2-右倾染色" tabindex="-1"><a class="header-anchor" href="#_2-右倾染色"><span>2.右倾染色</span></a></h3><figure><img src="'+p+'" alt="幻灯片2" tabindex="0"><figcaption>幻灯片2</figcaption></figure><h3 id="_3-左旋调衡" tabindex="-1"><a class="header-anchor" href="#_3-左旋调衡"><span>3.左旋调衡</span></a></h3><h4 id="_3-1-一次左旋" tabindex="-1"><a class="header-anchor" href="#_3-1-一次左旋"><span>3.1 一次左旋</span></a></h4><figure><img src="'+d+'" alt="幻灯片3" tabindex="0"><figcaption>幻灯片3</figcaption></figure><h4 id="_3-2-右旋-左旋" tabindex="-1"><a class="header-anchor" href="#_3-2-右旋-左旋"><span>3.2 右旋+左旋</span></a></h4><figure><img src="'+u+'" alt="幻灯片4" tabindex="0"><figcaption>幻灯片4</figcaption></figure><h3 id="_4-右旋调衡" tabindex="-1"><a class="header-anchor" href="#_4-右旋调衡"><span>4.右旋调衡</span></a></h3><h4 id="_4-1-一次右旋" tabindex="-1"><a class="header-anchor" href="#_4-1-一次右旋"><span>4.1 一次右旋</span></a></h4><figure><img src="'+h+'" alt="幻灯片5" tabindex="0"><figcaption>幻灯片5</figcaption></figure><h4 id="_4-2-左旋-右旋" tabindex="-1"><a class="header-anchor" href="#_4-2-左旋-右旋"><span>4.2 左旋+右旋</span></a></h4><figure><img src="'+g+'" alt="幻灯片6" tabindex="0"><figcaption>幻灯片6</figcaption></figure><h2 id="文章推荐" tabindex="-1"><a class="header-anchor" href="#文章推荐"><span>文章推荐</span></a></h2>',31),b={href:"https://zhuanlan.zhihu.com/p/24367771",target:"_blank",rel:"noopener noreferrer"},_={href:"https://juejin.im/post/5a27c6946fb9a04509096248#comment",target:"_blank",rel:"noopener noreferrer"},f=e("figure",null,[e("img",{src:"https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png",alt:"JavaGuide 官方公众号",tabindex:"0"}),e("figcaption",null,"JavaGuide 官方公众号")],-1);function v(B,y){const n=i("ExternalLinkIcon");return l(),c("div",null,[k,e("ul",null,[e("li",null,[e("a",b,[a("《红黑树深入剖析及 Java 实现》 - 美团点评技术团队"),s(n)])]),e("li",null,[e("a",_,[a("漫画：什么是红黑树？ - 程序员小灰"),s(n)]),a("（也介绍到了二叉查找树，非常推荐）")])]),f])}const E=t(m,[["render",v],["__file","red-black-tree.html.vue"]]),T=JSON.parse(`{"path":"/cs-basics/data-structure/red-black-tree.html","title":"红黑树","lang":"zh-CN","frontmatter":{"title":"红黑树","category":"计算机基础","tag":["数据结构"],"gitInclude":["../../snippets/article-footer.snippet.md"],"description":"红黑树介绍 红黑树（Red Black Tree）是一种自平衡二叉查找树。它是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 由于其自平衡的特性，保证...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/learning/cs-basics/data-structure/red-black-tree.html"}],["meta",{"property":"og:site_name","content":"Mua'dib Guide "}],["meta",{"property":"og:title","content":"红黑树"}],["meta",{"property":"og:description","content":"红黑树介绍 红黑树（Red Black Tree）是一种自平衡二叉查找树。它是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 由于其自平衡的特性，保证..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-31T05:42:06.000Z"}],["meta",{"property":"article:author","content":"Guide"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:modified_time","content":"2024-08-31T05:42:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"红黑树\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-31T05:42:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guide\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"红黑树介绍","slug":"红黑树介绍","link":"#红黑树介绍","children":[]},{"level":2,"title":"为什么需要红黑树？","slug":"为什么需要红黑树","link":"#为什么需要红黑树","children":[]},{"level":2,"title":"红黑树特点","slug":"红黑树特点","link":"#红黑树特点","children":[]},{"level":2,"title":"红黑树数据结构","slug":"红黑树数据结构","link":"#红黑树数据结构","children":[]},{"level":2,"title":"红黑树结构实现","slug":"红黑树结构实现","link":"#红黑树结构实现","children":[{"level":3,"title":"1.左倾染色","slug":"_1-左倾染色","link":"#_1-左倾染色","children":[]},{"level":3,"title":"2.右倾染色","slug":"_2-右倾染色","link":"#_2-右倾染色","children":[]},{"level":3,"title":"3.左旋调衡","slug":"_3-左旋调衡","link":"#_3-左旋调衡","children":[]},{"level":3,"title":"4.右旋调衡","slug":"_4-右旋调衡","link":"#_4-右旋调衡","children":[]}]},{"level":2,"title":"文章推荐","slug":"文章推荐","link":"#文章推荐","children":[]}],"git":{"createdTime":1725082926000,"updatedTime":1725082926000,"contributors":[{"name":"Tony Gong","email":"a280880907@163.com","commits":1}]},"readingTime":{"minutes":3.66,"words":1098},"filePathRelative":"cs-basics/data-structure/red-black-tree.md","localizedDate":"2024年8月31日","excerpt":"<h2>红黑树介绍</h2>\\n<p>红黑树（Red Black Tree）是一种自平衡二叉查找树。它是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p>\\n<p>由于其自平衡的特性，保证了最坏情形下在 O(logn) 时间复杂度内完成查找、增加、删除等操作，性能表现稳定。</p>\\n<p>在 JDK 中，<code>TreeMap</code>、<code>TreeSet</code> 以及 JDK1.8 的 <code>HashMap</code> 底层都用到了红黑树。</p>","autoDesc":true}`);export{E as comp,T as data};
