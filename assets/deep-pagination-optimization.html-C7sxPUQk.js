import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o,c as l,a as n,b as a,d as e,e as i}from"./app-D0cmWqTO.js";const r={},c=i(`<h2 id="深度分页介绍" tabindex="-1"><a class="header-anchor" href="#深度分页介绍"><span>深度分页介绍</span></a></h2><p>查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># MySQL 在无法利用索引的情况下跳过1000000条记录后，再获取10条记录</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">LIMIT</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="深度分页优化建议" tabindex="-1"><a class="header-anchor" href="#深度分页优化建议"><span>深度分页优化建议</span></a></h2><p>这里以 MySQL 数据库为例介绍一下如何优化深度分页。</p><h3 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询"><span>范围查询</span></a></h3><p>当可以保证 ID 的连续性时，根据 ID 范围进行分页是比较好的解决方案：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 查询指定 ID 范围的数据</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token operator">AND</span> id <span class="token operator">&lt;=</span> <span class="token number">100010</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id
<span class="token comment"># 也可以通过记录上次查询结果的最后一条记录的ID进行下一页的查询：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种优化方式限制比较大，且一般项目的 ID 也没办法保证完全连续。</p><h3 id="子查询" tabindex="-1"><a class="header-anchor" href="#子查询"><span>子查询</span></a></h3><p>我们先查询出 limit 第一个参数对应的主键值，再根据这个主键值再去过滤并 limit，这样效率会更快一些。</p><p>阿里巴巴《Java 开发手册》中也有对应的描述：</p><blockquote><p>利用延迟关联或者子查询优化超多分页场景。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/mysql/alibaba-java-development-handbook-paging.png" alt="" tabindex="0"><figcaption></figcaption></figure></blockquote><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 通过子查询来获取 id 的起始值，把 limit 1000000 的条件转移到子查询</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，子查询的结果会产生一张新表，会影响性能，应该尽量避免大量使用子查询。并且，这种方法只适用于 ID 是正序的。在复杂分页场景，往往需要通过过滤条件，筛选到符合条件的 ID，此时的 ID 是离散且不连续的。</p><p>当然，我们也可以利用子查询先去获取目标分页的 ID 集合，然后再根据 ID 集合获取内容，但这种写法非常繁琐，不如使用 INNER JOIN 延迟关联。</p><h3 id="延迟关联" tabindex="-1"><a class="header-anchor" href="#延迟关联"><span>延迟关联</span></a></h3><p>延迟关联的优化思路，跟子查询的优化思路其实是一样的：都是把条件转移到主键索引树，减少回表的次数。不同点是，延迟关联使用了 INNER JOIN（内连接） 包含子查询。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> t_order t1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> t2
<span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了使用 INNER JOIN 之外，还可以使用逗号连接子查询。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> t_order t1<span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引"><span>覆盖索引</span></a></h3><p>索引中已经包含了所有需要获取的字段的查询方式称为覆盖索引。</p><p><strong>覆盖索引的好处：</strong></p><ul><li><strong>避免 InnoDB 表进行索引的二次查询，也就是回表操作:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询（回表），减少了 IO 操作，提升了查询效率。</li><li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 如果只需要查询 id, code, type 这三列，可建立 code 和 type 的覆盖索引</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token keyword">FROM</span> t_order
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> code
<span class="token keyword">LIMIT</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，当查询的结果集占表的总行数的很大一部分时，可能就不会走索引了，自动转换为全表扫描。当然了，也可以通过 <code>FORCE INDEX</code> 来强制查询优化器走索引，但这种提升效果一般不明显。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,28),d={href:"https://juejin.cn/post/7012016858379321358",target:"_blank",rel:"noopener noreferrer"},k={href:"https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/6985478936683610149",target:"_blank",rel:"noopener noreferrer"};function m(g,h){const s=p("ExternalLinkIcon");return o(),l("div",null,[c,n("ul",null,[n("li",null,[a("聊聊如何解决 MySQL 深分页问题 - 捡田螺的小男孩："),n("a",d,[a("https://juejin.cn/post/7012016858379321358"),e(s)])]),n("li",null,[a("数据库深分页介绍及优化方案 - 京东零售技术："),n("a",k,[a("https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g"),e(s)])]),n("li",null,[a("MySQL 深分页优化 - 得物技术："),n("a",u,[a("https://juejin.cn/post/6985478936683610149"),e(s)])])])])}const b=t(r,[["render",m],["__file","deep-pagination-optimization.html.vue"]]),w=JSON.parse(`{"path":"/high-performance/deep-pagination-optimization.html","title":"深度分页介绍及优化建议","lang":"zh-CN","frontmatter":{"title":"深度分页介绍及优化建议","category":"高性能","head":[["meta",{"name":"keywords","content":"深度分页"}],["meta",{"name":"description","content":"查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低。深度分页可以采用范围查询、子查询、INNER JOIN 延迟关联、覆盖索引等方法进行优化。"}],["meta",{"property":"og:url","content":"https://javaguide.cn/learning/high-performance/deep-pagination-optimization.html"}],["meta",{"property":"og:site_name","content":"Mua'dib Guide "}],["meta",{"property":"og:title","content":"深度分页介绍及优化建议"}],["meta",{"property":"og:description","content":"深度分页介绍 查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如： 深度分页优化建议 这里以 MySQL 数据库为例介绍一下如何优化深度分页。 范围查询 当可以保证 ID 的连续性时，根据 ID 范围进行分页是比较好的解决方案： 这种优化方式限制比较大，且一般项目的 ID 也没办法保证完全连续。 子查询 我们先查询出 limit 第一个参..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://oss.javaguide.cn/github/javaguide/mysql/alibaba-java-development-handbook-paging.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-02T14:29:03.000Z"}],["meta",{"property":"article:author","content":"Guide"}],["meta",{"property":"article:modified_time","content":"2024-09-02T14:29:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深度分页介绍及优化建议\\",\\"image\\":[\\"https://oss.javaguide.cn/github/javaguide/mysql/alibaba-java-development-handbook-paging.png\\"],\\"dateModified\\":\\"2024-09-02T14:29:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guide\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]],"description":"深度分页介绍 查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如： 深度分页优化建议 这里以 MySQL 数据库为例介绍一下如何优化深度分页。 范围查询 当可以保证 ID 的连续性时，根据 ID 范围进行分页是比较好的解决方案： 这种优化方式限制比较大，且一般项目的 ID 也没办法保证完全连续。 子查询 我们先查询出 limit 第一个参..."},"headers":[{"level":2,"title":"深度分页介绍","slug":"深度分页介绍","link":"#深度分页介绍","children":[]},{"level":2,"title":"深度分页优化建议","slug":"深度分页优化建议","link":"#深度分页优化建议","children":[{"level":3,"title":"范围查询","slug":"范围查询","link":"#范围查询","children":[]},{"level":3,"title":"子查询","slug":"子查询","link":"#子查询","children":[]},{"level":3,"title":"延迟关联","slug":"延迟关联","link":"#延迟关联","children":[]},{"level":3,"title":"覆盖索引","slug":"覆盖索引","link":"#覆盖索引","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1725287343000,"updatedTime":1725287343000,"contributors":[{"name":"tonygong","email":"280880907@163.com","commits":1}]},"readingTime":{"minutes":3.9,"words":1171},"filePathRelative":"high-performance/deep-pagination-optimization.md","localizedDate":"2024年9月2日","excerpt":"<h2>深度分页介绍</h2>\\n<p>查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如：</p>\\n<div class=\\"language-sql\\" data-ext=\\"sql\\" data-title=\\"sql\\"><pre class=\\"language-sql\\"><code><span class=\\"token comment\\"># MySQL 在无法利用索引的情况下跳过1000000条记录后，再获取10条记录</span>\\n<span class=\\"token keyword\\">SELECT</span> <span class=\\"token operator\\">*</span> <span class=\\"token keyword\\">FROM</span> t_order <span class=\\"token keyword\\">ORDER</span> <span class=\\"token keyword\\">BY</span> id <span class=\\"token keyword\\">LIMIT</span> <span class=\\"token number\\">1000000</span><span class=\\"token punctuation\\">,</span> <span class=\\"token number\\">10</span>\\n</code></pre></div>","autoDesc":true}`);export{b as comp,w as data};
