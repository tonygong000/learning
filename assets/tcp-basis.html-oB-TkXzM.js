import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,e as n}from"./app-ChWUTpfW.js";const a="/learning/assets/tcp-message-AbZQ1qw2.webp",p="/learning/assets/tcp-establish-CXg2_9CH.webp",r={},s=n('<h2 id="tcp报文格式" tabindex="-1"><a class="header-anchor" href="#tcp报文格式"><span>TCP报文格式</span></a></h2><figure><img src="'+a+'" alt="" tabindex="0"><figcaption></figcaption></figure><ul><li><p><strong>源端口 和 目标端口</strong>：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。</p></li><li><p><strong>序列号</strong>：共占用 4个字节。说明序列号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。当序号增加到 4294967296 后，下一个序号将回到0重新开始。在建立连接时由计算机生成的随机数作为其初始值（ISN，即Initial Sequence Number，初始序列号），通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小（其中要注意的是 SYN 和 FIN 包的 seq 也要消耗一个序号）。用来解决网络包乱序问题。</p></li><li><p><strong>确认号</strong>：共占用 4个字节。说明确认号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。它表示期望收到对方下一次数据的序列号（所以 ack 一般都是上次接收成功的数据字节序号加1），发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。TCP在接收到数据后 200ms 才会发送ACK包，这种设定是为了等待是否有数据可以一起发送的。</p></li><li><p><strong>数据偏移</strong>：共占 4 个bit，它表示的是TCP报文的数据起始处距离TCP报文起始处的距离有多远。实际生活中我们说距离多远，我们的单位通常是米，而这里距离有多远，单位是 4 个字节（也就是 32bit）。由于 4 个bit，能表示的最大整数是 15，也就说明 TCP 报文里数据开始的位置距离报文起点是 60 个字节（4*15）。这意味着 TCP 的首部（除数据外的都叫首部）长度是 20-60 个字节。</p></li><li><p><strong>窗口</strong>：共占 16 个bit，因此最大的窗口大小为 2^16-1 = 65535 = 64k。这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项里加一个 窗口扩大选项，来传输更多的数据。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p></li></ul><h2 id="tcp连接建立步骤" tabindex="-1"><a class="header-anchor" href="#tcp连接建立步骤"><span>TCP连接建立步骤</span></a></h2><figure><img src="'+p+'" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="异常情况分析" tabindex="-1"><a class="header-anchor" href="#异常情况分析"><span>异常情况分析</span></a></h2><h3 id="试图与一个某端口建立连接但该主机已经宕机-主机宕机" tabindex="-1"><a class="header-anchor" href="#试图与一个某端口建立连接但该主机已经宕机-主机宕机"><span>试图与一个某端口建立连接但该主机已经宕机(主机宕机)</span></a></h3><p>这也是一种比较常见的情况，当某台服务器主机宕机了，而客户端并不知道，因此会重复发送SYNC数据包.</p><p>如下图所示，可以看到客户端每隔一段时间就会向服务端发送一个SYNC数据包。这里面具体的时间是跟TCP协议相关的，具体时间不同的操作系统实现可能稍有不同。</p><h3 id="建立连接时-服务器应用被阻塞-或者僵死" tabindex="-1"><a class="header-anchor" href="#建立连接时-服务器应用被阻塞-或者僵死"><span>建立连接时，服务器应用被阻塞(或者僵死)</span></a></h3><p>还有一种异常情况是，客户端建立连接的过程中服务端应用处于僵死状态，这种情况在实际中也会经常出现(我们假设仅仅应用程序僵死，而内核没有僵死)。</p><p>对于TCP的服务端来说，当它收到SYN数据包时，就会创建一个套接字的数据结构并给客户端回复ACK，再次收到客户端的ACK时会将套接字数据结构的状态转换为ESTABLISHED，并将其加入就绪队列。</p><p>当上面的套接字处于就绪队列时，accept函数才被唤醒了，可以从套接字中读取数据。</p><p>在 accept 返回之前，客户端也是可以发送数据的，因为数据的发送与接收都是在内核态进行的。客户端发送数据后，服务端的网卡会先接收，然后通过中断通知IP层，再上传到TCP层。TCP层根据目的端口和地址将数据存入关联的缓冲区。</p><p>到此，可以得出几点结论。</p><ul><li>在 accept 返回之前，三次握手已经完成。</li><li>TCP的客户端是否可以发送数据与服务端程序是否工作没有关系。</li></ul><p>但是如果内核也处于僵死状态，那情况可就完全不一样了。</p><p>此时由于机器完全卡死，TCP服务端无法接受任何消息，自然也无法给客户端发送任何应答报文，也不会有后续发送数据的环节了。</p>',18),c=[s];function o(l,g){return e(),i("div",null,c)}const m=t(r,[["render",o],["__file","tcp-basis.html.vue"]]),P=JSON.parse(`{"path":"/cs-basics/network/tcp-basis.html","title":"TCP基础","lang":"zh-CN","frontmatter":{"title":"TCP基础","category":"计算机基础","tag":["计算机网络"],"description":"TCP报文格式 源端口 和 目标端口：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。 序列号：共占用 4个字节。说明序列号的范围是 [0, ...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/learning/cs-basics/network/tcp-basis.html"}],["meta",{"property":"og:site_name","content":"Mua'dib Guide "}],["meta",{"property":"og:title","content":"TCP基础"}],["meta",{"property":"og:description","content":"TCP报文格式 源端口 和 目标端口：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。 序列号：共占用 4个字节。说明序列号的范围是 [0, ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-31T05:42:06.000Z"}],["meta",{"property":"article:author","content":"Guide"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:modified_time","content":"2024-08-31T05:42:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"TCP基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-31T05:42:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guide\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"TCP报文格式","slug":"tcp报文格式","link":"#tcp报文格式","children":[]},{"level":2,"title":"TCP连接建立步骤","slug":"tcp连接建立步骤","link":"#tcp连接建立步骤","children":[]},{"level":2,"title":"异常情况分析","slug":"异常情况分析","link":"#异常情况分析","children":[{"level":3,"title":"试图与一个某端口建立连接但该主机已经宕机(主机宕机)","slug":"试图与一个某端口建立连接但该主机已经宕机-主机宕机","link":"#试图与一个某端口建立连接但该主机已经宕机-主机宕机","children":[]},{"level":3,"title":"建立连接时，服务器应用被阻塞(或者僵死)","slug":"建立连接时-服务器应用被阻塞-或者僵死","link":"#建立连接时-服务器应用被阻塞-或者僵死","children":[]}]}],"git":{"createdTime":1725082926000,"updatedTime":1725082926000,"contributors":[{"name":"Tony Gong","email":"a280880907@163.com","commits":1}]},"readingTime":{"minutes":4.35,"words":1306},"filePathRelative":"cs-basics/network/tcp-basis.md","localizedDate":"2024年8月31日","excerpt":"<h2>TCP报文格式</h2>\\n<figure><figcaption></figcaption></figure>\\n<ul>\\n<li>\\n<p><strong>源端口 和 目标端口</strong>：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。</p>\\n</li>\\n<li>\\n<p><strong>序列号</strong>：共占用 4个字节。说明序列号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。当序号增加到 4294967296 后，下一个序号将回到0重新开始。在建立连接时由计算机生成的随机数作为其初始值（ISN，即Initial Sequence Number，初始序列号），通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小（其中要注意的是 SYN 和 FIN 包的 seq 也要消耗一个序号）。用来解决网络包乱序问题。</p>\\n</li>\\n<li>\\n<p><strong>确认号</strong>：共占用 4个字节。说明确认号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。它表示期望收到对方下一次数据的序列号（所以 ack 一般都是上次接收成功的数据字节序号加1），发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。TCP在接收到数据后 200ms 才会发送ACK包，这种设定是为了等待是否有数据可以一起发送的。</p>\\n</li>\\n<li>\\n<p><strong>数据偏移</strong>：共占 4 个bit，它表示的是TCP报文的数据起始处距离TCP报文起始处的距离有多远。实际生活中我们说距离多远，我们的单位通常是米，而这里距离有多远，单位是 4 个字节（也就是 32bit）。由于 4 个bit，能表示的最大整数是 15，也就说明 TCP 报文里数据开始的位置距离报文起点是 60 个字节（4*15）。这意味着 TCP 的首部（除数据外的都叫首部）长度是 20-60 个字节。</p>\\n</li>\\n<li>\\n<p><strong>窗口</strong>：共占 16 个bit，因此最大的窗口大小为 2^16-1 = 65535 = 64k。这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项里加一个 窗口扩大选项，来传输更多的数据。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>\\n</li>\\n</ul>","autoDesc":true}`);export{m as comp,P as data};
