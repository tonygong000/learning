<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://javaguide.cn/learning/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://javaguide.cn/learning/</id>
  <title>Mua&amp;apos;dib Guide </title>
  <subtitle>「Java学习指北 + Java面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，复习 Java 知识点，首选 Mua&amp;apos;dib Guide ！  </subtitle>
  <icon>https://javaguide.cn/learning/favicon.ico</icon>
  <updated>2024-08-28T17:07:58.731Z</updated>
  <generator>@vuepress/plugin-feed</generator>
  <link rel="self" href="https://javaguide.cn/learning/atom.xml"/>
  <link rel="alternate" href="https://javaguide.cn/learning/"/>
  <category term="projects"/>
  <category term="cs-basis"/>
  <category term="java"/>
  <category term="network"/>
  <category term="linux"/>
  <category term="web"/>
  <category term="论文"/>
  <category term="计算机基础"/>
  <category term="vue"/>
  <category term="神经网络"/>
  <category term="genkins"/>
  <category term="开发工具"/>
  <category term="Transformer"/>
  <category term="markdown"/>
  <category term="node.js"/>
  <category term="vcs"/>
  <category term="Linux"/>
  <category term="数据库"/>
  <category term="系统设计"/>
  <category term="Java"/>
  <category term="高性能"/>
  <category term="技术文章精选集"/>
  <category term="框架"/>
  <category term="知识星球"/>
  <category term="走近项目"/>
  <category term="分布式"/>
  <category term="面试准备"/>
  <category term="高可用"/>
  <contributor>
    <name>CityDreamer部落</name>
  </contributor>
  <contributor>
    <name>知了一笑</name>
  </contributor>
  <contributor>
    <name>CodingBetterLife</name>
  </contributor>
  <entry>
    <title type="text">MQTT</title>
    <id>https://javaguide.cn/learning/AloT/IoT/MQTT.html</id>
    <link href="https://javaguide.cn/learning/AloT/IoT/MQTT.html"/>
    <updated>2024-08-28T14:30:37.000Z</updated>
    <summary type="html"><![CDATA[<h2>介绍</h2>
<p>MQTT is an <strong>OASIS</strong> standard messaging protocol for the Internet of Things (IoT).<br>
It is designed as an extremely lightweight <strong>publish/subscribe</strong> messaging transport that is ideal for connecting<br>
remote devices with a small code footprint and minimal network bandwidth.</p>]]></summary>
    <content type="html"><![CDATA[<h2>介绍</h2>
<p>MQTT is an <strong>OASIS</strong> standard messaging protocol for the Internet of Things (IoT).<br>
It is designed as an extremely lightweight <strong>publish/subscribe</strong> messaging transport that is ideal for connecting<br>
remote devices with a small code footprint and minimal network bandwidth.</p>
<h3>基本结构</h3>
<figure><figcaption></figcaption></figure>
]]></content>
    <published>2024-08-28T14:30:37.000Z</published>
  </entry>
  <entry>
    <title type="text">头文件</title>
    <id>https://javaguide.cn/learning/c__/headFile.html</id>
    <link href="https://javaguide.cn/learning/c__/headFile.html"/>
    <updated>2024-07-09T06:25:49.000Z</updated>
    <summary type="html"><![CDATA[<h2>头文件调用</h2>
<h3>hpp头文件调用类</h3>
<p><br>
<br>
</p>
<h3>h头文件调用方法</h3>
]]></summary>
    <content type="html"><![CDATA[<h2>头文件调用</h2>
<h3>hpp头文件调用类</h3>
<p><br>
<br>
</p>
<h3>h头文件调用方法</h3>
]]></content>
    <published>2024-07-09T06:25:49.000Z</published>
  </entry>
  <entry>
    <title type="text">基本概念</title>
    <id>https://javaguide.cn/learning/AloT/basis.html</id>
    <link href="https://javaguide.cn/learning/AloT/basis.html"/>
    <updated>2024-07-09T07:01:21.000Z</updated>
    <summary type="html"><![CDATA[<h2>AIoT</h2>
<ul>
<li>create more efficient IoT operations,</li>
<li>improve human-machine interactions</li>
<li>enhance data management and analytics.</li>
</ul>
<p>API ensure the connection from the end user to the machine.</p>
<p>Data collected by IoT devices are used by AI to give insights</p>
]]></summary>
    <content type="html"><![CDATA[<h2>AIoT</h2>
<ul>
<li>create more efficient IoT operations,</li>
<li>improve human-machine interactions</li>
<li>enhance data management and analytics.</li>
</ul>
<p>API ensure the connection from the end user to the machine.</p>
<p>Data collected by IoT devices are used by AI to give insights</p>
<h3>cloud-based AIoT</h3>
<p>Management and processing of data from AIoT devices on the cloud platform; and by the platform various<br>
services and applications can process and access it.</p>
<figure><figcaption>cloud-based AIoT structure</figcaption></figure>
<h3>edge-base AIoT</h3>
<p>Data should be processed as close to the AIoT devices as possible to <strong>minimize the bandwidth</strong><br>
needed to move data.<br>
</p>
]]></content>
    <published>2024-07-02T16:23:45.000Z</published>
  </entry>
  <entry>
    <title type="text"></title>
    <id>https://javaguide.cn/learning/knowledge/</id>
    <link href="https://javaguide.cn/learning/knowledge/"/>
    <updated>2024-07-01T15:02:09.000Z</updated>
    <summary type="html"><![CDATA[<p>计算机必备知识</p>
]]></summary>
    <content type="html"><![CDATA[<p>计算机必备知识</p>
]]></content>
    <published>2024-07-01T15:02:09.000Z</published>
  </entry>
  <entry>
    <title type="text">综合项目实践</title>
    <id>https://javaguide.cn/learning/projects/general-projects.html</id>
    <link href="https://javaguide.cn/learning/projects/general-projects.html"/>
    <updated>2024-07-01T15:02:09.000Z</updated>
    <category term="projects"/>
    <published>2024-07-01T15:02:09.000Z</published>
  </entry>
  <entry>
    <title type="text"></title>
    <id>https://javaguide.cn/learning/projects/</id>
    <link href="https://javaguide.cn/learning/projects/"/>
    <updated>2024-07-01T15:02:09.000Z</updated>
    <summary type="html"><![CDATA[<p>这是本人大学期间所做项目的经验</p>
]]></summary>
    <content type="html"><![CDATA[<p>这是本人大学期间所做项目的经验</p>
]]></content>
    <published>2024-07-01T15:02:09.000Z</published>
  </entry>
  <entry>
    <title type="text">大创项目</title>
    <id>https://javaguide.cn/learning/projects/WebAPI.html</id>
    <link href="https://javaguide.cn/learning/projects/WebAPI.html"/>
    <updated>2024-07-01T15:53:32.000Z</updated>
    <summary type="html"><![CDATA[<h2>表达式树</h2>
<p>表达式树由一系列表达式节点（Expression Node）组成，每个节点表示代码中的一个操作或值。这些节点有不同的类型，例如：</p>
<h2>查询表达式</h2>
<div class="language-csharp" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name">IQueryable<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">&gt;</span></span> <span class="token function">SearchObjects</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> funcName<span class="token punctuation">,</span> <span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> objs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppException</span><span class="token punctuation">(</span><span class="token string">"未设置数据库连接上下文"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searchDic<span class="token punctuation">.</span><span class="token function">ContainsKey</span><span class="token punctuation">(</span>funcName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppException</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"未能找到 </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">funcName</span><span class="token punctuation">}</span></span><span class="token string"> 查询函数"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name"><span class="token keyword">var</span></span> objQuery <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Set</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InterceptWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">InjectArrayVisitor</span><span class="token punctuation">(</span>objs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InjectConditionVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>DelDate <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">OrderByDescending</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>CreateDate<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> searchDic<span class="token punctuation">[</span>funcName<span class="token punctuation">]</span><span class="token punctuation">(</span>objQuery<span class="token punctuation">,</span> objs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>表达式树</h2>
<p>表达式树由一系列表达式节点（Expression Node）组成，每个节点表示代码中的一个操作或值。这些节点有不同的类型，例如：</p>
<h2>查询表达式</h2>
<div class="language-csharp" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name">IQueryable<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">&gt;</span></span> <span class="token function">SearchObjects</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> funcName<span class="token punctuation">,</span> <span class="token keyword">params</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> objs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppException</span><span class="token punctuation">(</span><span class="token string">"未设置数据库连接上下文"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searchDic<span class="token punctuation">.</span><span class="token function">ContainsKey</span><span class="token punctuation">(</span>funcName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppException</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$"未能找到 </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">funcName</span><span class="token punctuation">}</span></span><span class="token string"> 查询函数"</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name"><span class="token keyword">var</span></span> objQuery <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Set</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">InterceptWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">InjectArrayVisitor</span><span class="token punctuation">(</span>objs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InjectConditionVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>DelDate <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">OrderByDescending</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>CreateDate<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> searchDic<span class="token punctuation">[</span>funcName<span class="token punctuation">]</span><span class="token punctuation">(</span>objQuery<span class="token punctuation">,</span> objs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3>自定义的表达式访问器</h3>
<p>主要作用是在表达式树中找到特定类型的表达式节点，并替换这些节点的值。具体来说，它用于处理数组索引表达式，并将这些索引表达式替换为数组中的实际值。</p>
<p>作用：</p>
<ul>
<li>
<p>动态生成查询：在一些场景中，你可能需要动态生成或修改查询。使用表达式访问器可以在运行时对查询进行复杂的修改，而不是在编译时决定查询的所有细节。</p>
</li>
<li>
<p>通用方法：如果有很多类似的查询需要执行，使用表达式访问器可以封装和复用查询修改逻辑。这样可以避免在每个查询中重复相同的代码。</p>
</li>
<li>
<p>复杂条件注入：当查询条件不仅仅是简单的数组索引获取，而是包含更多复杂的逻辑时，表达式访问器可以帮助你处理这些复杂的逻辑。</p>
</li>
<li>
<p>分层结构的查询：在分层结构或多个层次的查询中，访问器可以用于在表达式树的不同层次进行操作和修改。</p>
</li>
</ul>
<div class="language-csharp" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">namespace</span> <span class="token namespace">HiSys<span class="token punctuation">.</span>Utitlizes</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InjectArrayVisitor</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ExpressionVisitor</span></span>
    <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> parameters<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Expression</span> parentExp<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">InjectArrayVisitor</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> pamas<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            parameters <span class="token operator">=</span> pamas<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token function">InjectArrayVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            parameters <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token return-type class-name">Expression</span> <span class="token function">VisitUnary</span><span class="token punctuation">(</span><span class="token class-name">UnaryExpression</span> node<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>NodeType <span class="token operator">==</span> ExpressionType<span class="token punctuation">.</span>Convert<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token class-name"><span class="token keyword">var</span></span> ex <span class="token operator">=</span> node<span class="token punctuation">.</span>Operand <span class="token keyword">as</span> <span class="token class-name">BinaryExpression</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ex<span class="token punctuation">.</span>NodeType <span class="token operator">==</span> ExpressionType<span class="token punctuation">.</span>ArrayIndex <span class="token operator">&amp;&amp;</span> ex<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>NodeType <span class="token operator">==</span> ExpressionType<span class="token punctuation">.</span>Constant <span class="token operator">&amp;&amp;</span> ex<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>Name <span class="token operator">==</span> <span class="token string">"Int32"</span> <span class="token operator">&amp;&amp;</span> ex<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Type<span class="token punctuation">.</span>Name <span class="token operator">==</span> <span class="token string">"Object[]"</span><span class="token punctuation">)</span>
                <span class="token punctuation">{</span>
                    <span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>Right <span class="token keyword">as</span> <span class="token class-name">ConstantExpression</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Value<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> parameters<span class="token punctuation">.</span>Length<span class="token punctuation">)</span>
                    <span class="token punctuation">{</span>
                        <span class="token class-name"><span class="token keyword">var</span></span> val <span class="token operator">=</span> parameters<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token class-name"><span class="token keyword">var</span></span> valueProvider <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ValueProviderResult</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> val<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> CultureInfo<span class="token punctuation">.</span>CurrentCulture<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span> Expression<span class="token punctuation">.</span><span class="token function">Constant</span><span class="token punctuation">(</span>valueProvider<span class="token punctuation">.</span><span class="token function">ConvertTo</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">,</span> node<span class="token punctuation">.</span>Type<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">else</span>
                        <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">VisitUnary</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">VisitUnary</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//遍历表达式树，查找所有的类型转换操作（ExpressionType.Convert）。</span>
        <span class="token comment">//检查被转换的表达式是否是数组索引操作（如 (decimal)parameters[0]）。</span>
        <span class="token comment">//获取数组索引的值，并从 parameters 数组中提取相应的参数值。</span>
        <span class="token comment">//使用提取的参数值创建一个新的常量表达式，并替换原始的数组索引表达式。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>搜索方法</h2>
<h3>条件搜索</h3>
<div class="language-csharp" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name">IQueryable<span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span> <span class="token function">SearchObjects</span><span class="token punctuation">(</span><span class="token class-name">Expression<span class="token punctuation">&lt;</span>Func<span class="token punctuation">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> condition<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>context <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AppException</span><span class="token punctuation">(</span><span class="token string">"未设置数据库连接上下文"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name"><span class="token keyword">var</span></span> objQuery <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Set</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>
            objQuery<span class="token operator">=</span>objQuery<span class="token punctuation">.</span><span class="token function">InterceptWith</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">InjectConditionVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">BaseEntity</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">IsAssignableFrom</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                objQuery <span class="token operator">=</span> objQuery<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span>DelDate <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> objQuery<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><h2>委托类型</h2>
<p>作用：</p>
<ol>
<li>
<p>动态查询<br>
委托类型允许在运行时动态定义和更改查询逻辑。这样可以根据具体需求动态生成查询，而不需要在编译时确定所有可能的查询方式。</p>
</li>
<li>
<p>可扩展性<br>
通过使用委托，可以轻松地添加新的查询逻辑，而不需要修改现有代码结构。只需创建新的委托并将其添加到字典中即可，这样新功能可以与旧功能共存。</p>
</li>
<li>
<p>高度可重用性<br>
委托类型使得查询逻辑可以被重用。不同的查询逻辑可以在不同的上下文中被复用，而不需要重复代码。这样减少了代码冗余并提高了代码的可维护性。</p>
</li>
<li>
<p>松耦合<br>
使用委托使得方法之间的耦合度降低。调用方和具体的实现逻辑之间通过委托进行解耦，这样调用方不需要知道具体的实现细节，只需要知道如何调用委托。</p>
</li>
<li>
<p>灵活性<br>
委托类型提供了极大的灵活性，可以根据需要传递不同的参数、执行不同的逻辑。比如，在搜索功能中，可以传递不同的参数来改变搜索的行为，而不需要修改方法签名。</p>
</li>
</ol>
<div class="language-csharp" data-ext="cs" data-title="cs"><pre class="language-csharp"><code> <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">AddSearchFunc</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> funcName<span class="token punctuation">,</span> <span class="token class-name">Func<span class="token punctuation">&lt;</span>IQueryable<span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> IQueryable<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> funcBody<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>funcName <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> funcBody <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>searchDic<span class="token punctuation">.</span><span class="token function">ContainsKey</span><span class="token punctuation">(</span>funcName<span class="token punctuation">)</span><span class="token punctuation">)</span>
                searchDic<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>funcName<span class="token punctuation">,</span> funcBody<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 <span class="token class-name">Func<span class="token punctuation">&lt;</span>IQueryable<span class="token punctuation">&lt;</span>Product<span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> IQueryable<span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> searchByName <span class="token operator">=</span> <span class="token punctuation">(</span>query<span class="token punctuation">,</span> parameters<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">string</span></span> name <span class="token operator">=</span> parameters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token class-name"><span class="token keyword">string</span></span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> query<span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>p <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Cast</span><span class="token generic class-name"><span class="token punctuation">&lt;</span><span class="token keyword">object</span><span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <published>2024-07-01T15:02:09.000Z</published>
  </entry>
  <entry>
    <title type="text">曲面曲线方程</title>
    <id>https://javaguide.cn/learning/knowledge/further-math/curve.html</id>
    <link href="https://javaguide.cn/learning/knowledge/further-math/curve.html"/>
    <updated>2024-07-01T15:02:09.000Z</updated>
    <summary type="html"><![CDATA[<h2>椭球面</h2>
<p><br>
</p>
<h2>二次柱面</h2>
<figure><figcaption>img_2.png</figcaption></figure>
]]></summary>
    <content type="html"><![CDATA[<h2>椭球面</h2>
<p><br>
</p>
<h2>二次柱面</h2>
<figure><figcaption>img_2.png</figcaption></figure>
]]></content>
    <published>2024-07-01T15:02:09.000Z</published>
  </entry>
  <entry>
    <title type="text">用户组</title>
    <id>https://javaguide.cn/learning/linux/usergroup.html</id>
    <link href="https://javaguide.cn/learning/linux/usergroup.html"/>
    <updated>2024-06-05T04:16:51.000Z</updated>
    <summary type="html"><![CDATA[<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">useradd</span> 选项 用户名
</code></pre></div><blockquote>
<p>-c comment 指定一段注释性描述。<br>
-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>
-g 用户组 指定用户所属的用户组。<br>
-G 用户组，用户组 指定用户所属的附加组。<br>
-s Shell文件 指定用户的登录Shell。<br>
-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">useradd</span> 选项 用户名
</code></pre></div><blockquote>
<p>-c comment 指定一段注释性描述。<br>
-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。<br>
-g 用户组 指定用户所属的用户组。<br>
-G 用户组，用户组 指定用户所属的附加组。<br>
-s Shell文件 指定用户的登录Shell。<br>
-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">userdel</span> 选项 用户名
</code></pre></div><blockquote>
<p>常用的选项是 -r，它的作用是把用户的主目录一起删除。</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">usermod</span> 选项 用户名
</code></pre></div>]]></content>
    <published>2024-06-05T04:16:51.000Z</published>
  </entry>
  <entry>
    <title type="text">Python基础</title>
    <id>https://javaguide.cn/learning/python/basis.html</id>
    <link href="https://javaguide.cn/learning/python/basis.html"/>
    <updated>2024-06-05T04:16:51.000Z</updated>
    <summary type="html"><![CDATA[<h2>为什么Python运行慢</h2>
<ol>
<li>解释性语言，边运行边编译，其他语言在运行之前就编译成字节码</li>
<li>动态语言，在运行时可以改变其结构的语言，如新的函数、对象、代码可以被引入；并且因为没有类型定义，数据的比较和转换类型开销大</li>
<li>一切皆对象，每个对象都要维护引用计数</li>
<li>GIL机制，全局互斥锁，在多线程环境下性能开销极大</li>
<li>采用标记和分代的垃圾回收机制，每次垃圾回收都会中断正在执行的程序</li>
</ol>
<h2>优势</h2>
<ol>
<li>效率高。对于很多复杂性功能可以直接用清晰代码写出来</li>
<li>很多科学计算库，方便科研</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>为什么Python运行慢</h2>
<ol>
<li>解释性语言，边运行边编译，其他语言在运行之前就编译成字节码</li>
<li>动态语言，在运行时可以改变其结构的语言，如新的函数、对象、代码可以被引入；并且因为没有类型定义，数据的比较和转换类型开销大</li>
<li>一切皆对象，每个对象都要维护引用计数</li>
<li>GIL机制，全局互斥锁，在多线程环境下性能开销极大</li>
<li>采用标记和分代的垃圾回收机制，每次垃圾回收都会中断正在执行的程序</li>
</ol>
<h2>优势</h2>
<ol>
<li>效率高。对于很多复杂性功能可以直接用清晰代码写出来</li>
<li>很多科学计算库，方便科研</li>
</ol>
]]></content>
    <published>2024-06-05T04:16:51.000Z</published>
  </entry>
  <entry>
    <title type="text">贪心</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/model/greedy.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/model/greedy.html"/>
    <updated>2024-05-31T08:37:44.000Z</updated>
    <summary type="html"><![CDATA[<ol>
<li>区间覆盖</li>
</ol>
<p>给定N个闭区间以及一个线段区间 ，请你选择尽量少的区间，将指定线段区间完全覆盖</p>
<blockquote>
<ul>
<li>将闭区间以左端点大小排序</li>
<li>每一次循环筛选左端点小于start的区间，获取最大的右端点，判断是否大于线段区间右端点
<ul>
<li>若大于，则结束</li>
<li>若小于，令，继续循环</li>
</ul>
</li>
</ul>
</blockquote>
<p>2.<a href="https://www.lanqiao.cn/problems/2216/learning/" target="_blank" rel="noopener noreferrer">图书借阅</a></p>]]></summary>
    <content type="html"><![CDATA[<ol>
<li>区间覆盖</li>
</ol>
<p>给定N个闭区间以及一个线段区间 ，请你选择尽量少的区间，将指定线段区间完全覆盖</p>
<blockquote>
<ul>
<li>将闭区间以左端点大小排序</li>
<li>每一次循环筛选左端点小于start的区间，获取最大的右端点，判断是否大于线段区间右端点
<ul>
<li>若大于，则结束</li>
<li>若小于，令，继续循环</li>
</ul>
</li>
</ul>
</blockquote>
<p>2.<a href="https://www.lanqiao.cn/problems/2216/learning/" target="_blank" rel="noopener noreferrer">图书借阅</a></p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> os
<span class="token keyword">import</span> sys

n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
nums <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
books <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    books<span class="token punctuation">[</span>b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>l<span class="token punctuation">,</span> r<span class="token punctuation">]</span><span class="token punctuation">)</span>
sorted_record <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>


<span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> sorted_record
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    current_record <span class="token operator">=</span> <span class="token number">0</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> record <span class="token keyword">in</span> book<span class="token punctuation">:</span>
        <span class="token keyword">if</span> current_record <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            current_record <span class="token operator">=</span> record
            temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>record<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> record<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> current_record<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            current_record <span class="token operator">=</span> record
            temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>record<span class="token punctuation">)</span>
    sorted_record<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> record <span class="token keyword">in</span> temp<span class="token punctuation">:</span>
        book<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>record<span class="token punctuation">)</span>
    calculate<span class="token punctuation">(</span>book<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token number">0</span>
current_x<span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">for</span> index<span class="token punctuation">,</span> book <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>books<span class="token punctuation">)</span><span class="token punctuation">:</span>
    book<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    calculate<span class="token punctuation">(</span>book<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
sorted_record<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> record <span class="token keyword">in</span> sorted_record<span class="token punctuation">:</span>
    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>record<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        nums<span class="token punctuation">[</span>record<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
        res<span class="token operator">+=</span><span class="token builtin">len</span><span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        current_x<span class="token operator">+=</span><span class="token number">1</span>
        <span class="token keyword">if</span> current_x<span class="token operator">&lt;=</span>x<span class="token punctuation">:</span>
            res<span class="token operator">+=</span><span class="token builtin">len</span><span class="token punctuation">(</span>record<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>

<span class="token comment"># 请在此输入您的代码</span>
</code></pre></div>]]></content>
    <published>2024-05-26T16:37:58.000Z</published>
  </entry>
  <entry>
    <title type="text">蓝桥杯题目学习</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/lanqiao.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/lanqiao.html"/>
    <updated>2024-05-26T06:02:21.000Z</updated>
    <summary type="html"><![CDATA[<ol>
<li><a href="https://www.lanqiao.cn/problems/2211/learning/" target="_blank" rel="noopener noreferrer">六六大顺</a></li>
</ol>
<p>涉及python数的精度(Decimal)</p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal<span class="token punctuation">,</span> getcontext
getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">1000000000</span>
n<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">**</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span> <span class="token operator">-</span> Decimal<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span>
        <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> Decimal<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<ol>
<li><a href="https://www.lanqiao.cn/problems/2211/learning/" target="_blank" rel="noopener noreferrer">六六大顺</a></li>
</ol>
<p>涉及python数的精度(Decimal)</p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal<span class="token punctuation">,</span> getcontext
getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">1000000000</span>
n<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">**</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span> <span class="token operator">-</span> Decimal<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span>
        <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> Decimal<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>]]></content>
    <published>2024-05-26T06:02:21.000Z</published>
  </entry>
  <entry>
    <title type="text">项目进度和成本管理</title>
    <id>https://javaguide.cn/learning/software-project/project-management/project-process-and-cost-management.html</id>
    <link href="https://javaguide.cn/learning/software-project/project-management/project-process-and-cost-management.html"/>
    <updated>2024-05-26T06:02:21.000Z</updated>
    <summary type="html"><![CDATA[<h2>项目活动</h2>
<p>项目活动就是把项目的工作量分解为易管理的具体任务，而每一项任务都要有明确的时间和资源的限制，它是项目进度表编制的基础<br>
</p>
<h2>关键路径分析</h2>
<h3>关键路径</h3>
<p>在项目网络中有一条路线的时间最长。这条路线决定着项目的工期时间，称之为关键路径。</p>
<p>位于关键路径上的活动就是关键项目活动。</p>
<h3>活动缓冲期</h3>
<ol>
<li>任何关键活动的延迟都会导致项目预估工期的延期，所以关键活动的缓冲期都是0。(下图A,B,E,G,H是关键活动，他们缓冲期为0）</li>
<li>非关键活动缓冲期计算：找出下一条最长路径temp，$$\text{活动缓冲期}=\text{关键路径时间} - \text{路径temp时间}$$<br>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>项目活动</h2>
<p>项目活动就是把项目的工作量分解为易管理的具体任务，而每一项任务都要有明确的时间和资源的限制，它是项目进度表编制的基础<br>
</p>
<h2>关键路径分析</h2>
<h3>关键路径</h3>
<p>在项目网络中有一条路线的时间最长。这条路线决定着项目的工期时间，称之为关键路径。</p>
<p>位于关键路径上的活动就是关键项目活动。</p>
<h3>活动缓冲期</h3>
<ol>
<li>任何关键活动的延迟都会导致项目预估工期的延期，所以关键活动的缓冲期都是0。(下图A,B,E,G,H是关键活动，他们缓冲期为0）</li>
<li>非关键活动缓冲期计算：找出下一条最长路径temp，$$\text{活动缓冲期}=\text{关键路径时间} - \text{路径temp时间}$$<br>
</li>
</ol>
<h3>压缩工期</h3>
<p>就是压缩关键路径</p>
<h2>网络模型的遍历</h2>
<h3>正向遍历</h3>
<p>就是按照活动开始到活动结束的顺序对网络中的每个活动进行遍历。通过执行正向遍历来计算出每个活动最早开始和最早结束时间</p>
<h3>反向遍历</h3>
<p>按照活动结束到活动开始的倒序对网络中的每个活动进行遍历。通过执行反向遍历来计算出每个活动最迟开始和最迟结束时间</p>
<h2>作业</h2>
]]></content>
    <published>2024-05-26T06:02:21.000Z</published>
  </entry>
  <entry>
    <title type="text">acwing题目</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/acwing/acwing.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/acwing/acwing.html"/>
    <updated>2024-05-26T06:02:21.000Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/description/317/" target="_blank" rel="noopener noreferrer">315.旅行</a></p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
len1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
len2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> b<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
            <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> forward<span class="token punctuation">,</span>res
    <span class="token keyword">if</span> start1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> start2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        newtemp<span class="token operator">=</span><span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>newtemp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        temp<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        temp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>


search<span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<p><a href="https://www.acwing.com/problem/content/description/317/" target="_blank" rel="noopener noreferrer">315.旅行</a></p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
len1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
len2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> b<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
            <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> forward<span class="token punctuation">,</span>res
    <span class="token keyword">if</span> start1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> start2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        newtemp<span class="token operator">=</span><span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>newtemp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        temp<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        temp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>


search<span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>]]></content>
    <published>2024-05-26T06:02:21.000Z</published>
  </entry>
  <entry>
    <title type="text">动态规划</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/model/dp.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/model/dp.html"/>
    <updated>2024-06-07T08:37:59.000Z</updated>
    <summary type="html"><![CDATA[<ol>
<li><a href="https://www.acwing.com/problem/content/description/317/" target="_blank" rel="noopener noreferrer">315.旅行</a>
<blockquote>
<p>LCS问题+路径输出</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
len1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
len2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> b<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
            <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> forward<span class="token punctuation">,</span>res
    <span class="token keyword">if</span> start1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> start2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        newtemp<span class="token operator">=</span><span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>newtemp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        temp<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        temp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>


search<span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<ol>
<li><a href="https://www.acwing.com/problem/content/description/317/" target="_blank" rel="noopener noreferrer">315.旅行</a>
<blockquote>
<p>LCS问题+路径输出</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>a <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
len1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
len2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
forward <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> b<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
            <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                forward<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> forward<span class="token punctuation">,</span>res
    <span class="token keyword">if</span> start1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> start2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        newtemp<span class="token operator">=</span><span class="token punctuation">[</span>temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>newtemp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token keyword">if</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        temp<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        temp<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> forward<span class="token punctuation">[</span>start1<span class="token punctuation">]</span><span class="token punctuation">[</span>start2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>
        search<span class="token punctuation">(</span>start1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> start2<span class="token punctuation">,</span> temp<span class="token punctuation">)</span>
        search<span class="token punctuation">(</span>start1<span class="token punctuation">,</span> start2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> temp<span class="token punctuation">)</span>


search<span class="token punctuation">(</span>len1<span class="token punctuation">,</span> len2<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">set</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
res<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> res<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2">
<li><a href="https://www.luogu.com.cn/problem/P1108" target="_blank" rel="noopener noreferrer">低价购买</a>
<blockquote>
<p>最长下降序列+方案数（对最长下降子序列DP数组的dp）</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>
n <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
stocks <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
res <span class="token operator">=</span> <span class="token number">1</span>
t<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n
nums <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> stocks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> stocks<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">and</span> stocks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>stocks<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span>t<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">elif</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">and</span> stocks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>stocks<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>res<span class="token punctuation">:</span>
        nums<span class="token operator">+=</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> nums<span class="token punctuation">)</span>
</code></pre></div><ol start="3">
<li><a href="https://www.acwing.com/problem/content/description/3999/" target="_blank" rel="noopener noreferrer">涂色</a>
<blockquote>
<p>区间DP</p>
</blockquote>
</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>n=int(input())
o_colors=list(map(int,input().split()))
colors=[o_colors[0]]
for i in range(1,n):
    if o_colors[i]==o_colors[i-1]:
        continue
    else:
        colors.append(o_colors[i])
t_n=len(colors)

if t_n==1:
    print(0)
elif t_n==2:
    print(1)
else:
    dp = [[0] * t_n for i in range(t_n)]
    for increment in range(1,t_n):

        for i in range(0,t_n-1):
            if increment == 1:
                dp[i][i+increment]=1
                continue
            j=i+increment
            if j&gt;=t_n:
                break
            if colors[i]==colors[j]:
                dp[i][j]=dp[i+1][j-1]+1
            else:
                dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1
    print(dp[0][t_n-1])
</code></pre></div><ol start="4">
<li><a href="https://www.acwing.com/problem/content/description/2808/" target="_blank" rel="noopener noreferrer">涂色</a>
<blockquote>
<p>区间DP</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>s<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
target<span class="token operator">=</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        target<span class="token punctuation">.</span>append<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>
dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">for</span> increment <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        j<span class="token operator">=</span>i<span class="token operator">+</span>increment
        <span class="token keyword">if</span> j<span class="token operator">&gt;=</span>n<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">if</span> target<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>target<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> z <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>z<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>5.<a href="https://www.luogu.com.cn/problem/P10395" target="_blank" rel="noopener noreferrer">青蛙寻青</a></p>
<blockquote>
<p>DP,求修改的最小次数，<br>
在设置DP数组时要注意某些不可被取到的DP索引的数值</p>
<p>这里是min（）函数，所以需要初始化不可取到的DP值为INF</p>
</blockquote>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>n<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
a <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    current <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> current<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> current<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            current<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> m<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
<span class="token keyword">if</span> <span class="token keyword">not</span> judge<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    tempa <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> tempa<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            tempa<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    a <span class="token operator">=</span> tempa
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000000</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> i <span class="token operator">&gt;</span> j<span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000000</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">if</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div>]]></content>
    <published>2024-05-26T06:02:21.000Z</published>
  </entry>
  <entry>
    <title type="text">软件项目管理介绍</title>
    <id>https://javaguide.cn/learning/software-project/project-management/intro.html</id>
    <link href="https://javaguide.cn/learning/software-project/project-management/intro.html"/>
    <updated>2024-05-23T05:03:08.000Z</updated>
    <summary type="html"><![CDATA[<p>这是我大三下学期学习的课程，要写各种软件项目计划书。</p>
]]></summary>
    <content type="html"><![CDATA[<p>这是我大三下学期学习的课程，要写各种软件项目计划书。</p>
]]></content>
    <published>2024-05-23T05:03:08.000Z</published>
  </entry>
  <entry>
    <title type="text">项目估算</title>
    <id>https://javaguide.cn/learning/software-project/project-management/project-estimate.html</id>
    <link href="https://javaguide.cn/learning/software-project/project-management/project-estimate.html"/>
    <updated>2024-05-23T05:03:08.000Z</updated>
    <summary type="html"><![CDATA[<h2>基本内容</h2>
<p>在项目实施之前，在计划过程中完成</p>
<ul>
<li>规模估算</li>
<li>工作量估算</li>
<li>进度估算</li>
<li>风险估算</li>
<li>其他估算</li>
</ul>
<h2>基本估算方法</h2>
<h2>软件规模估算</h2>
<h3>德尔菲法</h3>
<figure><figcaption></figcaption></figure>
<h3>代码行估算法</h3>
<p>LOC指所有可执行的源代码行数，包括控制语句、数据定义、数据类型声明、等价声明、格式声明等</p>
<ul>
<li>SLOC (single line of code)</li>
<li>KLOC (thousand lines of code)</li>
<li>LLOC (logical line of code)</li>
<li>PLOC (physical line of code)</li>
<li>NCLOC (non-commented line of code)</li>
<li>DSI (delivered source instruction)</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>基本内容</h2>
<p>在项目实施之前，在计划过程中完成</p>
<ul>
<li>规模估算</li>
<li>工作量估算</li>
<li>进度估算</li>
<li>风险估算</li>
<li>其他估算</li>
</ul>
<h2>基本估算方法</h2>
<h2>软件规模估算</h2>
<h3>德尔菲法</h3>
<figure><figcaption></figcaption></figure>
<h3>代码行估算法</h3>
<p>LOC指所有可执行的源代码行数，包括控制语句、数据定义、数据类型声明、等价声明、格式声明等</p>
<ul>
<li>SLOC (single line of code)</li>
<li>KLOC (thousand lines of code)</li>
<li>LLOC (logical line of code)</li>
<li>PLOC (physical line of code)</li>
<li>NCLOC (non-commented line of code)</li>
<li>DSI (delivered source instruction)</li>
</ul>
<h2>工作量估算</h2>
<h3>COCOMO模型</h3>
<p>构造性成本模型(COCOMO：constructive cost model)是一种精确、易于使用的基于模型的成本估算方法：</p>
<ol>
<li>基本COCOMO模型，静态单变量模型，用 <strong>已估算出来的源代码行数(LOC)</strong> 为自变量的函数来计算软件开发工作量。</li>
<li>中间COCOMO模型，在用LOC为自变量的函数计算软件开发工作量的基础上，再用涉及产品、硬件、人员、项目等方面属性的影响因素来调整工作量的估算。</li>
<li>详细COCOMO模型，包括中间COCOMO模型的所有特性，但用上述各种影响因素调整工作量估算时，还要考虑对软件工程过程中分析、设计等各步骤的影响。</li>
</ol>
<h3>COCOMO基本变量</h3>
<ol>
<li>DSI(源指令条数)，定义为代码行数，包括除注释行以外的全部代码。若一行有两个语句，则算做一条指令。KDSI即为千代码行数。</li>
<li>MM(估算单位为人月)表示开发工作量。</li>
<li>TDEV(估算单位为月)表示开发进度，由工作量决定。</li>
</ol>
<h3>COCOMO计算公式</h3>
<figure><figcaption></figcaption></figure>
]]></content>
    <published>2024-05-23T05:03:08.000Z</published>
  </entry>
  <entry>
    <title type="text">图论</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/model/graph.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/model/graph.html"/>
    <updated>2024-05-31T07:51:16.000Z</updated>
    <summary type="html"><![CDATA[<h2>二分图最大匹配</h2>
<h3>匈牙利算法</h3>
<p>将问题看成从N个男生寻找M个女生的对象</p>
<ol>
<li>遍历男生，首先遍历这一轮的男生a的潜在发展对象，</li>
<li>如果潜在女朋友有男朋友b，则劝说这个男朋友b能否换一个</li>
<li>遍历这个男朋友b的潜在女朋友，看是否能成功找一个空着的
<ul>
<li>如果可以，男生b则换新的女朋友</li>
<li>如果不行，男生a只能接着遍历之后的潜在女朋友</li>
</ul>
</li>
<li>遍历完所有都没有的话，就单身</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> e <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
edges <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s<span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token operator">-=</span><span class="token number">1</span>
    t<span class="token operator">-=</span><span class="token number">1</span>
    <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
        edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>t<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
relation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> m
visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
time <span class="token operator">=</span> <span class="token number">0</span>
res <span class="token operator">=</span> <span class="token number">0</span>


<span class="token keyword">def</span> <span class="token function">hungry</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> visited<span class="token punctuation">,</span> time<span class="token punctuation">,</span> relation
    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">==</span> time<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> time
    <span class="token keyword">for</span> edge <span class="token keyword">in</span> edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">or</span> hungry<span class="token punctuation">(</span>relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span> <span class="token operator">=</span> s
            <span class="token keyword">return</span> <span class="token boolean">True</span>

    <span class="token keyword">return</span> <span class="token boolean">False</span>


<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">if</span> hungry<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>二分图最大匹配</h2>
<h3>匈牙利算法</h3>
<p>将问题看成从N个男生寻找M个女生的对象</p>
<ol>
<li>遍历男生，首先遍历这一轮的男生a的潜在发展对象，</li>
<li>如果潜在女朋友有男朋友b，则劝说这个男朋友b能否换一个</li>
<li>遍历这个男朋友b的潜在女朋友，看是否能成功找一个空着的
<ul>
<li>如果可以，男生b则换新的女朋友</li>
<li>如果不行，男生a只能接着遍历之后的潜在女朋友</li>
</ul>
</li>
<li>遍历完所有都没有的话，就单身</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code>n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> e <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
edges <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s<span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token operator">-=</span><span class="token number">1</span>
    t<span class="token operator">-=</span><span class="token number">1</span>
    <span class="token keyword">if</span> s <span class="token keyword">not</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
        edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>t<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
relation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> m
visited <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
time <span class="token operator">=</span> <span class="token number">0</span>
res <span class="token operator">=</span> <span class="token number">0</span>


<span class="token keyword">def</span> <span class="token function">hungry</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> visited<span class="token punctuation">,</span> time<span class="token punctuation">,</span> relation
    <span class="token keyword">if</span> visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">==</span> time<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> time
    <span class="token keyword">for</span> edge <span class="token keyword">in</span> edges<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">or</span> hungry<span class="token punctuation">(</span>relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            relation<span class="token punctuation">[</span>edge<span class="token punctuation">]</span> <span class="token operator">=</span> s
            <span class="token keyword">return</span> <span class="token boolean">True</span>

    <span class="token keyword">return</span> <span class="token boolean">False</span>


<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
        <span class="token keyword">continue</span>
    <span class="token keyword">if</span> hungry<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div><h2>最短路径</h2>
<h3>迪杰斯特拉算法</h3>
<p>dis代表从源点到各个点的最短距离，初始化为INF</p>
<p>v代表点是否遍历过</p>
<p>edge代表边和权重</p>
<ol>
<li>找到dis中值最小的点</li>
<li>通过这个点和edge数组来更新dis的值
<ul>
<li>进行松弛</li>
<li>记录这个点已经被遍历过</li>
</ul>
</li>
<li>直至遍历结束</li>
</ol>
<p>例题：</p>
<ol>
<li><a href="https://leetcode.cn/problems/network-delay-time/description/" target="_blank" rel="noopener noreferrer">网络延迟</a></li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">networkDelayTime</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> times<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type times: List[List[int]]
        :type n: int
        :type k: int
        :rtype: int
        """</span>
        edges<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> time <span class="token keyword">in</span> times<span class="token punctuation">:</span>
            <span class="token keyword">if</span> time<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">not</span> <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
                edges<span class="token punctuation">[</span>time<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span>time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                edges<span class="token punctuation">[</span>time<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>time<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>time<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        INF<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>
        v<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n
        dis<span class="token operator">=</span><span class="token punctuation">[</span>INF<span class="token punctuation">]</span><span class="token operator">*</span>n
        dis<span class="token punctuation">[</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            currentMin<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span>
            currentIndex<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>

            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> v<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> currentMin<span class="token operator">&gt;</span>dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        currentIndex<span class="token operator">=</span>j
                        currentMin<span class="token operator">=</span>dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> currentIndex<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            v<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
            <span class="token keyword">if</span> currentIndex <span class="token keyword">in</span> edges<span class="token punctuation">:</span>
                <span class="token keyword">for</span> edge <span class="token keyword">in</span> edges<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    dis<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token builtin">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token operator">+</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> dis<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dis<span class="token punctuation">)</span>
</code></pre></div><h3>floyd算法</h3>
<p><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/" target="_blank" rel="noopener noreferrer">阈值距离内邻居最少的城市</a></p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findTheCity</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">,</span> edges<span class="token punctuation">,</span> distanceThreshold<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type n: int
        :type edges: List[List[int]]
        :type distanceThreshold: int
        :rtype: int
        """</span>
        dis <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> n <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        newedges<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">"inf"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token keyword">for</span> edge <span class="token keyword">in</span> edges<span class="token punctuation">:</span>

            dis<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>edge<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
            dis<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>edge<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>

        ansCity<span class="token operator">=</span>ansNum<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tempnum<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;=</span>distanceThreshold<span class="token punctuation">:</span>
                    tempnum<span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">if</span> tempnum<span class="token operator">&lt;=</span>ansNum<span class="token punctuation">:</span>
                ansNum<span class="token operator">=</span>tempnum
                ansCity<span class="token operator">=</span>i
        <span class="token keyword">return</span> ansCity
</code></pre></div>]]></content>
    <category term="cs-basis"/>
    <published>2024-05-23T05:03:08.000Z</published>
  </entry>
  <entry>
    <title type="text">数论</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/model/math.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/model/math.html"/>
    <updated>2024-05-31T08:43:20.000Z</updated>
    <summary type="html"><![CDATA[<h2>约数个数和约数之和</h2>
<p>一个数质因子分解：</p>
<p>约数个数：</p>
<p>约数之和：</p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> math

a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
primes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


<span class="token keyword">def</span> <span class="token function">getPrimes</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> primes
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> primes<span class="token punctuation">:</span>
                    primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
                num <span class="token operator">=</span> num <span class="token operator">//</span> i
    <span class="token keyword">if</span> num <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        primes<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>


<span class="token keyword">def</span> <span class="token function">p_sum</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token number">0</span>
    temp <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">+=</span> temp
        temp <span class="token operator">*=</span> p
    <span class="token keyword">return</span> res


getPrimes<span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
res <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">for</span> prime <span class="token keyword">in</span> primes<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">*=</span> p_sum<span class="token punctuation">(</span>prime<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>prime<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>约数个数和约数之和</h2>
<p>一个数质因子分解：</p>
<p>约数个数：</p>
<p>约数之和：</p>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> math

a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
primes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


<span class="token keyword">def</span> <span class="token function">getPrimes</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">global</span> primes
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> num <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> primes<span class="token punctuation">:</span>
                    primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
                num <span class="token operator">=</span> num <span class="token operator">//</span> i
    <span class="token keyword">if</span> num <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
        primes<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>


<span class="token keyword">def</span> <span class="token function">p_sum</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token number">0</span>
    temp <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">+=</span> temp
        temp <span class="token operator">*=</span> p
    <span class="token keyword">return</span> res


getPrimes<span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
res <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">for</span> prime <span class="token keyword">in</span> primes<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">*=</span> p_sum<span class="token punctuation">(</span>prime<span class="token punctuation">,</span> primes<span class="token punctuation">[</span>prime<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div><h2>裴蜀定理</h2>
<p>若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</p>
<blockquote>
<p>任意两个数的组合必定是他们gcd的倍数，同样可以推广到更多数：如果这些数的gcd是d，那么他们的组合是d 的倍数，如果d 不是1，那么必然有无限个数无法被组合出来。</p>
</blockquote>
<ol>
<li><a href="https://www.acwing.com/problem/content/description/1228/" target="_blank" rel="noopener noreferrer">包子凑数</a>
<blockquote>
<p>完全背包+裴蜀定理</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">import</span> math

n <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>


<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    nums<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
flag <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    flag<span class="token operator">=</span>math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>flag<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> flag<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"INF"</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    unsupport<span class="token operator">=</span><span class="token number">10010</span>
    dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>unsupport<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>unsupport<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> i<span class="token operator">%</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unsupport <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># for k in range(0, j // nums[i] + 1):</span>
            <span class="token comment">#     if dp[i - 1][j - k * nums[i]] == 1:</span>
            <span class="token comment">#         dp[i][j] = 1</span>
            <span class="token comment">#         break</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">if</span> j<span class="token operator">&gt;=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">and</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
    res <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unsupport <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre></div><h2>卡特兰数</h2>
<p>卡特兰数的几何意义：</p>
<p>在坐标图中表示，从（0,0）出发，每次向x轴或者y轴正方向移动一个单位，到达（n,n）点，且在移动过程中不越过第一象限平分线的移动方案总数</p>
<p><br>
触碰到y=x+1这条线的最终都到了（n-1,n+1），所以卡特兰数为：</p>
<h2>欧几里得算法</h2>
<p>又称辗转相除法</p>
<h3>扩展欧几里得算法</h3>
<p>是欧几里得算法（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，找到整数x、y（其中一个可能是负数），使它们满足贝祖等式<br>
<br>
</p>
<blockquote>
<p>模逆元<br>
<br>
求模逆元<br>
</p>
</blockquote>
<h2>中国剩余定理</h2>
<p>中国剩余定理 (Chinese Remainder Theorem, CRT) 可求解如下形式的一元线性同余方程组（其中 $n_1, n_2, \cdots, n_k $两两互质）：</p>
<h3>过程</h3>
<ol>
<li>计算所有模数的积 n；</li>
<li>对于第 i 个方程：
<ol>
<li>计算 </li>
<li>计算在模  意义下的 逆元</li>
<li>计算（不要对  取模）。</li>
</ol>
</li>
<li>方程组在模 n 意义下的唯一解为： </li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">CRT</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> a<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token number">1</span>
    ans <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> n <span class="token operator">*</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        m <span class="token operator">=</span> n <span class="token operator">//</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        b <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token number">0</span>
        exgcd<span class="token punctuation">(</span>m<span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment"># b * m mod r[i] = 1</span>
        ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> m <span class="token operator">*</span> b <span class="token operator">%</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n
    <span class="token keyword">return</span> <span class="token punctuation">(</span>ans <span class="token operator">%</span> n <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n
</code></pre></div><h2>Python库函数</h2>
<figure><figcaption></figcaption></figure>
<figure><figcaption></figcaption></figure>
]]></content>
    <category term="cs-basis"/>
    <published>2024-05-23T05:03:08.000Z</published>
  </entry>
  <entry>
    <title type="text">TCP编程</title>
    <id>https://javaguide.cn/learning/java/network/tcp.html</id>
    <link href="https://javaguide.cn/learning/java/network/tcp.html"/>
    <updated>2024-05-21T18:05:03.000Z</updated>
    <summary type="html"><![CDATA[<h2>Socket</h2>
<p>Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：<br>
</p>
<h3>服务端</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ServerSocket</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听指定端口</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"server is running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Socket</span> sock <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"connected from "</span> <span class="token operator">+</span> sock<span class="token punctuation">.</span><span class="token function">getRemoteSocketAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token class-name">Socket</span> sock<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sock <span class="token operator">=</span> sock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> input <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">OutputStream</span> output <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ioe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"client disconnected."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> input<span class="token punctuation">,</span> <span class="token class-name">OutputStream</span> output<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"bye"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"ok: "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>Socket</h2>
<p>Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：<br>
</p>
<h3>服务端</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Server</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ServerSocket</span> ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听指定端口</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"server is running..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Socket</span> sock <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"connected from "</span> <span class="token operator">+</span> sock<span class="token punctuation">.</span><span class="token function">getRemoteSocketAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token class-name">Socket</span> sock<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token class-name">Socket</span> sock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sock <span class="token operator">=</span> sock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> input <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">OutputStream</span> output <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ioe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"client disconnected."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> input<span class="token punctuation">,</span> <span class="token class-name">OutputStream</span> output<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> s <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"bye"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"ok: "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>客户端</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Socket</span> sock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 连接指定服务器和端口</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">InputStream</span> input <span class="token operator">=</span> sock<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">OutputStream</span> output <span class="token operator">=</span> sock<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handle</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        sock<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"disconnected."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> input<span class="token punctuation">,</span> <span class="token class-name">OutputStream</span> output<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"[server] "</span> <span class="token operator">+</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&gt;&gt;&gt; "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印提示</span>
            <span class="token class-name">String</span> s <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取一行输入</span>
            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
            writer<span class="token punctuation">.</span><span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> resp <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt; "</span> <span class="token operator">+</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resp<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"bye"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>Socket流</h2>
<p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用Socket实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用InputStream和OutputStream来封装Socket的数据流，这样我们使用Socket的流，</p>
]]></content>
    <category term="java"/>
    <published>2024-05-21T18:05:03.000Z</published>
  </entry>
  <entry>
    <title type="text">UDP编程</title>
    <id>https://javaguide.cn/learning/java/network/udp.html</id>
    <link href="https://javaguide.cn/learning/java/network/udp.html"/>
    <updated>2024-05-21T18:05:03.000Z</updated>
    <summary type="html"><![CDATA[<h2>UDP</h2>
<p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>UDP和TCP都使用0~65535的端口，但是分开使用，互不干扰</p>
<blockquote>
<p>即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
</blockquote>
<h2>服务端</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">DatagramSocket</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramSocket</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听指定端口</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环</span>
    <span class="token comment">// 数据缓冲区:</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ds<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收取一个UDP数据包</span>
    <span class="token comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span>
    <span class="token comment">// 将其按UTF-8编码转换为String:</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送数据:</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token string">"ACK"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    packet<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ds<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>UDP</h2>
<p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>UDP和TCP都使用0~65535的端口，但是分开使用，互不干扰</p>
<blockquote>
<p>即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
</blockquote>
<h2>服务端</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">DatagramSocket</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramSocket</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听指定端口</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 无限循环</span>
    <span class="token comment">// 数据缓冲区:</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ds<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 收取一个UDP数据包</span>
    <span class="token comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span>
    <span class="token comment">// 将其按UTF-8编码转换为String:</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送数据:</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token string">"ACK"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    packet<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ds<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote>
<p>UDP收到数据后需要立即发送数据，因为课户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>
</blockquote>
<h2>DatagramPacket</h2>
<p>DatagramPacket 用于表示一个数据包，并包含发送和接收的数据及其相关的元数据（如目标地址和端口）。</p>
<h3>用于接收数据的构造函数</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>用于发送数据的构造函数</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">InetAddress</span> address <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>
<span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">,</span> address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>主要方法</h3>
<ul>
<li>获取数据：getData() 方法返回数据包中的数据。<br>
byte[] receivedData = packet.getData();</li>
<li>获取数据长度：getLength() 方法返回数据包中的实际数据长度。<br>
int length = packet.getLength();</li>
<li>获取发送端或接收端的地址：getAddress() 方法返回数据包的地址。<br>
InetAddress address = packet.getAddress();</li>
<li>获取端口号：getPort() 方法返回数据包的端口号。<br>
int port = packet.getPort();</li>
</ul>
<h2>客户端</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">DatagramSocket</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ds<span class="token punctuation">.</span><span class="token function">setSoTimeout</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ds<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 连接指定服务器和端口</span>
<span class="token comment">// 发送:</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">DatagramPacket</span> packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
ds<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 接收:</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
packet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatagramPacket</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
ds<span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span>packet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>packet<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> packet<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ds<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 关闭:</span>
ds<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <category term="java"/>
    <published>2024-05-21T18:05:03.000Z</published>
  </entry>
  <entry>
    <title type="text">servlet基础</title>
    <id>https://javaguide.cn/learning/java/servlet/basis.html</id>
    <link href="https://javaguide.cn/learning/java/servlet/basis.html"/>
    <updated>2024-05-21T17:25:12.000Z</updated>
    <summary type="html"><![CDATA[<h2>What is Servlet</h2>
<p>Java Servlet（Java服务器小程序）是一个基于Java技术的Web组件，运行在服务器端，它由Servlet容器所管理，用于生成动态的内容。</p>
<p>Servlet是平台独立的Java类，编写一个Servlet，实际上就是按照Servlet规范编写一个Java类。Servlet被编译为平台独立 的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。</p>
<h2>Servlet容器</h2>
<p>Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于 MIME的请求，格式化基于MIME的响应。</p>]]></summary>
    <content type="html"><![CDATA[<h2>What is Servlet</h2>
<p>Java Servlet（Java服务器小程序）是一个基于Java技术的Web组件，运行在服务器端，它由Servlet容器所管理，用于生成动态的内容。</p>
<p>Servlet是平台独立的Java类，编写一个Servlet，实际上就是按照Servlet规范编写一个Java类。Servlet被编译为平台独立 的字节码，可以被动态地加载到支持Java技术的Web服务器中运行。</p>
<h2>Servlet容器</h2>
<p>Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务，解码基于 MIME的请求，格式化基于MIME的响应。</p>
<p>Servlet没有main方法，不能独立运行，它必须被部署到Servlet容器中，由容器来实例化和调用 Servlet的方法（如doGet()和doPost()），Servlet容器在Servlet的生命周期内包容和管理Servlet。在JSP技术 推出后，管理和运行Servlet/JSP的容器也称为Web容器。</p>
<figure><figcaption>servlet容器交互</figcaption></figure>
<h2>Tomcat</h2>
<p>Tomcat是一个免费的开放源代码的Servlet容器。</p>
<p>Tomcat服务器接受客户请求并做出响应的过程如下，与上图类似：</p>
<ol>
<li>客户端（通常都是浏览器）访问Web服务器，发送HTTP请求。</li>
<li>Web服务器接收到请求后，传递给Servlet容器。</li>
<li>Servlet容器加载Servlet，产生Servlet实例后，向其传递表示请求和响应的对象。</li>
<li>Servlet实例使用请求对象得到客户端的请求信息，然后进行相应的处理。</li>
<li>Servlet实例将处理结果通过响应对象发送回客户端，容器负责确保响应正确送出，同时将控制返回给Web服务器。<br>
</li>
</ol>
<ul>
<li>Server 元素表示整个 Catalina servlet 容器。</li>
<li>Service元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。</li>
<li>Executor表示可以在Tomcat中的组件之间共享的线程池。</li>
<li>Connector代表连接组件。Tomcat 支持三种协议：HTTP/1.1、HTTP/2.0、AJP。</li>
<li>Context元素表示一个Web应用程序，它在特定的虚拟主机中运行。每个Web应用程序都基于Web应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如Servlet规范述。</li>
<li>Engine元素表示与特定的Catalina服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。</li>
<li>Host元素表示一个虚拟主机，它是一个服务器的网络名称（如“<a href="http://www.mycompany.com" target="_blank" rel="noopener noreferrer">www.mycompany.com</a>”）与运行Tomcat的特定服务器的关联。</li>
</ul>
]]></content>
    <category term="java"/>
    <published>2024-05-21T17:25:12.000Z</published>
  </entry>
  <entry>
    <title type="text">网页凭证</title>
    <id>https://javaguide.cn/learning/cs-basics/network/authentication/credential.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/authentication/credential.html"/>
    <updated>2024-05-20T14:49:15.000Z</updated>
    <summary type="html"><![CDATA[<h2>What is Credential</h2>
<p>在Web开发中，凭证（Credential）是指用于验证用户身份的信息。这通常包括用户名和密码，但也可以是其他形式的身份验证数据，如OAuth令牌或公钥。</p>
<ol>
<li>
<p>凭证（Credential）：</p>
<ul>
<li>用于用户身份验证的基本信息。</li>
<li>通常在用户登录时由用户输入（如用户名和密码）。</li>
<li>可以通过Credential Management API进行存储和管理，以便简化后续的登录流程。</li>
</ul>
</li>
<li>
<p>会话（Session）：</p>
<ul>
<li>是服务器端用于跟踪用户状态的机制。</li>
<li>当用户成功登录后，服务器会创建一个会话，并分配一个唯一的会话ID给用户。</li>
<li>这个会话ID通常存储在服务器的内存或数据库中。</li>
<li>会话在用户关闭浏览器或会话超时后会失效。</li>
</ul>
</li>
<li>
<p>Cookie：</p>
<ul>
<li>是存储在用户浏览器中的小型数据文件。</li>
<li>可以用来持久化会话ID，从而在用户关闭浏览器后仍然可以保持登录状态（通过持久化cookie）。</li>
<li>也可以存储一些不敏感的数据，如用户偏好设置。</li>
<li>HTTP请求时，浏览器会自动将相关的Cookie发送到服务器，以维持会话状态。</li>
</ul>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>What is Credential</h2>
<p>在Web开发中，凭证（Credential）是指用于验证用户身份的信息。这通常包括用户名和密码，但也可以是其他形式的身份验证数据，如OAuth令牌或公钥。</p>
<ol>
<li>
<p>凭证（Credential）：</p>
<ul>
<li>用于用户身份验证的基本信息。</li>
<li>通常在用户登录时由用户输入（如用户名和密码）。</li>
<li>可以通过Credential Management API进行存储和管理，以便简化后续的登录流程。</li>
</ul>
</li>
<li>
<p>会话（Session）：</p>
<ul>
<li>是服务器端用于跟踪用户状态的机制。</li>
<li>当用户成功登录后，服务器会创建一个会话，并分配一个唯一的会话ID给用户。</li>
<li>这个会话ID通常存储在服务器的内存或数据库中。</li>
<li>会话在用户关闭浏览器或会话超时后会失效。</li>
</ul>
</li>
<li>
<p>Cookie：</p>
<ul>
<li>是存储在用户浏览器中的小型数据文件。</li>
<li>可以用来持久化会话ID，从而在用户关闭浏览器后仍然可以保持登录状态（通过持久化cookie）。</li>
<li>也可以存储一些不敏感的数据，如用户偏好设置。</li>
<li>HTTP请求时，浏览器会自动将相关的Cookie发送到服务器，以维持会话状态。</li>
</ul>
</li>
</ol>
<h2>Credential Management API</h2>
<p>是一组用于处理用户凭证（例如密码和身份验证信息）的Web API。它允许Web应用程序简化用户登录流程，通过提供统一的方法来存储、检索和删除用户凭证，从而改善用户体验。</p>
<blockquote>
<p>需要注意的是，Credential Management API在不同浏览器中的支持情况可能有所不同，使用前请确保目标浏览器支持此API。</p>
</blockquote>
<h3>存储凭证</h3>
<p>假设用户登录成功后，我们想要将用户的凭证保存下来，以便下次用户访问时可以自动填充登录表单。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 假设我们有用户的凭证</span>
<span class="token keyword">const</span> cred <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PasswordCredential</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">"user@example.com"</span><span class="token punctuation">,</span> <span class="token comment">// 用户名或电子邮件</span>
  <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token string">"password123"</span><span class="token punctuation">,</span> <span class="token comment">// 用户密码</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span> <span class="token comment">// 可选：用户全名</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 navigator.credentials.store() 方法来存储凭证</span>
navigator<span class="token punctuation">.</span>credentials
  <span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>cred<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"凭证已存储"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"存储凭证时发生错误:"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>检索凭证</h3>
<p>当用户再次访问页面时，我们可以使用 navigator.credentials.get() 方法来检索之前存储的凭证，并自动填充登录表单。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>navigator<span class="token punctuation">.</span>credentials
  <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">password</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 指定要检索密码凭证</span>
    <span class="token literal-property property">mediation</span><span class="token operator">:</span> <span class="token string">"required"</span><span class="token punctuation">,</span> <span class="token comment">// 强制用户选择凭证，而不是自动使用</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">cred</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将凭证填充到登录表单中</span>
      document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#username"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">=</span> cred<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
      document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#password"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">=</span> cred<span class="token punctuation">.</span>password<span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"凭证已检索"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"没有检索到凭证"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"检索凭证时发生错误:"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>删除凭证</h3>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>navigator<span class="token punctuation">.</span>credentials
  <span class="token punctuation">.</span><span class="token function">preventSilentAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"凭证已删除"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"删除凭证时发生错误:"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <category term="network"/>
    <published>2024-05-20T14:49:15.000Z</published>
  </entry>
  <entry>
    <title type="text">第三方登录</title>
    <id>https://javaguide.cn/learning/cs-basics/network/authentication/federated-identity.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/authentication/federated-identity.html"/>
    <updated>2024-05-20T14:49:15.000Z</updated>
    <summary type="html"><![CDATA[<figure><figcaption>Federated Identity process</figcaption></figure>
<p>有很多方法能够实现第三方登录，最常用的是OAuth协议，这个协议旨在支持分布式的身份认证和对于calling system的认证token的反馈</p>
<p>OAuth只包括了OAuth authentication tokens，没有包含用户信息，所以只能用于身份的通行，不能用于和用户权限有关的操作，比如开放给用户什么资源</p>
<p>为了解决这个问题，<strong>OpenID Connect</strong>可以从用户的认证系统中提供用户信息。</p>]]></summary>
    <content type="html"><![CDATA[<figure><figcaption>Federated Identity process</figcaption></figure>
<p>有很多方法能够实现第三方登录，最常用的是OAuth协议，这个协议旨在支持分布式的身份认证和对于calling system的认证token的反馈</p>
<p>OAuth只包括了OAuth authentication tokens，没有包含用户信息，所以只能用于身份的通行，不能用于和用户权限有关的操作，比如开放给用户什么资源</p>
<p>为了解决这个问题，<strong>OpenID Connect</strong>可以从用户的认证系统中提供用户信息。</p>
]]></content>
    <category term="network"/>
    <published>2024-05-20T14:49:15.000Z</published>
  </entry>
  <entry>
    <title type="text">移动设备身份认证</title>
    <id>https://javaguide.cn/learning/cs-basics/network/authentication/mobile-device-authentication.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/authentication/mobile-device-authentication.html"/>
    <updated>2024-05-20T14:49:15.000Z</updated>
    <summary type="html"><![CDATA[<figure><figcaption>mobile-device-authentication</figcaption></figure>
]]></summary>
    <content type="html"><![CDATA[<figure><figcaption>mobile-device-authentication</figcaption></figure>
]]></content>
    <category term="network"/>
    <published>2024-05-20T14:49:15.000Z</published>
  </entry>
  <entry>
    <title type="text">nginx</title>
    <id>https://javaguide.cn/learning/linux/nginx.html</id>
    <link href="https://javaguide.cn/learning/linux/nginx.html"/>
    <updated>2024-05-19T17:07:55.000Z</updated>
    <summary type="html"><![CDATA[<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>server {
        listen       82;
        listen       [::]:82;
        server_name  _;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

    		# 这里是添加的内容
        location / {
          root /home/www/webProject/;
          index index.html;
	      try_files $uri $uri/ /index.html;
        }



        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>server {
        listen       82;
        listen       [::]:82;
        server_name  _;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

    		# 这里是添加的内容
        location / {
          root /home/www/webProject/;
          index index.html;
	      try_files $uri $uri/ /index.html;
        }



        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
</code></pre></div>]]></content>
    <category term="linux"/>
    <published>2024-05-19T17:07:55.000Z</published>
  </entry>
  <entry>
    <title type="text">JavaScript</title>
    <id>https://javaguide.cn/learning/web/javascript/javascript-basis.html</id>
    <link href="https://javaguide.cn/learning/web/javascript/javascript-basis.html"/>
    <updated>2024-05-19T17:07:55.000Z</updated>
    <summary type="html"><![CDATA[<h2>变量类型</h2>
<ul>
<li>
<p>Number</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
<li>
<p>Array</p>
<ul>
<li>
<p>索引访问数组（可以多维）</p>
</li>
<li>
<p>length属性访问长度</p>
</li>
<li>
<p>和字符串的转换</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> myData <span class="token operator">=</span> <span class="token string">"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myArray <span class="token operator">=</span> myData<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myNewString <span class="token operator">=</span> myArray<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> dogNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Rocket"</span><span class="token punctuation">,</span> <span class="token string">"Flash"</span><span class="token punctuation">,</span> <span class="token string">"Bella"</span><span class="token punctuation">,</span> <span class="token string">"Slugger"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
dogNames<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Rocket,Flash,Bella,Slugger</span>
</code></pre></div></li>
<li>
<p>增加或者删除数组元素</p>
<ul>
<li>数组末尾添加或删除一个项目，我们可以使用 push() 和 pop()</li>
<li>数组开始增加或删除项目，unshift() 和 shift()</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Object</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>变量类型</h2>
<ul>
<li>
<p>Number</p>
</li>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
<li>
<p>Array</p>
<ul>
<li>
<p>索引访问数组（可以多维）</p>
</li>
<li>
<p>length属性访问长度</p>
</li>
<li>
<p>和字符串的转换</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> myData <span class="token operator">=</span> <span class="token string">"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle"</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myArray <span class="token operator">=</span> myData<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myNewString <span class="token operator">=</span> myArray<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> dogNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Rocket"</span><span class="token punctuation">,</span> <span class="token string">"Flash"</span><span class="token punctuation">,</span> <span class="token string">"Bella"</span><span class="token punctuation">,</span> <span class="token string">"Slugger"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
dogNames<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Rocket,Flash,Bella,Slugger</span>
</code></pre></div></li>
<li>
<p>增加或者删除数组元素</p>
<ul>
<li>数组末尾添加或删除一个项目，我们可以使用 push() 和 pop()</li>
<li>数组开始增加或删除项目，unshift() 和 shift()</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Object</p>
</li>
</ul>
<h2>异步JavaScript</h2>
<h3>事件处理程序</h3>
<ul>
<li>
<p>XMLHttpRequest</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"xhr"</span><span class="token operator">&gt;</span>点击发起请求<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button id<span class="token operator">=</span><span class="token string">"reload"</span><span class="token operator">&gt;</span>重载<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>pre readonly <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"event-log"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>pre<span class="token operator">&gt;</span>

<span class="token keyword">const</span> log <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".event-log"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#xhr"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  log<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  xhr<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"loadend"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>log<span class="token punctuation">.</span>textContent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">完成！状态码：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>xhr<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>
    <span class="token string">"GET"</span><span class="token punctuation">,</span>
    <span class="token string">"https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json"</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>log<span class="token punctuation">.</span>textContent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">请求已发起\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#reload"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  log<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
  document<span class="token punctuation">.</span>location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
</ul>
<h2>Promise</h2>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fetchPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//输出Promise { &lt;state&gt;: "pending" }</span>
<span class="token comment">//"pending" 状态意味着操作仍在进行中。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fetchPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//将一个处理函数传递给 Promise 的 then() 方法。</span>
<span class="token comment">// 当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 Response 对象</span>
fetchPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">已收到响应：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"已发送请求……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>Promise链</h3>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fetchPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

fetchPromise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>错误捕获</h3>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fetchPromise <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

fetchPromise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">HTTP 请求错误：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>json<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">无法获取产品列表：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>状态</h3>
<ul>
<li>待定（pending）：初始状态，既没有被兑现，也没有被拒绝。这是调用 fetch() 返回 Promise 时的状态，此时请求还在进行中。</li>
<li>已兑现（fulfilled）：意味着操作成功完成。当 Promise 完成时，它的 then() 处理函数被调用。</li>
<li>已拒绝（rejected）：意味着操作失败。当一个 Promise 失败时，它的 catch() 处理函数被调用。</li>
</ul>
<h3>合并使用多个 Promise</h3>
<ul>
<li>
<p>Promise.all()<br>
返回一个Promise</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fetchPromise1 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fetchPromise2 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fetchPromise3 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fetchPromise1<span class="token punctuation">,</span> fetchPromise2<span class="token punctuation">,</span> fetchPromise3<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">responses</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> response <span class="token keyword">of</span> responses<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">获取失败：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul>
<li>
<p>Promise.any()<br>
在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> fetchPromise1 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fetchPromise2 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fetchPromise3 <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
  <span class="token string">"https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json"</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fetchPromise1<span class="token punctuation">,</span> fetchPromise2<span class="token punctuation">,</span> fetchPromise3<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">获取失败：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h2>async 和 await</h2>
<p>在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 await 关键字。</p>
<p>这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<p>异步函数总是返回一个 Promise</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span>
    <span class="token comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span>
    <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>
      <span class="token string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span>ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">HTTP 请求错误：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>response<span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span>
    <span class="token comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span>
    <span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>json<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">无法获取产品列表：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>error<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">fetchProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>]]></content>
    <category term="web"/>
    <published>2024-05-19T17:07:55.000Z</published>
  </entry>
  <entry>
    <title type="text">JavaScript扩展</title>
    <id>https://javaguide.cn/learning/web/javascript/javascript-extension.html</id>
    <link href="https://javaguide.cn/learning/web/javascript/javascript-extension.html"/>
    <updated>2024-05-19T17:07:55.000Z</updated>
    <summary type="html"><![CDATA[<h2>Chunk Error</h2>
<h3>Basis knowledge</h3>
<p>The way React, Vue, Angular and similar frameworks work is by <strong>downloading JavaScript files and using them to render websites</strong> on the browser. Whenever a project is built, two types of files are created:</p>
<ul>
<li>Main entry file - The file to which the script tag in index.html points to</li>
<li>Other helper files - The files which are imported by the main entry file whenever required.</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>Chunk Error</h2>
<h3>Basis knowledge</h3>
<p>The way React, Vue, Angular and similar frameworks work is by <strong>downloading JavaScript files and using them to render websites</strong> on the browser. Whenever a project is built, two types of files are created:</p>
<ul>
<li>Main entry file - The file to which the script tag in index.html points to</li>
<li>Other helper files - The files which are imported by the main entry file whenever required.</li>
</ul>
<p>Most of the time, if you have a small project, a single entry file is enough.<br>
You can store all the JavaScript code into the same file.</p>
<p>But, for faster loading and better user experience, the JavaScript code can also be broken down into multiple files<br>
when it's built and these files(which is <strong>Other helper files</strong>) are dynamically fetched by the main entry file whenever required.</p>
<p>Now, whenever there’s an <strong>error observed in fetching these other helper JavaScript files</strong>, a ChunkLoad Error is thrown.</p>
<blockquote>
<p>The multiple JavaScript files used are also known as chunks, and hence the name of the error.</p>
</blockquote>
<h3>Reason for the error</h3>
<ul>
<li>
<p>The checksum validation for the JavaScript file failed</p>
<p>This can occur when the checksum of the received file does not match the integrity attribute of the script tag. (For more information on why this is important and how it’s done you can refer to Subresource Integrity - Web security | MDN).</p>
<p>A possible reason for this is that you have antivirus, browser extensions, proxies, or ad blocking software that may be modifying the file contents, resulting in it not matching the checksum.</p>
<blockquote>
<p>Subresource Integrity (SRI) 是一种安全特性，它允许网页的开发者通过提供资源的哈希值来确保他们加载的资源未被篡改。使用 SRI 时，开发者在 script 或 link 标签中添加 integrity 属性和 crossorigin 属性。示例如下：</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>&lt;script src="https://example.com/script.js" integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxfqhmWp7vjKhp+nIVf3Yg6ZkZ9bD4w" crossorigin="anonymous"&gt;&lt;/script&gt;
</code></pre></div><p>工作原理：</p>
<ol>
<li>获取文件: 浏览器从指定的 URL 获取文件。</li>
<li>计算校验和: 浏览器计算获取到的文件的校验和。</li>
<li>校验和对比: 浏览器将计算得到的校验和与 integrity 属性中提供的校验和进行对比。</li>
<li>校验成功: 如果校验和匹配，浏览器将执行文件。</li>
<li>校验失败: 如果校验和不匹配，浏览器将拒绝加载文件并抛出错误。</li>
</ol>
</blockquote>
</li>
<li>
<p>The relevant chunk files can not be found or are outdated<br>
Again, this can occur because your browser is not able to find and/or download the chunk file, maybe because the file does not exist, but also because of the hundreds of reasons for internet failure (proxies, firewalls, outages etc.).</p>
<p>It can also occur if the browser is able to download the chunk file, but the downloaded file is an outdated one.</p>
</li>
</ul>
<h3>Example of the Chunk Load Error</h3>
<p>Assume a user is using your app, he has downloaded the main entrypoint file which is, in turn, going to download chunk1.js, chunk2.js, chunk3.js, … whenever required. At the same time, you push a critical bug fix and redeploy the application.</p>
<p>This causes the previous chunks to be deleted and be replaced by new ones, say chunkA.js, chunkB.js, chunkC.js, … Now for the user, whenever his entrypoint file tries to download the file chunk2.js it’ll give a chunk load error since the file does not exist.</p>
<p>An extension of this use case is when, due to some caching in between the user and your server, the user is served an older entrypoint file, even though you’ve redeployed the application long back. This causes the browser to try and fetch older non-existent files, resulting in a Chunk Load Error.</p>
<h3>Reproducing the Error</h3>
<p>You are most likely already stuck on this error, but here’s a simple way to reproduce the Chunk Load Error.</p>
<p>Let’s say you have a App.jsx which looks like this:</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"./OtherComponent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">App</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> App<span class="token punctuation">;</span>
</code></pre></div><p>And an OtherComponent.jsx which contains -</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">OtherComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello World<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> OtherComponent<span class="token punctuation">;</span>
</code></pre></div><p>Building this project should create multiple chunks, which you can see in your build folder. You can now serve this build folder, and delete one of the chunks created. Now, since the browser is trying to fetch a chunk, but is unable to fetch it since it doesn’t exist, it’ll throw a chunk load error.</p>
<blockquote>
<p>在构建时，上述代码中的 React.lazy 和 Suspense 都会引入代码分割（code splitting）的概念，以优化应用程序的加载性能。</p>
<p>React.lazy 和 import()： React.lazy 是 React 提供的一个动态导入组件的方式，它接受一个返回 import() 函数的函数作为参数，该函数动态地加载组件。在这个例子中，OtherComponent 被异步加载，只有当需要渲染时才会加载，而不是在应用程序初始化时立即加载。</p>
<p>Suspense 组件： Suspense 是 React 提供的一个组件，用于在异步加载组件时显示加载中的占位符。当 OtherComponent 还在加载中时，Suspense 会渲染它的 fallback 属性中指定的内容，以提供用户一个加载状态的提示。</p>
<p>在构建时，由于 React.lazy 和 Suspense 的存在，Webpack 会生成一个单独的 chunk 文件来包含被动态导入的组件。在本例中，OtherComponent 会被打包成一个独立的 chunk 文件，并且在需要时被异步加载。</p>
<p>因此，在构建时会生成至少两个 chunk 文件：</p>
<ul>
<li>主 chunk 文件（通常名为 main.js 或类似的名字），其中包含了应用程序的主要代码。</li>
<li>懒加载的 chunk 文件（通常根据模块的名称或路径来命名），其中包含了被 React.lazy 异步加载的 OtherComponent 组件的代码。</li>
</ul>
</blockquote>
]]></content>
    <category term="web"/>
    <published>2024-05-19T17:07:55.000Z</published>
  </entry>
  <entry>
    <title type="text">论文写作</title>
    <id>https://javaguide.cn/learning/neural-network/paper-related.html</id>
    <link href="https://javaguide.cn/learning/neural-network/paper-related.html"/>
    <updated>2024-06-07T08:37:59.000Z</updated>
    <summary type="html"><![CDATA[<h2>基本要求</h2>
<ul>
<li>主题相关：
<ul>
<li>任务相关：视觉问答任务，基于知识的视觉问答</li>
<li>技术相关： GCN, LSTM相关方法</li>
</ul>
</li>
<li>问题相关：知识性视觉问答中存在数据，模型优化，偏置等等问题。但是只需要列出与本文要解决问题相关的一些工作。
<ul>
<li>从不同维度划分主题</li>
<li>同一主题方法归类</li>
</ul>
</li>
<li>总结问题</li>
<li>引出本研究的区别和贡献。</li>
</ul>
<h2>相关工作</h2>
<ul>
<li>工作分类</li>
<li>思路</li>
<li>引用文献的用途</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>基本要求</h2>
<ul>
<li>主题相关：
<ul>
<li>任务相关：视觉问答任务，基于知识的视觉问答</li>
<li>技术相关： GCN, LSTM相关方法</li>
</ul>
</li>
<li>问题相关：知识性视觉问答中存在数据，模型优化，偏置等等问题。但是只需要列出与本文要解决问题相关的一些工作。
<ul>
<li>从不同维度划分主题</li>
<li>同一主题方法归类</li>
</ul>
</li>
<li>总结问题</li>
<li>引出本研究的区别和贡献。</li>
</ul>
<h2>相关工作</h2>
<ul>
<li>工作分类</li>
<li>思路</li>
<li>引用文献的用途</li>
</ul>
<h2>方法</h2>
<p>数据资源和方法</p>
]]></content>
    <category term="论文"/>
    <published>2024-05-18T08:29:38.000Z</published>
  </entry>
  <entry>
    <title type="text">算法训练</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/Practice.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/Practice.html"/>
    <updated>2024-05-18T08:29:38.000Z</updated>
    <summary type="html"><![CDATA[<h2>LeetCode</h2>
<p><strong>以下是出自LeetCode题目，为作者个人练习记录使用，非商业目的</strong></p>
<ol>
<li><a href="https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&amp;envId=top-interview-150" target="_blank" rel="noopener noreferrer">文本左右对齐</a>
<blockquote>
<p>hard<br>
思路：模拟</p>
</blockquote>
</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>LeetCode</h2>
<p><strong>以下是出自LeetCode题目，为作者个人练习记录使用，非商业目的</strong></p>
<ol>
<li><a href="https://leetcode.cn/problems/text-justification/description/?envType=study-plan-v2&amp;envId=top-interview-150" target="_blank" rel="noopener noreferrer">文本左右对齐</a>
<blockquote>
<p>hard<br>
思路：模拟</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">fullJustify</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> words<span class="token punctuation">,</span> maxWidth<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type words: List[str]
        :type maxWidth: int
        :rtype: List[str]
        """</span>
        templen<span class="token operator">=</span><span class="token number">0</span>
        index1<span class="token operator">=</span><span class="token number">0</span>
        index2<span class="token operator">=</span><span class="token number">0</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">while</span> index2<span class="token operator">&lt;</span><span class="token builtin">len</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>
            word<span class="token operator">=</span>words<span class="token punctuation">[</span>index2<span class="token punctuation">]</span>
            templen<span class="token operator">+=</span><span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span>
            <span class="token keyword">if</span> templen<span class="token operator">+</span><span class="token punctuation">(</span>index2<span class="token operator">-</span>index1<span class="token punctuation">)</span><span class="token operator">&lt;=</span>maxWidth<span class="token punctuation">:</span>
                index2<span class="token operator">+=</span><span class="token number">1</span>
                <span class="token keyword">if</span> index2<span class="token operator">==</span><span class="token builtin">len</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    index2<span class="token operator">-=</span><span class="token number">1</span>
                    redundant<span class="token operator">=</span>maxWidth<span class="token operator">-</span><span class="token punctuation">(</span>templen<span class="token operator">+</span>index2<span class="token operator">-</span>index1<span class="token punctuation">)</span>
                    space_allot<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
                    <span class="token keyword">if</span> index2<span class="token operator">==</span>index1<span class="token punctuation">:</span>
                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>words<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">*</span><span class="token punctuation">(</span>redundant<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        str_temp<span class="token operator">=</span><span class="token string">""</span>
                        str_temp<span class="token operator">+=</span>words<span class="token punctuation">[</span>index1<span class="token punctuation">]</span>
                        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>index1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                            str_temp<span class="token operator">+=</span><span class="token string">" "</span><span class="token operator">+</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                        str_temp<span class="token operator">+=</span><span class="token string">" "</span><span class="token operator">*</span>redundant
                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str_temp<span class="token punctuation">)</span>
                    index2<span class="token operator">=</span>index2<span class="token operator">+</span><span class="token number">1</span>
                    index1<span class="token operator">=</span>index2
                    templen<span class="token operator">=</span><span class="token number">0</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                index2<span class="token operator">-=</span><span class="token number">1</span>
                templen<span class="token operator">-=</span><span class="token builtin">len</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span>
                redundant<span class="token operator">=</span>maxWidth<span class="token operator">-</span><span class="token punctuation">(</span>templen<span class="token operator">+</span>index2<span class="token operator">-</span>index1<span class="token punctuation">)</span>
                space_allot<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
                <span class="token keyword">if</span> index2<span class="token operator">==</span>index1<span class="token punctuation">:</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>words<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">*</span><span class="token punctuation">(</span>redundant<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    quotient<span class="token operator">=</span>redundant<span class="token operator">//</span><span class="token punctuation">(</span>index2<span class="token operator">-</span>index1<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
                    remainder<span class="token operator">=</span>redundant<span class="token operator">%</span><span class="token punctuation">(</span>index2<span class="token operator">-</span>index1<span class="token punctuation">)</span>
                    str_temp<span class="token operator">=</span><span class="token string">""</span>
                    str_temp<span class="token operator">+=</span>words<span class="token punctuation">[</span>index1<span class="token punctuation">]</span>
                    <span class="token keyword">if</span> remainder<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>index1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                            str_temp<span class="token operator">+=</span><span class="token string">" "</span><span class="token operator">*</span>quotient<span class="token operator">+</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str_temp<span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        temp_remain<span class="token operator">=</span><span class="token number">1</span>
                        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>index1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>index2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                            <span class="token keyword">if</span> temp_remain<span class="token operator">&lt;=</span>remainder<span class="token punctuation">:</span>
                                str_temp<span class="token operator">+=</span><span class="token string">" "</span><span class="token operator">*</span><span class="token punctuation">(</span>quotient<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                                temp_remain<span class="token operator">+=</span><span class="token number">1</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                str_temp<span class="token operator">+=</span><span class="token string">" "</span><span class="token operator">*</span>quotient<span class="token operator">+</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str_temp<span class="token punctuation">)</span>
                index2<span class="token operator">=</span>index2<span class="token operator">+</span><span class="token number">1</span>
                index1<span class="token operator">=</span>index2
                templen<span class="token operator">=</span><span class="token number">0</span>
        <span class="token keyword">return</span> res

</code></pre></div><ol start="2">
<li><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&amp;envId=top-interview-150" target="_blank" rel="noopener noreferrer">串联所有单词的子串</a>
<blockquote>
<p>滑动窗口</p>
</blockquote>
</li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">findSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">,</span> words<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """</span>
        slide<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        left<span class="token operator">=</span><span class="token number">0</span>
        right<span class="token operator">=</span>left<span class="token operator">+</span>slide<span class="token operator">-</span><span class="token number">1</span>
        res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>

        oridiffer<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

        <span class="token keyword">for</span> word <span class="token keyword">in</span> words<span class="token punctuation">:</span>
            <span class="token keyword">if</span> word <span class="token keyword">in</span> oridiffer<span class="token punctuation">:</span>
                oridiffer<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                oridiffer<span class="token punctuation">[</span>word<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>

        differ<span class="token operator">=</span>self<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>oridiffer<span class="token punctuation">)</span>
        <span class="token keyword">while</span> right<span class="token operator">&lt;</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>

            temp_word<span class="token operator">=</span>s<span class="token punctuation">[</span>right<span class="token operator">-</span>slide<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> temp_word <span class="token keyword">in</span> differ<span class="token punctuation">:</span>
                differ<span class="token punctuation">[</span>temp_word<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
                <span class="token keyword">if</span> differ<span class="token punctuation">[</span>temp_word<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">del</span> differ<span class="token punctuation">[</span>temp_word<span class="token punctuation">]</span>
                <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>differ<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                    differ<span class="token operator">=</span>self<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>oridiffer<span class="token punctuation">)</span>
                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">)</span>
                    left<span class="token operator">+=</span><span class="token number">1</span>
                    right<span class="token operator">=</span>left<span class="token operator">+</span>slide<span class="token operator">-</span><span class="token number">1</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    right<span class="token operator">+=</span>slide
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                differ<span class="token operator">=</span>self<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>oridiffer<span class="token punctuation">)</span>
                left<span class="token operator">+=</span><span class="token number">1</span>
                right<span class="token operator">=</span>left<span class="token operator">+</span>slide<span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">return</span> res
    <span class="token keyword">def</span> <span class="token function">deepcopy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> key <span class="token keyword">in</span> lst<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>lst<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res
</code></pre></div><ol start="3">
<li><a href="https://leetcode.cn/problems/word-ladder/?envType=study-plan-v2&amp;envId=top-interview-150" target="_blank" rel="noopener noreferrer">单词接龙</a></li>
</ol>
<div class="language-python" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">ladderLength</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> beginWord<span class="token punctuation">,</span> endWord<span class="token punctuation">,</span> wordList<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """</span>

        <span class="token keyword">if</span> endWord <span class="token keyword">not</span> <span class="token keyword">in</span> wordList<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        wordList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span>
        wordList<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
        n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>wordList<span class="token punctuation">)</span>
        parent <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        depth<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        word_len<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span>
        edges<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>n <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                differ <span class="token operator">=</span> <span class="token number">0</span>
                <span class="token keyword">for</span> z <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>word_len<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> wordList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token operator">!=</span>wordList<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>z<span class="token punctuation">]</span><span class="token punctuation">:</span>
                        differ<span class="token operator">+=</span><span class="token number">1</span>
                        <span class="token keyword">if</span> differ<span class="token operator">&gt;=</span><span class="token number">2</span><span class="token punctuation">:</span>
                            <span class="token keyword">break</span>
                <span class="token keyword">if</span> differ<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">:</span>
                    edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
                    edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>
        beginindex<span class="token operator">=</span>wordList<span class="token punctuation">.</span>index<span class="token punctuation">(</span>beginWord<span class="token punctuation">)</span>
        endindex<span class="token operator">=</span>wordList<span class="token punctuation">.</span>index<span class="token punctuation">(</span>endWord<span class="token punctuation">)</span>
        depth<span class="token punctuation">[</span>beginindex<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span>

        visited<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
        tovisit<span class="token operator">=</span><span class="token punctuation">[</span>beginindex<span class="token punctuation">]</span>
        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tovisit<span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
            currentindex<span class="token operator">=</span>tovisit<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

            <span class="token keyword">if</span> currentindex<span class="token operator">==</span>endindex<span class="token punctuation">:</span>
                <span class="token keyword">return</span> depth<span class="token punctuation">[</span>currentindex<span class="token punctuation">]</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> edges<span class="token punctuation">[</span>currentindex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span> <span class="token keyword">and</span> i <span class="token keyword">not</span> <span class="token keyword">in</span> visited<span class="token punctuation">:</span>
                    parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>currentindex
                    depth<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>depth<span class="token punctuation">[</span>currentindex<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>
                    tovisit<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                    visited<span class="token punctuation">.</span>append<span class="token punctuation">(</span>currentindex<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
</code></pre></div><blockquote>
<p>单词之间的关系可以建立图分析<br>
例如对于单词 hit，我们创建三个虚拟节点 *it、h*t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可.<br>
用这些虚拟节点和word节点连接</p>
</blockquote>
]]></content>
    <category term="计算机基础"/>
    <published>2024-05-17T03:24:34.000Z</published>
  </entry>
  <entry>
    <title type="text">WebRtc</title>
    <id>https://javaguide.cn/learning/web/webrtc.html</id>
    <link href="https://javaguide.cn/learning/web/webrtc.html"/>
    <updated>2024-05-15T06:29:08.000Z</updated>
    <summary type="html"><![CDATA[<h2>协议</h2>
<h3>ICE（Interactive Connectivity Establishment）</h3>
<figure><figcaption>ICE信息交换整个过程</figcaption></figure>
<p>一个框架用以建立点对点连接。</p>
<ul>
<li>帮助应用通过防火墙的阻隔</li>
<li>为应用设定一个公网IP</li>
<li>通过一个服务器转发数据如果router禁止应用间的直接连接</li>
</ul>
<h3>STUN（Session Traversal Utilities for NAT）</h3>
<p>一个协议来发现公网IP地址，并且确定在路由器中router的会妨碍连接的限制。该协议使用的是NAT协议</p>]]></summary>
    <content type="html"><![CDATA[<h2>协议</h2>
<h3>ICE（Interactive Connectivity Establishment）</h3>
<figure><figcaption>ICE信息交换整个过程</figcaption></figure>
<p>一个框架用以建立点对点连接。</p>
<ul>
<li>帮助应用通过防火墙的阻隔</li>
<li>为应用设定一个公网IP</li>
<li>通过一个服务器转发数据如果router禁止应用间的直接连接</li>
</ul>
<h3>STUN（Session Traversal Utilities for NAT）</h3>
<p>一个协议来发现公网IP地址，并且确定在路由器中router的会妨碍连接的限制。该协议使用的是NAT协议</p>
<p>客户端会给STUN服务器发送请求，获得自己在公网的IP，并且获知自己是否能在router中通行<br>
</p>
<h3>TURN（Traversal Using Relays around NAT）</h3>
<p>一些router由于运行了路由限制————“Symmetric NAT”，只能和之前建立过的连接的应用连接</p>
<blockquote>
<ul>
<li>常规NAT：<br>
通过将内部地址和端口映射到唯一的外部地址和端口上来实现连接。<br>
对于相同的内部地址和端口，常规NAT总是将其映射到相同的外部地址和端口上。</li>
<li>对称型NAT：<br>
为每个传出的数据包分配不同的外部端口，并且只有在外部通信开始后才会将端口映射到内部地址上。<br>
对于相同的内部地址和端口，对称型NAT可能会将其映射到不同的外部地址和端口上，这取决于与不同目标的通信。</li>
</ul>
</blockquote>
<p>因此TURN通过打开一个TURN服务器的连接，并且将信息通过该服务器转发</p>
<p>由于会有额外的开销，能不用就不用<br>
</p>
<h3>NAT（Network Address Translation）</h3>
<p>运行在router的协议，将本网络中主机的IP转换为运行在某个特定端口的公网IP</p>
<h3>SDP（Session Description Protocol）</h3>
<p>文本协议</p>
<p>用来传输建立媒体传输所需要的参数：媒体类型、媒体流的传输地址和端口、媒体流的特性和限制等</p>
<h4>结构</h4>
<ul>
<li>SDP包含多行UTF-8编码格式的行</li>
<li>每行开始是一个类型字符，之后是“=”，之后是结构化的描述或者值</li>
<li>每行以单词开头的行，叫做“letter-lines”</li>
</ul>
<h2>Signaling</h2>
<p>交换的信息 <strong>Offer and Answer</strong> ，这包含了SDP内容</p>
<p>可以通过各种渠道：email、postcard、carrier pigeon</p>
<h3>session description</h3>
<p>每个应用都保存两个description————localDescription、remoteDescription</p>
<h3>ICE candidates</h3>
<p>和signaling交换的是媒体信息，而ICE candidate交换的是网络连接；并且也详细说明了两个应用之间所能进行交流的方法（直接交流或者通过TURN交流）</p>
<p>一般的，每个应用会从好到坏选择每一个candidate。</p>
<p>candidates一般是UDP，但同时也允许TCP</p>
<h3>UDP candidate type</h3>
<ul>
<li>host<br>
一个host candidate代表它的IP地址就是真实直接的远程IP地址</li>
<li>prflx<br>
对等反射候选地址，指的是在ICE过程中由对等方发现并提供的地址。它通常是在双方都位于对称型NAT（Symmetric NAT）之间时出现的。<br>
在Trickle ICE阶段作为额外的candidate<br>
对称型NAT会为每个传出的数据包分配不同的外部端口，并且只有在外部通信开始后才会将端口映射到内部地址上。<br>
这导致了两个对等方在通信时会发现彼此的外部地址，并将其作为候选地址交换</li>
</ul>
]]></content>
    <category term="web"/>
    <published>2024-05-15T05:35:16.000Z</published>
  </entry>
  <entry>
    <title type="text">盒模型</title>
    <id>https://javaguide.cn/learning/web/css/box-model.html</id>
    <link href="https://javaguide.cn/learning/web/css/box-model.html"/>
    <updated>2024-05-14T03:16:46.000Z</updated>
    <summary type="html"><![CDATA[<h2>区块盒子和行内盒子</h2>
<p>在 CSS 中，我们有几种类型的盒子，一般分为<strong>区块盒子</strong>（block boxes）和<strong>行内盒子</strong>（inline boxes）。类型指的是盒子在页面流中的行为方式以及与页面上其他盒子的关系。</p>
<p>盒子有<strong>内部显示</strong>（inner display type）和<strong>外部显示</strong>（outer display type）两种类型。</p>
<h2>外部显示类型</h2>
<ul>
<li>
<p>一个拥有 <strong>block</strong> 外部显示类型的盒子会表现出以下行为：</p>
<ul>
<li>display:block</li>
<li>盒子会产生换行。</li>
<li>width 和 height 属性可以发挥作用。</li>
<li>内边距、外边距和边框会将其他元素从当前盒子周围“推开”。</li>
<li>如果未指定 width，方框将沿行向扩展，以填充其容器中的可用空间。在大多数情况下，盒子会变得与其容器一样宽，占据可用空间的 100%。</li>
</ul>
</li>
<li>
<p>一个拥有 <strong>inline</strong> 外部显示类型的盒子会表现出以下行为：</p>
<ul>
<li>display: inline</li>
<li>盒子不会产生换行。</li>
<li>width 和 height 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。</li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>区块盒子和行内盒子</h2>
<p>在 CSS 中，我们有几种类型的盒子，一般分为<strong>区块盒子</strong>（block boxes）和<strong>行内盒子</strong>（inline boxes）。类型指的是盒子在页面流中的行为方式以及与页面上其他盒子的关系。</p>
<p>盒子有<strong>内部显示</strong>（inner display type）和<strong>外部显示</strong>（outer display type）两种类型。</p>
<h2>外部显示类型</h2>
<ul>
<li>
<p>一个拥有 <strong>block</strong> 外部显示类型的盒子会表现出以下行为：</p>
<ul>
<li>display:block</li>
<li>盒子会产生换行。</li>
<li>width 和 height 属性可以发挥作用。</li>
<li>内边距、外边距和边框会将其他元素从当前盒子周围“推开”。</li>
<li>如果未指定 width，方框将沿行向扩展，以填充其容器中的可用空间。在大多数情况下，盒子会变得与其容器一样宽，占据可用空间的 100%。</li>
</ul>
</li>
<li>
<p>一个拥有 <strong>inline</strong> 外部显示类型的盒子会表现出以下行为：</p>
<ul>
<li>display: inline</li>
<li>盒子不会产生换行。</li>
<li>width 和 height 属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。</li>
</ul>
</li>
</ul>
<h2>内部显示类型</h2>
<p>例如，可以通过设置 display: flex; 来更改内部显示类型。该元素仍将使用外部显示类型 block 但内部显示类型将变为 flex。该方框的任何直接子代都将成为弹性（flex）项，并按照弹性盒子规范执行。</p>
<blockquote>
<p>同时设置外部和内部显示类型：display:block-flex</p>
</blockquote>
<h2>盒模型的各个部分</h2>
<h3>CSS标准盒模型</h3>
<ul>
<li>内容盒子：显示内容的区域；使用 inline-size 和 block-size 或 width 和 height 等属性确定其大小。</li>
<li>内边距盒子：填充位于内容周围的空白处；使用 padding 和相关属性确定其大小。</li>
<li>边框盒子：边框盒子包住内容和任何填充；使用 border 和相关属性确定其大小。</li>
<li>外边距盒子：外边距是最外层，其包裹内容、内边距和边框，作为该盒子与其他元素之间的空白；使用 margin 和相关属性确定其大小。</li>
</ul>
<h3>CSS替代盒模型</h3>
<p><strong>width=内容盒width+padding+border</strong></p>
<div class="language-css" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.box</span> <span class="token punctuation">{</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 350px<span class="token punctuation">;</span>
  <span class="token property">inline-size</span><span class="token punctuation">:</span> 350px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
  <span class="token property">block-size</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">padding</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>
  <span class="token property">border</span><span class="token punctuation">:</span> 5px solid black<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>外边距</h2>
<ul>
<li>margin-top</li>
<li>margin-right</li>
<li>margin-bottom</li>
<li>margin-left</li>
</ul>
<h3>外边距折叠</h3>
<ul>
<li>两个正外边距将合并为一个外边距。其大小等于最大的单个外边距。</li>
<li>两个负外边距会折叠，并使用最小（离零最远）的值。</li>
<li>如果其中一个外边距为负值，其值将从总值中减去。</li>
</ul>
]]></content>
    <category term="web"/>
    <published>2024-05-14T03:16:46.000Z</published>
  </entry>
  <entry>
    <title type="text">SFC</title>
    <id>https://javaguide.cn/learning/system-design/framework/vue/Single-File-Components.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/vue/Single-File-Components.html"/>
    <updated>2024-05-13T15:08:06.000Z</updated>
    <category term="vue"/>
    <published>2024-05-13T15:08:06.000Z</published>
  </entry>
  <entry>
    <title type="text">slot使用</title>
    <id>https://javaguide.cn/learning/system-design/framework/vue/slot.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/vue/slot.html"/>
    <updated>2024-05-13T11:50:53.000Z</updated>
    <summary type="html"><![CDATA[<h2>Slot</h2>
<p>和prop传递JavaScript对象不同的是，slot传递的是template content</p>
<figure><figcaption></figcaption></figure>
]]></summary>
    <content type="html"><![CDATA[<h2>Slot</h2>
<p>和prop传递JavaScript对象不同的是，slot传递的是template content</p>
<figure><figcaption></figcaption></figure>
]]></content>
    <category term="vue"/>
    <published>2024-05-13T11:50:53.000Z</published>
  </entry>
  <entry>
    <title type="text">vue中storage解析</title>
    <id>https://javaguide.cn/learning/system-design/framework/vue/storage.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/vue/storage.html"/>
    <updated>2024-05-13T11:50:53.000Z</updated>
    <summary type="html"><![CDATA[<h2>localStorage和sessionStorage</h2>
<p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。</p>
<p>它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。</p>
<h3>我们已经有了 cookie。为什么还要其他存储对象呢？</h3>
<p>与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数现代浏览器都允许保存至少 5MB 的数据（或更多），并且具有用于配置数据的设置。</p>]]></summary>
    <content type="html"><![CDATA[<h2>localStorage和sessionStorage</h2>
<p>Web 存储对象 localStorage 和 sessionStorage 允许我们在浏览器上保存键/值对。</p>
<p>它们有趣的是，在页面刷新后（对于 sessionStorage）甚至浏览器完全重启（对于 localStorage）后，数据仍然保留在浏览器中。我们很快就会看到。</p>
<h3>我们已经有了 cookie。为什么还要其他存储对象呢？</h3>
<p>与 cookie 不同，Web 存储对象不会随每个请求被发送到服务器。因此，我们可以保存更多数据。大多数现代浏览器都允许保存至少 5MB 的数据（或更多），并且具有用于配置数据的设置。</p>
<p>还有一点和 cookie 不同，服务器无法通过 HTTP header 操纵存储对象。一切都是在 JavaScript 中完成的。</p>
<p>存储绑定到源（域/协议/端口三者）。也就是说，不同协议或子域对应不同的存储对象，它们之间无法访问彼此数据。</p>
<h3>方法和属性</h3>
<ul>
<li>setItem(key, value) —— 存储键/值对。</li>
<li>getItem(key) —— 按照键获取值。</li>
<li>removeItem(key) —— 删除键及其对应的值。</li>
<li>clear() —— 删除所有数据。</li>
<li>key(index) —— 获取该索引下的键名。</li>
<li>length —— 存储的内容的长度。</li>
</ul>
<h2>localStorage</h2>
<ul>
<li>在同源的所有标签页和窗口之间共享数据。</li>
<li>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</li>
</ul>
<h3>遍历键</h3>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> localStorage<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> key <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>sessionStorage</h2>
<ul>
<li>sessionStorage 的数据只存在于当前浏览器标签页。
<ul>
<li>具有相同页面的另一个标签页中将会有不同的存储。</li>
<li>但是，它在同一标签页下的 iframe 之间是共享的（假如它们来自相同的源）。</li>
</ul>
</li>
<li>数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。
<blockquote>
<p>Vue组件之间可以共享sessionStorage中的数据。<br>
sessionStorage是存储在浏览器中的，可以在同一浏览器窗口tab会话期间被所有的组件访问和共享</p>
</blockquote>
</li>
</ul>
<h2>Storage事件</h2>
<p>当 localStorage 或 sessionStorage 中的数据更新后，storage 事件就会触发，它具有以下属性：</p>
<ul>
<li>key —— 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）。</li>
<li>oldValue —— 旧值（如果是新增数据，则为 null）。</li>
<li>newValue —— 新值（如果是删除数据，则为 null）。</li>
<li>url —— 发生数据更新的文档的 url。</li>
<li>storageArea —— 发生数据更新的 localStorage 或 sessionStorage 对象。</li>
</ul>
<div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 在其他文档对同一存储进行更新时触发</span>
window<span class="token punctuation">.</span><span class="token function-variable function">onstorage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 也可以使用 window.addEventListener('storage', event =&gt; {</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>key <span class="token operator">!=</span> <span class="token string">"now"</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>key <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>newValue <span class="token operator">+</span> <span class="token string">" at "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">,</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote>
<p>window是浏览器的全局对象</p>
<ul>
<li>全局变量和方法: 你可以像在普通的JavaScript中一样使用window对象来访问全局变量和方法，比如window.alert()。</li>
<li>事件监听器: 你可以使用window.addEventListener()来添加全局的事件监听器，比如监听resize事件。</li>
<li>浏览器API: 一些浏览器提供的API也是通过window对象访问的，比如<strong>window.localStorage</strong>和<strong>window.sessionStorage</strong>用于访问本地存储和会话存储。</li>
</ul>
</blockquote>
]]></content>
    <category term="vue"/>
    <published>2024-05-13T11:50:53.000Z</published>
  </entry>
  <entry>
    <title type="text">TypeScript介绍</title>
    <id>https://javaguide.cn/learning/system-design/framework/vue/typescript.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/vue/typescript.html"/>
    <updated>2024-05-13T15:08:06.000Z</updated>
    <summary type="html"><![CDATA[<h2>Basis</h2>
<p>vue原生支持TypeScript</p>
<ul>
<li>detect many common errors via static analysis at build time
<ul>
<li>reduces the chance of runtime errors in production</li>
<li>allows us to more confidently refactor code in large-scale applications</li>
</ul>
</li>
<li>improves developer ergonomics via type-based auto-completion in IDEs</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>Basis</h2>
<p>vue原生支持TypeScript</p>
<ul>
<li>detect many common errors via static analysis at build time
<ul>
<li>reduces the chance of runtime errors in production</li>
<li>allows us to more confidently refactor code in large-scale applications</li>
</ul>
</li>
<li>improves developer ergonomics via type-based auto-completion in IDEs</li>
</ul>
<h3>Project Setup</h3>
<p>create-vue, the official project scaffolding tool, offers the options to scaffold a Vite-powered, TypeScript-ready Vue project.</p>
<h3>Configuring tsconfig.json</h3>
<p>Projects scaffolded via create-vue include pre-configured tsconfig.json. The base config is abstracted in the @vue/tsconfig package.</p>
<p>When configuring tsconfig.json manually, some notable options include:</p>
<ul>
<li>compilerOptions.isolatedModules is set to true because Vite uses esbuild for transpiling TypeScript and is subject to single-file transpile limitations.</li>
<li>compilerOptions.verbatimModuleSyntax is a superset of isolatedModules and is a good choice, too - it's what @vue/tsconfig uses.</li>
</ul>
<h2>Vue usage with TS</h2>
<h3>defineComponent()</h3>
<h2>TypeScript with Composition API</h2>
<h3>Typing Component Props</h3>
<p>When using <strong>script setup</strong>, the defineProps() macro supports inferring the props types based on its argument:</p>
<ul>
<li>
<p>Runtime Declaration</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> String<span class="token punctuation">,</span> required<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  bar<span class="token operator">:</span> Number
<span class="token punctuation">}</span><span class="token punctuation">)</span>

props<span class="token punctuation">.</span>foo <span class="token comment">// string</span>
props<span class="token punctuation">.</span>bar <span class="token comment">// number | undefined</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li>
<li>
<p>Type-Based Declaration</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span>
  bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><blockquote>
<p>当一个属性被标记为可选时，表示它不是必需的，可以选择性地存在。<br>
如果该属性存在，则其类型必须符合指定的类型；<br>
如果不存在，则可以不提供该属性，或者将其值设为 undefined。</p>
</blockquote>
</li>
<li>
<p>move props types into a separate interface</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
  <span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span>
  bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>

  <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li>
<li>
<p>props imported from another source</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
    <span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> Props <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./foo'</span>

    <span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li>
<li>
<p>Props Default Values</p>
<blockquote>
<p>When using type-based declaration, we lose the ability to declare default values for the props.<br>
This can be resolved by the withDefaults compiler macro:</p>
</blockquote>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
  msg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  labels<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">withDefaults</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  msg<span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
  <span class="token function-variable function">labels</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
<li>
<p>Complex prop types</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
<span class="token keyword">interface</span> <span class="token class-name">Book</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span>
  author<span class="token operator">:</span> <span class="token builtin">string</span>
  year<span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  book<span class="token operator">:</span> Book
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li>
</ul>
<h3>Typing Component Emits</h3>
<ul>
<li>
<p>In <strong>script setup</strong>, the emit function can also be typed using either runtime declaration OR type declaration</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token operator">&lt;</span>script setup lang<span class="token operator">=</span><span class="token string">"ts"</span><span class="token operator">&gt;</span>
<span class="token comment">// runtime</span>
<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'change'</span><span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// options based</span>
<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">change</span><span class="token operator">:</span> <span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// return `true` or `false` to indicate</span>
    <span class="token comment">// validation pass / fail</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">update</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// return `true` or `false` to indicate</span>
    <span class="token comment">// validation pass / fail</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// type-based</span>
<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineEmits</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  <span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token string">'change'</span><span class="token punctuation">,</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
  <span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token string">'update'</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 3.3+: alternative, more succinct syntax</span>
<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineEmits</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  change<span class="token operator">:</span> <span class="token punctuation">[</span>id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">]</span>
  update<span class="token operator">:</span> <span class="token punctuation">[</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div></li>
<li>
<p><strong>Not in script setup</strong></p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  emits<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"change"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">setup</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token punctuation">{</span> emit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">"change"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- type check / auto-completion</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li>
</ul>
<h3>Typing Ref()</h3>
<ul>
<li>Refs infer the type from the initial value:</li>
</ul>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>

<span class="token comment">// inferred type: Ref&lt;number&gt;</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// =&gt; TS Error: Type 'string' is not assignable to type 'number'.</span>
<span class="token comment">//1.specify complex types</span>
year<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"2020"</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> Ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> year<span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">"2020"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//2.passing a generic argument</span>
year<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2020</span><span class="token punctuation">;</span> <span class="token comment">// ok!</span>

<span class="token comment">// resulting type: Ref&lt;string | number&gt;</span>
<span class="token keyword">const</span> year <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"2020"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

year<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2020</span><span class="token punctuation">;</span> <span class="token comment">// ok!</span>
<span class="token comment">//tips:</span>
<span class="token comment">//ref return undefined if not assigned inital value</span>
<span class="token comment">// inferred type: Ref&lt;number | undefined&gt;</span>
<span class="token keyword">const</span> n <span class="token operator">=</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2>TypeScript with Options API</h2>
]]></content>
    <category term="vue"/>
    <published>2024-05-13T11:50:53.000Z</published>
  </entry>
  <entry>
    <title type="text">TCP基础</title>
    <id>https://javaguide.cn/learning/cs-basics/network/tcp-basis.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/tcp-basis.html"/>
    <updated>2024-05-20T14:49:15.000Z</updated>
    <summary type="html"><![CDATA[<h2>TCP报文格式</h2>
<figure><figcaption></figcaption></figure>
<ul>
<li>
<p><strong>源端口 和 目标端口</strong>：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。</p>
</li>
<li>
<p><strong>序列号</strong>：共占用 4个字节。说明序列号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。当序号增加到 4294967296 后，下一个序号将回到0重新开始。在建立连接时由计算机生成的随机数作为其初始值（ISN，即Initial Sequence Number，初始序列号），通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小（其中要注意的是 SYN 和 FIN 包的 seq 也要消耗一个序号）。用来解决网络包乱序问题。</p>
</li>
<li>
<p><strong>确认号</strong>：共占用 4个字节。说明确认号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。它表示期望收到对方下一次数据的序列号（所以 ack 一般都是上次接收成功的数据字节序号加1），发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。TCP在接收到数据后 200ms 才会发送ACK包，这种设定是为了等待是否有数据可以一起发送的。</p>
</li>
<li>
<p><strong>数据偏移</strong>：共占 4 个bit，它表示的是TCP报文的数据起始处距离TCP报文起始处的距离有多远。实际生活中我们说距离多远，我们的单位通常是米，而这里距离有多远，单位是 4 个字节（也就是 32bit）。由于 4 个bit，能表示的最大整数是 15，也就说明 TCP 报文里数据开始的位置距离报文起点是 60 个字节（4*15）。这意味着 TCP 的首部（除数据外的都叫首部）长度是 20-60 个字节。</p>
</li>
<li>
<p><strong>窗口</strong>：共占 16 个bit，因此最大的窗口大小为 2^16-1 = 65535 = 64k。这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项里加一个 窗口扩大选项，来传输更多的数据。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>TCP报文格式</h2>
<figure><figcaption></figcaption></figure>
<ul>
<li>
<p><strong>源端口 和 目标端口</strong>：各占 2 个字节。2 个字节，也就是 16个 bit，这应该也能说明为什么计算机端口的范围是 1-65535 （0 不使用，2^16=65536，最大位65536不使用）了吧？有了源端口和目标端口，加上 IP 首部里的源IP和目标IP，就可以唯一确定一个连接。</p>
</li>
<li>
<p><strong>序列号</strong>：共占用 4个字节。说明序列号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。当序号增加到 4294967296 后，下一个序号将回到0重新开始。在建立连接时由计算机生成的随机数作为其初始值（ISN，即Initial Sequence Number，初始序列号），通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小（其中要注意的是 SYN 和 FIN 包的 seq 也要消耗一个序号）。用来解决网络包乱序问题。</p>
</li>
<li>
<p><strong>确认号</strong>：共占用 4个字节。说明确认号的范围是 [0, 2^32-1]，也就是 [0, 4294967296]。它表示期望收到对方下一次数据的序列号（所以 ack 一般都是上次接收成功的数据字节序号加1），发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。TCP在接收到数据后 200ms 才会发送ACK包，这种设定是为了等待是否有数据可以一起发送的。</p>
</li>
<li>
<p><strong>数据偏移</strong>：共占 4 个bit，它表示的是TCP报文的数据起始处距离TCP报文起始处的距离有多远。实际生活中我们说距离多远，我们的单位通常是米，而这里距离有多远，单位是 4 个字节（也就是 32bit）。由于 4 个bit，能表示的最大整数是 15，也就说明 TCP 报文里数据开始的位置距离报文起点是 60 个字节（4*15）。这意味着 TCP 的首部（除数据外的都叫首部）长度是 20-60 个字节。</p>
</li>
<li>
<p><strong>窗口</strong>：共占 16 个bit，因此最大的窗口大小为 2^16-1 = 65535 = 64k。这是早期的设计，对于现在的网络应用，可能会不太够，因此可以在选项里加一个 窗口扩大选项，来传输更多的数据。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p>
</li>
</ul>
<h2>TCP连接建立步骤</h2>
<figure><figcaption></figcaption></figure>
<h2>异常情况分析</h2>
<h3>试图与一个某端口建立连接但该主机已经宕机(主机宕机)</h3>
<p>这也是一种比较常见的情况，当某台服务器主机宕机了，而客户端并不知道，因此会重复发送SYNC数据包.</p>
<p>如下图所示，可以看到客户端每隔一段时间就会向服务端发送一个SYNC数据包。这里面具体的时间是跟TCP协议相关的，具体时间不同的操作系统实现可能稍有不同。</p>
<h3>建立连接时，服务器应用被阻塞(或者僵死)</h3>
<p>还有一种异常情况是，客户端建立连接的过程中服务端应用处于僵死状态，这种情况在实际中也会经常出现(我们假设仅仅应用程序僵死，而内核没有僵死)。</p>
<p>对于TCP的服务端来说，当它收到SYN数据包时，就会创建一个套接字的数据结构并给客户端回复ACK，再次收到客户端的ACK时会将套接字数据结构的状态转换为ESTABLISHED，并将其加入就绪队列。</p>
<p>当上面的套接字处于就绪队列时，accept函数才被唤醒了，可以从套接字中读取数据。</p>
<p>在 accept 返回之前，客户端也是可以发送数据的，因为数据的发送与接收都是在内核态进行的。客户端发送数据后，服务端的网卡会先接收，然后通过中断通知IP层，再上传到TCP层。TCP层根据目的端口和地址将数据存入关联的缓冲区。</p>
<p>到此，可以得出几点结论。</p>
<ul>
<li>在 accept 返回之前，三次握手已经完成。</li>
<li>TCP的客户端是否可以发送数据与服务端程序是否工作没有关系。</li>
</ul>
<p>但是如果内核也处于僵死状态，那情况可就完全不一样了。</p>
<p>此时由于机器完全卡死，TCP服务端无法接受任何消息，自然也无法给客户端发送任何应答报文，也不会有后续发送数据的环节了。</p>
]]></content>
    <category term="计算机基础"/>
    <published>2024-05-13T10:33:04.000Z</published>
  </entry>
  <entry>
    <title type="text">神经网络基础</title>
    <id>https://javaguide.cn/learning/neural-network/basis.html</id>
    <link href="https://javaguide.cn/learning/neural-network/basis.html"/>
    <updated>2024-05-12T14:28:01.000Z</updated>
    <summary type="html"><![CDATA[<h2>顶会期刊</h2>
<h3>Database</h3>
<ul>
<li>
<p><strong>SIGMOD</strong>：Special Interest Group on Management Of Data</p>
</li>
<li>
<p><strong>VLDB</strong>：International Conference on Very Large Data Bases</p>
</li>
<li>
<p><strong>ICDE</strong>：International Conference on Data Engineering</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>顶会期刊</h2>
<h3>Database</h3>
<ul>
<li>
<p><strong>SIGMOD</strong>：Special Interest Group on Management Of Data</p>
</li>
<li>
<p><strong>VLDB</strong>：International Conference on Very Large Data Bases</p>
</li>
<li>
<p><strong>ICDE</strong>：International Conference on Data Engineering</p>
</li>
</ul>
<h3>Machine Learning</h3>
<ul>
<li>
<p><strong>ICML</strong>：International Conference on Machine Learning</p>
</li>
<li>
<p><strong>NIPS</strong>：Neural Information Processing Systems</p>
</li>
</ul>
<h3>Artificial intelligence</h3>
<ul>
<li>
<p><strong>AAAI</strong>：American Association for Artificial Intelligence</p>
</li>
<li>
<p><strong>IJCAI</strong>：International Joint Conference on Artificial Intelligence</p>
</li>
<li>
<p><strong>NIPS</strong>：Neural Information Processing Systems</p>
</li>
<li>
<p><strong>ICML</strong>：International Conference on Machine Learning</p>
</li>
</ul>
<h3>计算机领域顶会论文</h3>
<figure><img src="/images/conference/top-conference-computer.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="/images/conference/top-journal-ai-ccfa.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="/images/conference/top-conference-ai-ccfa.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2>期刊论文搜索</h2>
<h3>A类</h3>
<ul>
<li>
<p><a href="http://dblp.uni-trier.de/db/journals/ai/" target="_blank" rel="noopener noreferrer">Artificial Intelligence（AI）</a></p>
</li>
<li>
<p><a href="http://dblp.uni-trier.de/db/journals/pami/" target="_blank" rel="noopener noreferrer">IEEE Trans on Pattern Analysis and Machine Intelligence （TPAMI）</a></p>
</li>
<li>
<p><a href="http://dblp.uni-trier.de/db/journals/ijcv/" target="_blank" rel="noopener noreferrer">International Journal of Computer Vision（IJCV）</a></p>
</li>
<li>
<p><a href="http://dblp.uni-trier.de/db/journals/jmlr/" target="_blank" rel="noopener noreferrer">Journal of Machine Learning Research（JMLR）</a></p>
</li>
</ul>
<h3>其他链接</h3>
<p><a href="https://zhuanlan.zhihu.com/p/87189934" target="_blank" rel="noopener noreferrer">知乎的链接</a></p>
]]></content>
    <category term="神经网络"/>
    <published>2024-05-12T14:26:44.000Z</published>
  </entry>
  <entry>
    <title type="text">genkins基础知识</title>
    <id>https://javaguide.cn/learning/tools/genkins/basis.html</id>
    <link href="https://javaguide.cn/learning/tools/genkins/basis.html"/>
    <updated>2024-05-09T16:00:48.000Z</updated>
    <summary type="html"><![CDATA[<h2>概念</h2>
<p>Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。</p>
<p>Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。</p>
<h2>安装</h2>
<h3>apt-get安装</h3>
<h3>docker安装</h3>
<h3>安装细节</h3>
<ul>
<li>
<p>jdk版本需为jdk17</p>
<blockquote>
<p>如果不是所需版本，在/usr/lib/jvm中找到相应的版本，将原有/usr/bin/java文件删除，并且通过以下指令建立新的符号链接：</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/lib/jvm/java-7/bin/java /usr/bin/java
</code></pre></div><blockquote>
<p>与此同时也可以删除原有的jdk：</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /usr/lib/jvm/java-9
</code></pre></div></li>
<li>
<p>初始运行端口为8080</p>
<blockquote>
<p>更改端口需到/etc/default/jenkins/jenkins.xml修改<strong>HTTP_PORT=8080</strong></p>
</blockquote>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>概念</h2>
<p>Jenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。</p>
<p>Jenkins 支持各种运行方式，可通过系统包、Docker 或者通过一个独立的 Java 程序。</p>
<h2>安装</h2>
<h3>apt-get安装</h3>
<h3>docker安装</h3>
<h3>安装细节</h3>
<ul>
<li>
<p>jdk版本需为jdk17</p>
<blockquote>
<p>如果不是所需版本，在/usr/lib/jvm中找到相应的版本，将原有/usr/bin/java文件删除，并且通过以下指令建立新的符号链接：</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/lib/jvm/java-7/bin/java /usr/bin/java
</code></pre></div><blockquote>
<p>与此同时也可以删除原有的jdk：</p>
</blockquote>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /usr/lib/jvm/java-9
</code></pre></div></li>
<li>
<p>初始运行端口为8080</p>
<blockquote>
<p>更改端口需到/etc/default/jenkins/jenkins.xml修改<strong>HTTP_PORT=8080</strong></p>
</blockquote>
</li>
</ul>
<h2>启动服务</h2>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> systemctl start jenkins
<span class="token function">sudo</span> systemctl restart jenkins
<span class="token function">sudo</span> systemctl status jenkins
</code></pre></div><h2>配置文件</h2>
<h3>Jenkins主目录</h3>
<p>Jenkins 的主目录是 Jenkins 服务器的根目录，其中包含了 Jenkins 的所有配置、作业、插件等信息。</p>
<p>默认情况下，Jenkins 的主目录位于 /var/lib/jenkins/ 目录下。</p>
<p>在这个目录中，你可以找到 Jenkins 的核心配置文件以及其他重要文件和目录。</p>
<h3>Jenkins的配置文件</h3>
<ul>
<li>config.xml: 这是 Jenkins 的主要配置文件，包含了全局配置信息，比如 Jenkins URL、Jenkins 主题、构建工具配置等。</li>
<li>credentials.xml: 这个文件包含了 Jenkins 的凭据配置信息，比如用户名、密码、API 密钥等。</li>
<li>hudson.plugins.gradle.Gradle.xml: 如果你使用了 Gradle 插件，该文件保存了 Gradle 插件的配置信息。</li>
<li>hudson.plugins.git.GitSCM.xml: 如果你使用了 Git 插件，该文件保存了 Git 插件的配置信息。</li>
</ul>
]]></content>
    <category term="genkins"/>
    <published>2024-05-09T16:00:48.000Z</published>
  </entry>
  <entry>
    <title type="text">genkins实践</title>
    <id>https://javaguide.cn/learning/tools/genkins/practice.html</id>
    <link href="https://javaguide.cn/learning/tools/genkins/practice.html"/>
    <updated>2024-05-09T16:00:48.000Z</updated>
    <summary type="html"><![CDATA[<h2>配置Github源代码</h2>
<ul>
<li>
<p>配置SSH凭据</p>
<ul>
<li>生成SSH密钥</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span> <span class="token parameter variable">-C</span> <span class="token string">"your_email@example.com"</span>
</code></pre></div><ul>
<li>
<p>将 SSH 公钥添加到 GitHub</p>
<p>~/.ssh/id_rsa.pub 文件中的内容复制并粘贴到 GitHub 的 "Key" 文本框中，并为 SSH 密钥添加一个描述，然后点击 "Add SSH key"</p>
</li>
<li>
<p>在 Jenkins 中配置 SSH 凭据</p>
</li>
</ul>
</li>
<li>
<p>SSH密钥验证<br>
下一步把github的host-key保存到linux服务器上</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-keyscan github.com <span class="token operator">&gt;&gt;</span> ~/.ssh/known_hosts
</code></pre></div><ul>
<li>host-key:github.com的公钥，在之后使用ssh连接github时搜索网站上的host key,判断ssh访问的主机是否被篡改过
<blockquote>
<p>那么主机B当前使用的host key保存在哪呢？在/etc/ssh/ssh_host*文件中，这些文件是服务端(此处即主机B)的sshd服务程序启动时重建的。以rsa算法为例，则保存在/etc/ssh/ssh_host_rsa_key和/etc/ssh/ssh_host_rsa_key.pub中，其中公钥文件/etc/ssh/ssh_host_rsa_key.pub中保存的就是host key。</p>
</blockquote>
</li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>配置Github源代码</h2>
<ul>
<li>
<p>配置SSH凭据</p>
<ul>
<li>生成SSH密钥</li>
</ul>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span> <span class="token parameter variable">-C</span> <span class="token string">"your_email@example.com"</span>
</code></pre></div><ul>
<li>
<p>将 SSH 公钥添加到 GitHub</p>
<p>~/.ssh/id_rsa.pub 文件中的内容复制并粘贴到 GitHub 的 "Key" 文本框中，并为 SSH 密钥添加一个描述，然后点击 "Add SSH key"</p>
</li>
<li>
<p>在 Jenkins 中配置 SSH 凭据</p>
</li>
</ul>
</li>
<li>
<p>SSH密钥验证<br>
下一步把github的host-key保存到linux服务器上</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ssh-keyscan github.com <span class="token operator">&gt;&gt;</span> ~/.ssh/known_hosts
</code></pre></div><ul>
<li>host-key:github.com的公钥，在之后使用ssh连接github时搜索网站上的host key,判断ssh访问的主机是否被篡改过
<blockquote>
<p>那么主机B当前使用的host key保存在哪呢？在/etc/ssh/ssh_host*文件中，这些文件是服务端(此处即主机B)的sshd服务程序启动时重建的。以rsa算法为例，则保存在/etc/ssh/ssh_host_rsa_key和/etc/ssh/ssh_host_rsa_key.pub中，其中公钥文件/etc/ssh/ssh_host_rsa_key.pub中保存的就是host key。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2>jenkins触发器</h2>
<h3>github webhooks</h3>
<p>当 GitHub 有代码提交时通知 Jenkins，你需要配置 GitHub 上的 Webhooks 来触发 Jenkins 的构建任务。</p>
<p>为此，你需要在 GitHub 仓库的设置中添加一个 Webhooks，并指定 Jenkins 服务器的 URL。</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>http://your_jenkins_server/github-webhook/
</code></pre></div><h2>jenkins构建后步骤</h2>
<h3>Shell</h3>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>User
<span class="token comment">#!/bin/sh</span>
<span class="token function-name function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token builtin class-name">echo</span> <span class="token string">'Start the program '</span>
    <span class="token builtin class-name">echo</span> '</code></pre></div>]]></content>
    <category term="开发工具"/>
    <published>2024-05-09T16:00:48.000Z</published>
  </entry>
  <entry>
    <title type="text">Transformer基础</title>
    <id>https://javaguide.cn/learning/neural-network/transformer/basis.html</id>
    <link href="https://javaguide.cn/learning/neural-network/transformer/basis.html"/>
    <updated>2024-05-08T16:27:28.000Z</updated>
    <summary type="html"><![CDATA[<h2>掩码</h2>
]]></summary>
    <content type="html"><![CDATA[<h2>掩码</h2>
]]></content>
    <category term="Transformer"/>
    <published>2024-05-08T16:27:28.000Z</published>
  </entry>
  <entry>
    <title type="text">Encoder层介绍</title>
    <id>https://javaguide.cn/learning/neural-network/transformer/encoder.html</id>
    <link href="https://javaguide.cn/learning/neural-network/transformer/encoder.html"/>
    <updated>2024-05-08T16:27:28.000Z</updated>
    <summary type="html"><![CDATA[<h2>Encoder</h2>
<figure><img src="http://47.94.135.15:81/Transformer/Encoder-Layer.webp" alt="Encoder-Layer" tabindex="0"><figcaption>Encoder-Layer</figcaption></figure>
<h3>Code Example</h3>
<div class="language-python" data-ext="py" data-title="EncoderLayer"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">EncoderLayer</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    Single encoder layer in a transformer encoder.

    Performs multi-head attention and position-wise feedforward operations.
    Supports layer normalization before or after these operations.

    Args:
        d_model (int): Embedding dimension size.
        ffn_hidden (int): Feedforward network hidden layer size.
        n_head (int): Number of attention heads.
        drop_prob (float): Dropout probability.
        norm_type (str): Type of layer normalization, 'pre' or 'post'.
        pe (str): Positional encoding type, 'rotary', 'relative' or 'absolute'.

    """</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> d_model<span class="token punctuation">,</span> ffn_hidden<span class="token punctuation">,</span> n_head<span class="token punctuation">,</span> drop_prob<span class="token punctuation">,</span> norm_type<span class="token punctuation">,</span> pe<span class="token operator">=</span><span class="token string">'absolute'</span><span class="token punctuation">,</span> norm_bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span>
                 <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> norm_type <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token string">'post'</span><span class="token punctuation">,</span> <span class="token string">'rezero'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> \
            <span class="token string">"norm_type must be 'pre', 'post' or 'rezero'"</span>
        <span class="token keyword">assert</span> pe <span class="token keyword">in</span> <span class="token punctuation">(</span>
            <span class="token string">'rotary'</span><span class="token punctuation">,</span> <span class="token string">'relative'</span><span class="token punctuation">,</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span> <span class="token string">'none'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rpe must be either 'rotary' or 'relative' or 'absolute'"</span>
        <span class="token keyword">if</span> pe <span class="token operator">==</span> <span class="token string">'rotary'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> MultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> pe <span class="token operator">==</span> <span class="token string">'relative'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> RPEMultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> MultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">,</span> pe<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>dropout1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>ffn <span class="token operator">=</span> PositionWiseFeedForward<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> hidden<span class="token operator">=</span>ffn_hidden<span class="token punctuation">,</span> drop_prob<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>dropout2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>norm_type <span class="token operator">=</span> norm_type  <span class="token comment"># post, pre, or rezero</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'pre'</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'post'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>norm1 <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> bias<span class="token operator">=</span>norm_bias<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>norm2 <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> bias<span class="token operator">=</span>norm_bias<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>res_weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> src_mask<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'post'</span><span class="token punctuation">:</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>norm1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x<span class="token punctuation">,</span> key<span class="token operator">=</span>x<span class="token punctuation">,</span> value<span class="token operator">=</span>x<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>norm2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'pre'</span><span class="token punctuation">:</span>
            x_pre_norm <span class="token operator">=</span> self<span class="token punctuation">.</span>norm1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> key<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> value<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>norm2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x
            <span class="token comment"># x = self.attention(query=x_pre_norm, key=x_pre_norm, value=x_pre_norm, mask=src_mask) + x</span>
            <span class="token comment"># x = self.ffn(self.norm2(x)) + x</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x<span class="token punctuation">,</span> key<span class="token operator">=</span>x<span class="token punctuation">,</span> value<span class="token operator">=</span>x<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>res_weight<span class="token punctuation">)</span> <span class="token operator">+</span> x
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>res_weight<span class="token punctuation">)</span> <span class="token operator">+</span> x
        <span class="token keyword">return</span> x
        <span class="token comment"># 输出给encoder的x的shape（batch_size,seq_len,embed_size）</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>Encoder</h2>
<figure><img src="http://47.94.135.15:81/Transformer/Encoder-Layer.webp" alt="Encoder-Layer" tabindex="0"><figcaption>Encoder-Layer</figcaption></figure>
<h3>Code Example</h3>
<div class="language-python" data-ext="py" data-title="EncoderLayer"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">EncoderLayer</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    Single encoder layer in a transformer encoder.

    Performs multi-head attention and position-wise feedforward operations.
    Supports layer normalization before or after these operations.

    Args:
        d_model (int): Embedding dimension size.
        ffn_hidden (int): Feedforward network hidden layer size.
        n_head (int): Number of attention heads.
        drop_prob (float): Dropout probability.
        norm_type (str): Type of layer normalization, 'pre' or 'post'.
        pe (str): Positional encoding type, 'rotary', 'relative' or 'absolute'.

    """</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> d_model<span class="token punctuation">,</span> ffn_hidden<span class="token punctuation">,</span> n_head<span class="token punctuation">,</span> drop_prob<span class="token punctuation">,</span> norm_type<span class="token punctuation">,</span> pe<span class="token operator">=</span><span class="token string">'absolute'</span><span class="token punctuation">,</span> norm_bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span>
                 <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> norm_type <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token string">'post'</span><span class="token punctuation">,</span> <span class="token string">'rezero'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> \
            <span class="token string">"norm_type must be 'pre', 'post' or 'rezero'"</span>
        <span class="token keyword">assert</span> pe <span class="token keyword">in</span> <span class="token punctuation">(</span>
            <span class="token string">'rotary'</span><span class="token punctuation">,</span> <span class="token string">'relative'</span><span class="token punctuation">,</span> <span class="token string">'absolute'</span><span class="token punctuation">,</span> <span class="token string">'none'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"rpe must be either 'rotary' or 'relative' or 'absolute'"</span>
        <span class="token keyword">if</span> pe <span class="token operator">==</span> <span class="token string">'rotary'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> MultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> pe <span class="token operator">==</span> <span class="token string">'relative'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> RPEMultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>attention <span class="token operator">=</span> MultiHeadAttention<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> n_head<span class="token operator">=</span>n_head<span class="token punctuation">,</span> pe<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>dropout1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>ffn <span class="token operator">=</span> PositionWiseFeedForward<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> hidden<span class="token operator">=</span>ffn_hidden<span class="token punctuation">,</span> drop_prob<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>dropout2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span>p<span class="token operator">=</span>drop_prob<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>norm_type <span class="token operator">=</span> norm_type  <span class="token comment"># post, pre, or rezero</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'pre'</span> <span class="token keyword">or</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'post'</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>norm1 <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> bias<span class="token operator">=</span>norm_bias<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>norm2 <span class="token operator">=</span> LayerNorm<span class="token punctuation">(</span>d_model<span class="token operator">=</span>d_model<span class="token punctuation">,</span> bias<span class="token operator">=</span>norm_bias<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>res_weight <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> src_mask<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'post'</span><span class="token punctuation">:</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>norm1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x<span class="token punctuation">,</span> key<span class="token operator">=</span>x<span class="token punctuation">,</span> value<span class="token operator">=</span>x<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>norm2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>norm_type <span class="token operator">==</span> <span class="token string">'pre'</span><span class="token punctuation">:</span>
            x_pre_norm <span class="token operator">=</span> self<span class="token punctuation">.</span>norm1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> key<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> value<span class="token operator">=</span>x_pre_norm<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>norm2<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> x
            <span class="token comment"># x = self.attention(query=x_pre_norm, key=x_pre_norm, value=x_pre_norm, mask=src_mask) + x</span>
            <span class="token comment"># x = self.ffn(self.norm2(x)) + x</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>attention<span class="token punctuation">(</span>query<span class="token operator">=</span>x<span class="token punctuation">,</span> key<span class="token operator">=</span>x<span class="token punctuation">,</span> value<span class="token operator">=</span>x<span class="token punctuation">,</span> mask<span class="token operator">=</span>src_mask<span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>res_weight<span class="token punctuation">)</span> <span class="token operator">+</span> x
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>dropout2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ffn<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>res_weight<span class="token punctuation">)</span> <span class="token operator">+</span> x
        <span class="token keyword">return</span> x
        <span class="token comment"># 输出给encoder的x的shape（batch_size,seq_len,embed_size）</span>
</code></pre></div>]]></content>
    <category term="Transformer"/>
    <published>2024-05-08T16:27:28.000Z</published>
  </entry>
  <entry>
    <title type="text">markdownit扩展语法</title>
    <id>https://javaguide.cn/learning/node/markdown/markdownit.html</id>
    <link href="https://javaguide.cn/learning/node/markdown/markdownit.html"/>
    <updated>2024-05-09T16:00:48.000Z</updated>
    <summary type="html"><![CDATA[<p>详情请点击<a href="https://github.com/markdown-it/markdown-it?tab=readme-ov-file#usage-examples" target="_blank" rel="noopener noreferrer">markdownit扩展用法</a></p>
<h2>footnote</h2>
<p>Here is a footnote reference,<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1"> and another.<sup class="footnote-ref"></sup></a><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></p>]]></summary>
    <content type="html"><![CDATA[<p>详情请点击<a href="https://github.com/markdown-it/markdown-it?tab=readme-ov-file#usage-examples" target="_blank" rel="noopener noreferrer">markdownit扩展用法</a></p>
<h2>footnote</h2>
<p>Here is a footnote reference,<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1"> and another.<sup class="footnote-ref"></sup></a><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></p><a class="footnote-anchor" id="footnote-ref2">
<hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref2">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref2">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref2"></a><p><a class="footnote-anchor" id="footnote-ref2">Here is the footnote. </a><a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>Here's one with multiple blocks.</p>
<p>Subsequent paragraphs are indented to show that they<br>
belong to the previous footnote. <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    <category term="markdown"/>
    <published>2024-05-06T01:10:21.000Z</published>
  </entry>
  <entry>
    <title type="text">slurm基础知识</title>
    <id>https://javaguide.cn/learning/linux/slurm/basis.html</id>
    <link href="https://javaguide.cn/learning/linux/slurm/basis.html"/>
    <updated>2024-05-05T08:07:02.000Z</updated>
    <summary type="html"><![CDATA[<h2>slurm介绍</h2>
<p>Slurm（Simple Linux Utility for Resource Management）是一个开源的、灵活的、可扩展的集群管理和作业调度系统，主要用于管理计算集群中的资源分配和作业调度。</p>
<ul>
<li>灵活性和可扩展性：Slurm可以轻松地配置和部署在各种规模和类型的集群上，并支持动态添加和移除节点。</li>
<li>高性能作业调度：Slurm具有高效的作业调度算法，可以有效地管理大规模集群上的作业并优化资源利用率。</li>
<li>资源管理：Slurm可以管理各种类型的资源，包括CPU、GPU、内存、网络等，并提供了细粒度的资源分配和控制。</li>
<li>可扩展的插件架构：Slurm提供了丰富的插件接口，允许用户根据需要定制和扩展功能。</li>
<li>可视化界面：Slurm提供了一些工具和界面，如sview，用于直观地查看集群状态和作业情况。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>slurm介绍</h2>
<p>Slurm（Simple Linux Utility for Resource Management）是一个开源的、灵活的、可扩展的集群管理和作业调度系统，主要用于管理计算集群中的资源分配和作业调度。</p>
<ul>
<li>灵活性和可扩展性：Slurm可以轻松地配置和部署在各种规模和类型的集群上，并支持动态添加和移除节点。</li>
<li>高性能作业调度：Slurm具有高效的作业调度算法，可以有效地管理大规模集群上的作业并优化资源利用率。</li>
<li>资源管理：Slurm可以管理各种类型的资源，包括CPU、GPU、内存、网络等，并提供了细粒度的资源分配和控制。</li>
<li>可扩展的插件架构：Slurm提供了丰富的插件接口，允许用户根据需要定制和扩展功能。</li>
<li>可视化界面：Slurm提供了一些工具和界面，如sview，用于直观地查看集群状态和作业情况。</li>
</ul>
<h2>slurm指令</h2>
<h3>sbatch指令</h3>
<ul>
<li>sbatch <a href="http://script.sh" target="_blank" rel="noopener noreferrer">script.sh</a>: 提交一个批处理作业，其中script.sh是包含作业配置和要运行的命令的脚本文件。</li>
<li>sbatch -n N <a href="http://script.sh" target="_blank" rel="noopener noreferrer">script.sh</a>: 指定作业使用的CPU核心数量为N。</li>
<li>sbatch --gres=gpu:N <a href="http://script.sh" target="_blank" rel="noopener noreferrer">script.sh</a>: 指定作业使用的GPU数量为N。</li>
<li>sbatch -p partition <a href="http://script.sh" target="_blank" rel="noopener noreferrer">script.sh</a>: 指定作业提交到的分区（partition），例如，如果有多个分区，可以使用这个选项来选择提交作业的分区。</li>
<li>sbatch -o output_file: 指定作业的标准输出文件。</li>
<li>sbatch -e error_file: 指定作业的标准错误输出文件。</li>
</ul>
<h3>其他指令</h3>
<ul>
<li>sinfo: 显示集群中当前节点的状态信息，包括节点名称、分区、节点状态（如idle、alloc、down等）、节点空闲核心数等。</li>
<li>squeue: 显示当前正在排队和运行的作业信息，包括作业ID、用户名、作业状态、提交时间、队列、节点分配等。</li>
<li>scontrol show job &lt;job_id&gt;: 显示特定作业的详细信息，包括作业ID、提交时间、作业状态、所用节点等。</li>
<li>scontrol show node &lt;node_name&gt;: 显示特定节点的详细信息，包括节点名称、状态、分区、空闲核心数、内存等。</li>
<li>sacct: 显示作业的账单信息，包括作业ID、用户、队列、提交时间、开始时间、结束时间、运行时间、CPU使用量等。</li>
<li>sview: 如果安装了sview工具，可以使用它来以图形化的方式查看集群的状态和作业情况。</li>
</ul>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>//脚本示例
#!/bin/bash
#SBATCH -J tensroflow
#SBATCH -p batch
#SBATCH -N 1
#SBATCH --gres=gpu:4
#SBATCH --ntasks-per-node=6
source /public/home/pfchao/miniconda3/bin/activate torch
python main.py
</code></pre></div>]]></content>
    <category term="linux"/>
    <published>2024-05-05T08:07:02.000Z</published>
  </entry>
  <entry>
    <title type="text">包管理器</title>
    <id>https://javaguide.cn/learning/node/package-manager.html</id>
    <link href="https://javaguide.cn/learning/node/package-manager.html"/>
    <updated>2024-05-05T05:51:46.000Z</updated>
    <summary type="html"><![CDATA[<h2>PNPM</h2>
<p>PNPM 是一种 JavaScript 包管理器，类似于 npm 和 Yarn。</p>
<p>PNPM 的全称是"Plug'n'Play NPM"，它的主要目标是改进包的安装和管理过程，减少磁盘占用和提高性能。</p>
<p>PNPM 通过共享依赖以及符号链接来实现这些优化。与传统的 npm 或 Yarn 不同，PNPM 在安装包时将它们链接到一个共享的存储库中，而不是将它们复制到每个项目的 node_modules 目录中。</p>
<blockquote>
<p>这种方法大大减少了磁盘占用，特别是当多个项目共享相同的依赖时。</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<h2>PNPM</h2>
<p>PNPM 是一种 JavaScript 包管理器，类似于 npm 和 Yarn。</p>
<p>PNPM 的全称是"Plug'n'Play NPM"，它的主要目标是改进包的安装和管理过程，减少磁盘占用和提高性能。</p>
<p>PNPM 通过共享依赖以及符号链接来实现这些优化。与传统的 npm 或 Yarn 不同，PNPM 在安装包时将它们链接到一个共享的存储库中，而不是将它们复制到每个项目的 node_modules 目录中。</p>
<blockquote>
<p>这种方法大大减少了磁盘占用，特别是当多个项目共享相同的依赖时。</p>
</blockquote>
<p>此外，PNPM 还能提供更快的安装速度，因为它只需要创建符号链接而不是复制文件。</p>
<h2>CNPM</h2>
<p>cnpm 是一种类似于 npm 的 JavaScript 包管理工具。 它的全称是"淘宝 NPM"，是由淘宝团队开发的。</p>
<p>与 npm 类似，cnpm 允许用户安装、管理和发布 JavaScript 包，但其主要目的是提供一个快速的下载源，以解决 npm 源在中国大陆地区访问速度较慢的问题。</p>
<h2>YARN</h2>
<p>Yarn 是一种比 npm 更快、更可靠的包管理解决方案。</p>
<ul>
<li>快速安装： Yarn 使用并行下载和缓存，因此通常比 npm 更快地安装依赖项。</li>
<li>可靠性： Yarn 锁定了每个安装的包的版本，以确保在不同环境中安装相同的依赖项时不会出现不一致。</li>
<li>安全性： Yarn 提供了一套命令和工具，用于检查依赖项中的安全漏洞，并提供修复建议。</li>
<li>离线模式： Yarn 允许在没有网络连接时安装依赖项，只需使用先前下载的缓存即可。</li>
<li>易于使用： Yarn 的命令与 npm 类似，因此对于大多数开发人员来说，迁移到 Yarn 是相对简单的。</li>
</ul>
]]></content>
    <category term="node.js"/>
    <published>2024-05-05T05:51:46.000Z</published>
  </entry>
  <entry>
    <title type="text">git版本管理</title>
    <id>https://javaguide.cn/learning/vcs/git.html</id>
    <link href="https://javaguide.cn/learning/vcs/git.html"/>
    <updated>2024-05-05T10:43:53.000Z</updated>
    <summary type="html"><![CDATA[<h2>git基本操作</h2>
<h3>merge</h3>
<p>在 Git 中，“合并”指的是将两个或多个不同的分支或线性提交历史中的更改集成到一起。</p>
<p>这通常发生在开发团队合作开发项目时，其中不同的开发者可能会在同一个代码库中编辑不同的文件或同一个文件的不同部分。</p>
<h3>pull</h3>
<p>在 Git 中，“拉取”（Pull）是指从远程仓库获取最新的更改并将其合并到本地仓库中。</p>
<p>当你和其他开发者协作工作时，他们可能会将他们的更改推送到共享的远程仓库中。</p>
<p>git pull命令实际上执行了两个操作：首先，它从远程仓库中获取最新的更改（使用 git fetch），然后将这些更改合并到当前分支中（使用 git merge）。</p>]]></summary>
    <content type="html"><![CDATA[<h2>git基本操作</h2>
<h3>merge</h3>
<p>在 Git 中，“合并”指的是将两个或多个不同的分支或线性提交历史中的更改集成到一起。</p>
<p>这通常发生在开发团队合作开发项目时，其中不同的开发者可能会在同一个代码库中编辑不同的文件或同一个文件的不同部分。</p>
<h3>pull</h3>
<p>在 Git 中，“拉取”（Pull）是指从远程仓库获取最新的更改并将其合并到本地仓库中。</p>
<p>当你和其他开发者协作工作时，他们可能会将他们的更改推送到共享的远程仓库中。</p>
<p>git pull命令实际上执行了两个操作：首先，它从远程仓库中获取最新的更改（使用 git fetch），然后将这些更改合并到当前分支中（使用 git merge）。</p>
<h3>fetch</h3>
<p>git fetch 是从远程仓库中获取最新的分支和提交，但它并不会自动将这些更改合并到你当前的分支中。</p>
<p>相比之下，git pull 命令执行 git fetch 的功能，并自动将获取的更改合并到当前分支。</p>
<h2>head</h2>
<h3>基本概念</h3>
<p>"HEAD"是一个指针，它指向当前所在的本地分支的最新提交（commit）。</p>
<p>换句话说，"HEAD"表示你当前所处的工作目录所对应的提交。当你在工作目录中进行操作时，例如提交新的更改或创建新的分支，Git会更新"HEAD"指向最新的提交</p>
<h3>实例</h3>
<ul>
<li>当你在一个分支上工作时，"HEAD"指向这个分支，表示你当前所处的工作上下文。</li>
<li>当你创建一个新的提交时，"HEAD"会随之移动到这个新的提交上。</li>
<li>当你切换分支或者检出一个特定的提交时，"HEAD"会随之更新为指向对应的分支或提交。</li>
</ul>
<h2>git分支操作</h2>
<h3>重置当前提交记录</h3>
<ul>
<li>
<p>重置类型</p>
<ul>
<li>软重置（soft reset）：在软重置模式下，HEAD 指针会移动到目标提交上，但工作目录和暂存区中的文件不会受到影响，也不会改变提交历史。这意味着你可以重新提交当前状态的文件，或者修改后重新提交。</li>
<li>混合重置（mixed reset）：在混合重置模式下，HEAD 指针会移动到目标提交上，工作目录中的文件会恢复到目标提交的状态，但是暂存区中的文件不会受到影响。这意味着你需要重新添加文件到暂存区，并重新提交这些文件。</li>
<li>硬重置（hard reset）：在硬重置模式下，HEAD 指针会移动到目标提交上，工作目录中的文件和暂存区中的文件都会恢复到目标提交的状态，提交历史也会被改变。这意味着你会丢失所有未提交的更改，因此需要谨慎使用。</li>
</ul>
</li>
<li>
<p>使用本地仓库记录重置</p>
<ul>
<li>硬重置会将当前分支的指针（通常是 HEAD 指针）直接移动到目标提交上，这意味着 Git 将会忽略（丢弃）当前分支之后的所有提交。</li>
<li>硬重置会同时更新工作目录和暂存区，使它们与目标提交的状态一致。因此，任何未提交的更改都会被删除。</li>
</ul>
</li>
<li>
<p>使用远程仓库记录重置</p>
<ul>
<li>不会导致当前分支之后的记录丢失</li>
<li>当你将本地重置后的提交推送到远程仓库时，Git 会尝试将本地仓库的提交历史与远程仓库的提交历史合并。由于远程仓库的提交历史不受本地重置操作的影响，因此推送操作可能会被拒绝</li>
</ul>
</li>
</ul>
<h3>解决远程和本地仓库不一致</h3>
<ul>
<li>
<p>使用 --force 选项进行强制推送：</p>
<p>如果你确定要覆盖远程仓库的提交历史，可以使用 git push --force 命令来强制推送。这会覆盖远程仓库的提交历史，并将本地仓库的提交历史应用到远程仓库中。但是请注意，强制推送可能会导致其他开发者的工作丢失，因此应该谨慎使用。</p>
</li>
<li>
<p>使用 --force-with-lease 选项进行安全的强制推送：</p>
<p>git push --force-with-lease 命令是一种相对安全的强制推送方式。它会先检查远程仓库的提交历史是否与本地仓库的提交历史匹配，只有在匹配的情况下才会执行推送操作。这可以避免在多人协作的情况下意外覆盖其他开发者的提交。</p>
</li>
<li>
<p>使用 git revert 撤销错误的提交：</p>
<p>如果推送操作被拒绝是因为你想要撤销错误的提交，可以使用 git revert 命令来创建新的提交以撤销之前的提交。这样可以保留提交历史，并且不会影响其他开发者的工作。</p>
</li>
<li>
<p>使用 git pull 对远程仓库的head记录进行抓取合并：</p>
<p>有时候需要自己手动进行合并</p>
<p>webstorm合并窗口：左边是本地分支内容，中间是合并后的内容，右边是远程分支内容，可以根据窗口之间的提示进行合并</p>
</li>
</ul>
<h2>问题</h2>
<h3>未提交先推送</h3>
<p>Git会拒绝推送并显示一个错误消息，提示你先提交你的修改。这是因为Git要求在推送之前先将本地的修改提交到本地仓库。</p>
]]></content>
    <category term="vcs"/>
    <published>2024-05-05T05:51:46.000Z</published>
  </entry>
  <entry>
    <title type="text">Bash和Shell程序</title>
    <id>https://javaguide.cn/learning/linux/bash.html</id>
    <link href="https://javaguide.cn/learning/linux/bash.html"/>
    <updated>2024-05-04T16:35:33.000Z</updated>
    <summary type="html"><![CDATA[<h2>Shell</h2>
<ul>
<li>壳程序，调用其他应用程序</li>
<li>用户&lt;---&gt;Shell&lt;---&gt;内核&lt;---&gt;硬件</li>
</ul>
<h3>Linux提供的shell版本</h3>
<ul>
<li>/bin/shell</li>
<li>/bin/bash</li>
<li>/bin/tcsh</li>
<li>/bin/csh</li>
</ul>
<h2>Bash</h2>
<p><strong>是shell的一个版本</strong></p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>cat /etc/passwd
//查看不同用户所使用的shell
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>Shell</h2>
<ul>
<li>壳程序，调用其他应用程序</li>
<li>用户&lt;</li>
</ul>
]]></content>
    <category term="Linux"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">基础知识</title>
    <id>https://javaguide.cn/learning/linux/basis.html</id>
    <link href="https://javaguide.cn/learning/linux/basis.html"/>
    <updated>2024-05-09T16:00:48.000Z</updated>
    <summary type="html"><![CDATA[<h2>Linux基础</h2>
<h3>目录配置</h3>
<ol>
<li>/etc 配置文件存放目录
<ul>
<li>/etc/default</li>
</ul>
</li>
<li>/usr/bin 可执行文件</li>
<li>/usr/lib 程序使用的动态函数库</li>
<li>/usr/share/doc 软件使用手册和说明文件</li>
<li>/usr/share/man man page文件</li>
</ol>
<h3>常用命令行工具</h3>
<ul>
<li>
<p>wget<br>
这是一个用于从网络上下载文件的命令行工具<br>
<strong>code example1:</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">wget</span> <span class="token parameter variable">-q</span> <span class="token parameter variable">-O</span> - https://pkg.jenkins.io/debian/jenkins.io.key <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</code></pre></div><ul>
<li>-q:在wget中，表示静默模式，即不显示任何下载信息，只显示错误信息</li>
<li>-O -: -O 选项用于指定下载文件的输出路径，其中 - 表示将文件内容输出到标准输出流（stdout）</li>
<li><a href="https://pkg.jenkins.io/debian/jenkins.io.key:" target="_blank" rel="noopener noreferrer">https://pkg.jenkins.io/debian/jenkins.io.key:</a> 这是 Jenkins 官方仓库的 GPG 公钥的 URL 地址，用于验证 Jenkins 软件包的完整性和真实性。</li>
<li>|: 这是管道操作符，将命令的输出作为另一个命令的输入。</li>
<li>sudo apt-key add -: 这条命令将通过 wget 下载的 Jenkins GPG 公钥添加到系统的 APT 密钥管理中。这样，在以后使用 apt 命令安装 Jenkins 时，系统就可以使用该密钥来验证软件包的签名，确保软件包的完整性和来源可信。</li>
</ul>
<p><strong>code example2:</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'</span>
</code></pre></div><p>这部分命令是使用 echo 命令将 Jenkins 官方软件仓库的地址写入到一个新建的文件 /etc/apt/sources.list.d/jenkins.list 中。</p>
<p>该文件是 APT 软件源列表的一个片段，用于指定系统要从哪里获取软件包</p>
<ul>
<li>sh -c 'command': 这个命令是在 shell 中执行指定的命令。在这种情况下，command 是一个包含在单引号内的命令字符串。</li>
<li>deb: 这个关键字表示这是一个二进制软件包仓库。<br>
<a href="http://pkg.jenkins.io/debian-stable:" target="_blank" rel="noopener noreferrer">http://pkg.jenkins.io/debian-stable:</a> 这是 Jenkins 官方二进制软件包仓库的地址。</li>
<li>binary/: 这个路径指定了二进制软件包在仓库中的位置。</li>
<li>&gt;: 这个符号表示将命令的输出重定向到指定的文件中。</li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>Linux基础</h2>
<h3>目录配置</h3>
<ol>
<li>/etc 配置文件存放目录
<ul>
<li>/etc/default</li>
</ul>
</li>
<li>/usr/bin 可执行文件</li>
<li>/usr/lib 程序使用的动态函数库</li>
<li>/usr/share/doc 软件使用手册和说明文件</li>
<li>/usr/share/man man page文件</li>
</ol>
<h3>常用命令行工具</h3>
<ul>
<li>
<p>wget<br>
这是一个用于从网络上下载文件的命令行工具<br>
<strong>code example1:</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">wget</span> <span class="token parameter variable">-q</span> <span class="token parameter variable">-O</span> - https://pkg.jenkins.io/debian/jenkins.io.key <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</code></pre></div><ul>
<li>-q:在wget中，表示静默模式，即不显示任何下载信息，只显示错误信息</li>
<li>-O -: -O 选项用于指定下载文件的输出路径，其中 - 表示将文件内容输出到标准输出流（stdout）</li>
<li><a href="https://pkg.jenkins.io/debian/jenkins.io.key:" target="_blank" rel="noopener noreferrer">https://pkg.jenkins.io/debian/jenkins.io.key:</a> 这是 Jenkins 官方仓库的 GPG 公钥的 URL 地址，用于验证 Jenkins 软件包的完整性和真实性。</li>
<li>|: 这是管道操作符，将命令的输出作为另一个命令的输入。</li>
<li>sudo apt-key add -: 这条命令将通过 wget 下载的 Jenkins GPG 公钥添加到系统的 APT 密钥管理中。这样，在以后使用 apt 命令安装 Jenkins 时，系统就可以使用该密钥来验证软件包的签名，确保软件包的完整性和来源可信。</li>
</ul>
<p><strong>code example2:</strong></p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">sudo</span> <span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'</span>
</code></pre></div><p>这部分命令是使用 echo 命令将 Jenkins 官方软件仓库的地址写入到一个新建的文件 /etc/apt/sources.list.d/jenkins.list 中。</p>
<p>该文件是 APT 软件源列表的一个片段，用于指定系统要从哪里获取软件包</p>
<ul>
<li>sh -c 'command': 这个命令是在 shell 中执行指定的命令。在这种情况下，command 是一个包含在单引号内的命令字符串。</li>
<li>deb: 这个关键字表示这是一个二进制软件包仓库。<br>
<a href="http://pkg.jenkins.io/debian-stable:" target="_blank" rel="noopener noreferrer">http://pkg.jenkins.io/debian-stable:</a> 这是 Jenkins 官方二进制软件包仓库的地址。</li>
<li>binary/: 这个路径指定了二进制软件包在仓库中的位置。</li>
<li>&gt;: 这个符号表示将命令的输出重定向到指定的文件中。</li>
</ul>
</li>
</ul>
]]></content>
    <category term="Linux"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">Daemon和Service</title>
    <id>https://javaguide.cn/learning/linux/daemon.html</id>
    <link href="https://javaguide.cn/learning/linux/daemon.html"/>
    <updated>2024-05-05T05:37:54.000Z</updated>
    <summary type="html"><![CDATA[<h2>daemon</h2>
<p><strong>类似于服务</strong></p>
<h2>systemd</h2>
<p><strong>启动服务管理机制</strong></p>
<h3>优势</h3>
<ul>
<li>并行处理所有服务</li>
<li>一经要求就响应的on-demand启动方式</li>
<li>服务依赖性的自动检查</li>
<li>依daemon功能分类</li>
<li>将多个daemons作为一个群组</li>
<li>向下兼容就有init脚本</li>
</ul>
<h3>配置文件目录</h3>
<ul>
<li>/usr/lib/systemd/system 每个服务最主要的启动脚本设置</li>
<li>/run/systemd/system 系统执行所产生的服务脚本</li>
<li>/etc/systemd/system 管理员根据主机系统需要所建立的执行脚本</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2>daemon</h2>
<p><strong>类似于服务</strong></p>
<h2>systemd</h2>
<p><strong>启动服务管理机制</strong></p>
<h3>优势</h3>
<ul>
<li>并行处理所有服务</li>
<li>一经要求就响应的on-demand启动方式</li>
<li>服务依赖性的自动检查</li>
<li>依daemon功能分类</li>
<li>将多个daemons作为一个群组</li>
<li>向下兼容就有init脚本</li>
</ul>
<h3>配置文件目录</h3>
<ul>
<li>/usr/lib/systemd/system 每个服务最主要的启动脚本设置</li>
<li>/run/systemd/system 系统执行所产生的服务脚本</li>
<li>/etc/systemd/system 管理员根据主机系统需要所建立的执行脚本</li>
</ul>
<p><strong>上述目录优先级依次递增</strong></p>
<h3>创建service</h3>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>[Unit]
Description=My Node.js App
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/node /path/to/your/node/app.js
Restart=always

[Install]
WantedBy=multi-user.target
//表示该服务应该在系统启动到多用户模式时被启动
//当执行enable service时，自动在 multi-user.target.wants 目录下创建service的符号连接
</code></pre></div><ul>
<li>[Install]<br>
multi-user.target 是一个 Systemd 的目标单元，代表了多用户模式。在多用户模式下，系统启动后会运行大部分用户级别的服务。</li>
</ul>
]]></content>
    <category term="Linux"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">RPM基础</title>
    <id>https://javaguide.cn/learning/linux/rpm.html</id>
    <link href="https://javaguide.cn/learning/linux/rpm.html"/>
    <updated>2024-06-07T12:35:09.000Z</updated>
    <summary type="html"><![CDATA[<h3>RPM</h3>
<p>RPM软件管理程序：rpm</p>
<ul>
<li>root才能使用rpm</li>
<li>rpm不同于apt-get，rpm需要相应rpm文件才能安装软件；</li>
<li>可以不联网，通过将安装光盘挂载</li>
</ul>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>mount /dev/sr0 /mnt
find /mnt -name 'pam-devel*'
rpm -ivh pam-devel... --test
rpm -ivh pam-devel...
umonut /mnt
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h3>RPM</h3>
<p>RPM软件管理程序：rpm</p>
<ul>
<li>root才能使用rpm</li>
<li>rpm不同于apt-get，rpm需要相应rpm文件才能安装软件；</li>
<li>可以不联网，通过将安装光盘挂载</li>
</ul>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>mount /dev/sr0 /mnt
find /mnt -name 'pam-devel*'
rpm -ivh pam-devel... --test
rpm -ivh pam-devel...
umonut /mnt
</code></pre></div>]]></content>
    <category term="Linux"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">redis语法基础</title>
    <id>https://javaguide.cn/learning/database/redis/redis-basis.html</id>
    <link href="https://javaguide.cn/learning/database/redis/redis-basis.html"/>
    <updated>2024-05-08T16:27:28.000Z</updated>
    <summary type="html"><![CDATA[<h2>Windows使用</h2>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-server redis.windows.conf
<span class="token comment">#使用指定配置文件启动redis服务器</span>
redis-cli <span class="token parameter variable">-h</span> localhost <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">-a</span> your_password
<span class="token comment">#在另一个cmd窗口启动redis数据库</span>
redis-cil <span class="token function">shutdown</span>
<span class="token comment">#关闭服务器</span>
AUTH your_password
<span class="token comment">#在启动数据库后输入密码进行身份验证</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>Windows使用</h2>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>redis-server redis.windows.conf
<span class="token comment">#使用指定配置文件启动redis服务器</span>
redis-cli <span class="token parameter variable">-h</span> localhost <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token parameter variable">-a</span> your_password
<span class="token comment">#在另一个cmd窗口启动redis数据库</span>
redis-cil <span class="token function">shutdown</span>
<span class="token comment">#关闭服务器</span>
AUTH your_password
<span class="token comment">#在启动数据库后输入密码进行身份验证</span>
</code></pre></div><h2>DataStructure</h2>
<h3>Set</h3>
<p>Some of the important commands in working with sets are SADD, SREM, SISMEMBER, SMEMBERS and SUNION.</p>
<ol>
<li>SADD 加值（随机）</li>
</ol>
<div class="language-r" data-ext="r" data-title="r"><pre class="language-r"><code>    SADD superpowers <span class="token string">"flight"</span>
    SADD superpowers <span class="token string">"x-ray vision"</span> <span class="token string">"reflexes"</span>

</code></pre></div><ol start="2">
<li>SREM移除值（随机）</li>
<li>SISMEMBER测试值是否存在</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>SISMEMBER superpowers "flight" =&gt; 1
SISMEMBER superpowers "reflexes" =&gt; 0
</code></pre></div><ol start="4">
<li>SMEMBERS returns a list of all the members of this set.</li>
<li>SUNION combines two or more sets and returns the list of all elements.</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>SADD birdpowers "pecking"
    SADD birdpowers "flight"
    SUNION superpowers birdpowers =&gt; 1) "pecking", 2) "x-ray vision", 3) "flight"
</code></pre></div><ol start="6">
<li>SPOP、SADD（随机）</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>SADD letters a b c d e f =&gt; 6
    SPOP letters 2 =&gt; 1) "c" 2) "a"
</code></pre></div><h3>sorted list</h3>
<ol>
<li>ZADD</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>ZADD hackers 1940 "Alan Kay"
    ZADD hackers 1906 "Grace Hopper"
    ZADD hackers 1953 "Richard Stallman"
    ZADD hackers 1965 "Yukihiro Matsumoto"
    ZADD hackers 1916 "Claude Shannon"
    ZADD hackers 1969 "Linus Torvalds"
    ZADD hackers 1957 "Sophie Wilson"
    ZADD hackers 1912 "Alan Turing"
</code></pre></div><ol start="2">
<li>ZRANGE</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>ZRANGE hackers 2 4 =&gt; 1) "Claude Shannon", 2) "Alan Kay", 3) "Richard Stallman"
</code></pre></div><h3>Hashes</h3>
<ol>
<li>HSET</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>HSET user:1000 name "John Smith"
    HSET user:1000 email "john.smith@example.com"
    HSET user:1000 password "s3cret"
</code></pre></div><ol start="2">
<li>HGETALL返回一个键的所有值</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code> HGETALL user:1000
</code></pre></div><ol start="3">
<li>HGET返回一个键的特定值</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>HGET user:1001 name =&gt; "Mary Jones"
</code></pre></div><ol start="4">
<li>可以单独对hash的值进行操作</li>
</ol>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>HSET user:1000 visits 10
    HINCRBY user:1000 visits 1 =&gt; 11
    HINCRBY user:1000 visits 10 =&gt; 21
    HDEL user:1000 visits
    HINCRBY user:1000 visits 1 =&gt; 1
</code></pre></div><h3>bitmap</h3>
<ol>
<li>bitop</li>
</ol>
<p>对键值进行and、or、xor、not操作<br>
操作的较短字符串会被zero-padding</p>
<div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>redis&gt; SET key1 "foobar"
"OK"
redis&gt; SET key2 "abcdef"
"OK"
redis&gt; BITOP AND dest key1 key2
(integer) 6
redis&gt; GET dest
"`bc`ab"
redis&gt;
</code></pre></div>]]></content>
    <category term="数据库"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">Reactor模式</title>
    <id>https://javaguide.cn/learning/system-design/designMode/reactorDesign.html</id>
    <link href="https://javaguide.cn/learning/system-design/designMode/reactorDesign.html"/>
    <updated>2024-05-04T16:35:33.000Z</updated>
    <summary type="html"><![CDATA[<figure><img src="https://pic3.zhimg.com/80/v2-30401fced0ce7a24ac6299f785bc16fa_1440w.webp" alt="v2-30401fced0ce7a24ac6299f785bc16fa_1440w" tabindex="0"><figcaption>v2-30401fced0ce7a24ac6299f785bc16fa_1440w</figcaption></figure>
<h2>Reactor模式</h2>
<p>反应器模式或应答者模式，是基于事件驱动的设计模式，拥有一个或多个并发输入源，有一个服务处理器和多个请求处理器，服务处理器会同步的将输入的请求事件以多路复用的方式分发给相应的请求处理器。</p>]]></summary>
    <content type="html"><![CDATA[<figure><img src="https://pic3.zhimg.com/80/v2-30401fced0ce7a24ac6299f785bc16fa_1440w.webp" alt="v2-30401fced0ce7a24ac6299f785bc16fa_1440w" tabindex="0"><figcaption>v2-30401fced0ce7a24ac6299f785bc16fa_1440w</figcaption></figure>
<h2>Reactor模式</h2>
<p>反应器模式或应答者模式，是基于事件驱动的设计模式，拥有一个或多个并发输入源，有一个服务处理器和多个请求处理器，服务处理器会同步的将输入的请求事件以多路复用的方式分发给相应的请求处理器。</p>
<p>1、非阻塞的线程接收请求</p>
<p>2、适用于高并发系统</p>
<h3>单Reactor多线程</h3>
<figure><img src="https://pic3.zhimg.com/80/v2-5754d9ebf6b9b621a1ff89545974b6ea_1440w.webp" alt="v2-5754d9ebf6b9b621a1ff89545974b6ea_1440w" tabindex="0"><figcaption>v2-5754d9ebf6b9b621a1ff89545974b6ea_1440w</figcaption></figure>
<p>1、Reactor通过select监听客户端请求，建立连接</p>
<p>2、如果建立连接，Acceptor通过accept处理连接请求，创建Handler处理事件</p>
<p>3、如果没建立连接，由Reactor分发调用连接对应的handler来处理</p>
<p>4、handler只负责相应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务。</p>
<p>5、worker线程池会分配独立线程完成真正的业务，并将结果返回给handler。</p>
<p>6、handler收到响应后，通过send分发将结果返回给client。</p>
<h3>主从Reactor多线程</h3>
<figure><img src="https://pic2.zhimg.com/80/v2-ce188fec5a25fe51ea7a2151bdeff135_1440w.webp" alt="v2-ce188fec5a25fe51ea7a2151bdeff135_1440w" tabindex="0"><figcaption>v2-ce188fec5a25fe51ea7a2151bdeff135_1440w</figcaption></figure>
]]></content>
    <category term="系统设计"/>
    <published>2024-05-04T16:35:33.000Z</published>
  </entry>
  <entry>
    <title type="text">Java 线程练习</title>
    <id>https://javaguide.cn/learning/java/concurrent/java-thread-point.html</id>
    <link href="https://javaguide.cn/learning/java/concurrent/java-thread-point.html"/>
    <updated>2024-04-24T12:00:17.000Z</updated>
    <summary type="html"><![CDATA[<h2>守护进程</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//这是一个无线计数器</span>
<span class="token keyword">class</span> <span class="token class-name">TimerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//可以使用守护进程</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>守护进程</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//这是一个无线计数器</span>
<span class="token keyword">class</span> <span class="token class-name">TimerThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//可以使用守护进程</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>线程t作为守护线程开启可以进行无限循环，无需担心虚拟机一直不退出</p>
<p>因为守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<h2>同步锁</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 锁住this</span>
        count <span class="token operator">+=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// 解锁</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 锁住this</span>
    count <span class="token operator">+=</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 解锁</span>

</code></pre></div><p>上述写法等价</p>
<h2>wait和notify方法</h2>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> waitAndnotify <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newQueue queue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">newQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getting queue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"adding queue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> newQueue<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果使用notify()随机唤醒，其他线程可能永远不被唤醒，具有危险性</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>ReentrantLock</h2>
<p>可以使用ReentrantLock替代synchronized方法</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> reentrantlock <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Counter</span> counter<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
            counter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>

            counter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Counter</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">{</span>
    <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//可以使用tryLock方法尝试获取，如果获取不到就执行其他</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
            n<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//tryLock方法</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>]]></content>
    <category term="Java"/>
    <published>2024-04-24T12:00:17.000Z</published>
  </entry>
  <entry>
    <title type="text">如何基于Redis实现延时任务</title>
    <id>https://javaguide.cn/learning/database/redis/redis-delayed-task.html</id>
    <link href="https://javaguide.cn/learning/database/redis/redis-delayed-task.html"/>
    <updated>2024-03-23T02:55:07.000Z</updated>
    <summary type="html"><![CDATA[<p>基于 Redis 实现延时任务的功能无非就下面两种方案：</p>
<ol>
<li>Redis 过期事件监听</li>
<li>Redisson 内置的延时队列</li>
</ol>
<p>面试的时候，你可以先说自己考虑了这两种方案，但最后发现 Redis 过期事件监听这种方案存在很多问题，因此你最终选择了 Redisson 内置的 DelayedQueue 这种方案。</p>
<p>这个时候面试官可能会追问你一些相关的问题，我们后面会提到，提前准备就好了。</p>
<p>另外，除了下面介绍到的这些问题之外，Redis 相关的常见问题建议你都复习一遍，不排除面试官会顺带问你一些 Redis 的其他问题。</p>]]></summary>
    <content type="html"><![CDATA[<p>基于 Redis 实现延时任务的功能无非就下面两种方案：</p>
<ol>
<li>Redis 过期事件监听</li>
<li>Redisson 内置的延时队列</li>
</ol>
<p>面试的时候，你可以先说自己考虑了这两种方案，但最后发现 Redis 过期事件监听这种方案存在很多问题，因此你最终选择了 Redisson 内置的 DelayedQueue 这种方案。</p>
<p>这个时候面试官可能会追问你一些相关的问题，我们后面会提到，提前准备就好了。</p>
<p>另外，除了下面介绍到的这些问题之外，Redis 相关的常见问题建议你都复习一遍，不排除面试官会顺带问你一些 Redis 的其他问题。</p>
<h3>Redis 过期事件监听实现延时任务功能的原理？</h3>
<p>Redis 2.0 引入了发布订阅 (pub/sub) 功能。在 pub/sub 中，引入了一个叫做 <strong>channel（频道）</strong> 的概念，有点类似于消息队列中的 <strong>topic（主题）</strong>。</p>
<p>pub/sub 涉及发布者（publisher）和订阅者（subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png" alt="Redis 发布订阅 (pub/sub) 功能" tabindex="0"><figcaption>Redis 发布订阅 (pub/sub) 功能</figcaption></figure>
<p>在 pub/sub 模式下，生产者需要指定消息发送到哪个 channel 中，而消费者则订阅对应的 channel 以获取消息。</p>
<p>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息的，而不是我们自己编写的代码。其中，<code>__keyevent@0__:expired</code> 就是一个默认的 channel，负责监听 key 的过期事件。也就是说，当一个 key 过期之后，Redis 会发布一个 key 过期的事件到<code>__keyevent@&lt;db&gt;__:expired</code>这个 channel 中。</p>
<p>我们只需要监听这个 channel，就可以拿到过期的 key 的消息，进而实现了延时任务功能。</p>
<p>这个功能被 Redis 官方称为 <strong>keyspace notifications</strong> ，作用是实时监控实时监控 Redis 键和值的变化。</p>
<h3>Redis 过期事件监听实现延时任务功能有什么缺陷？</h3>
<p><strong>1、时效性差</strong></p>
<p>官方文档的一段介绍解释了时效性差的原因，地址：<a href="https://redis.io/docs/manual/keyspace-notifications/#timing-of-expired-events" target="_blank" rel="noopener noreferrer">https://redis.io/docs/manual/keyspace-notifications/#timing-of-expired-events</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-timing-of-expired-events.png" alt="Redis 过期事件" tabindex="0"><figcaption>Redis 过期事件</figcaption></figure>
<p>这段话的核心是：过期事件消息是在 Redis 服务器删除 key 时发布的，而不是一个 key 过期之后就会就会直接发布。</p>
<p>我们知道常用的过期数据的删除策略就两个：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>因此，就会存在我设置了 key 的过期时间，但到了指定时间 key 还未被删除，进而没有发布过期事件的情况。</p>
<p><strong>2、丢消息</strong></p>
<p>Redis 的 pub/sub 模式中的消息并不支持持久化，这与消息队列不同。在 Redis 的 pub/sub 模式中，发布者将消息发送给指定的频道，订阅者监听相应的频道以接收消息。当没有订阅者时，消息会被直接丢弃，在 Redis 中不会存储该消息。</p>
<p><strong>3、多服务实例下消息重复消费</strong></p>
<p>Redis 的 pub/sub 模式目前只有广播模式，这意味着当生产者向特定频道发布一条消息时，所有订阅相关频道的消费者都能够收到该消息。</p>
<p>这个时候，我们需要注意多个服务实例重复处理消息的问题，这会增加代码开发量和维护难度。</p>
<h3>Redisson 延迟队列原理是什么？有什么优势？</h3>
<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，比如多种分布式锁的实现、延时队列。</p>
<p>我们可以借助 Redisson 内置的延时队列 RDelayedQueue 来实现延时任务功能。</p>
<p>Redisson 的延迟队列 RDelayedQueue 是基于 Redis 的 SortedSet 来实现的。SortedSet 是一个有序集合，其中的每个元素都可以设置一个分数，代表该元素的权重。Redisson 利用这一特性，将需要延迟执行的任务插入到 SortedSet 中，并给它们设置相应的过期时间作为分数。</p>
<p>Redisson 使用 <code>zrangebyscore</code> 命令扫描 SortedSet 中过期的元素，然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被监听到。这样做可以避免对整个 SortedSet 进行轮询，提高了执行效率。</p>
<p>相比于 Redis 过期事件监听实现延时任务功能，这种方式具备下面这些优势：</p>
<ol>
<li><strong>减少了丢消息的可能</strong>：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</li>
<li><strong>消息不存在重复消费问题</strong>：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。</li>
</ol>
<p>跟 Redisson 内置的延时队列相比，消息队列可以通过保障消息消费的可靠性、控制消息生产者和消费者的数量等手段来实现更高的吞吐量和更强的可靠性，实际项目中首选使用消息队列的延时消息这种方案。</p>
]]></content>
    <category term="数据库"/>
    <published>2024-03-23T02:55:07.000Z</published>
  </entry>
  <entry>
    <title type="text">Redis为什么用跳表实现有序集合</title>
    <id>https://javaguide.cn/learning/database/redis/redis-skiplist.html</id>
    <link href="https://javaguide.cn/learning/database/redis/redis-skiplist.html"/>
    <updated>2024-03-22T17:53:48.000Z</updated>
    <summary type="html"><![CDATA[<h2>前言</h2>
<p>近几年针对 Redis 面试时会涉及常见数据结构的底层设计，其中就有这么一道比较有意思的面试题：“Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？”。</p>
<p>本文就以这道大厂常问的面试题为切入点，带大家详细了解一下跳表这个数据结构。</p>
<p>本文整体脉络如下图所示，笔者会从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005468.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<h2>前言</h2>
<p>近几年针对 Redis 面试时会涉及常见数据结构的底层设计，其中就有这么一道比较有意思的面试题：“Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？”。</p>
<p>本文就以这道大厂常问的面试题为切入点，带大家详细了解一下跳表这个数据结构。</p>
<p>本文整体脉络如下图所示，笔者会从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005468.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2>跳表在 Redis 中的运用</h2>
<p>这里我们需要先了解一下 Redis 用到跳表的数据结构有序集合的使用，Redis 有个比较常用的数据结构叫<strong>有序集合(sorted set，简称 zset)</strong>，正如其名它是一个可以保证有序且元素唯一的集合，所以它经常用于排行榜等需要进行统计排列的场景。</p>
<p>这里我们通过命令行的形式演示一下排行榜的实现，可以看到笔者分别输入 3 名用户：<strong>xiaoming</strong>、<strong>xiaohong</strong>、<strong>xiaowang</strong>，它们的<strong>score</strong>分别是 60、80、60，最终按照成绩升级降序排列。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd rankList <span class="token number">60</span> xiaoming
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd rankList <span class="token number">80</span> xiaohong
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd rankList <span class="token number">60</span> xiaowang
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># 返回有序集中指定区间内的成员，通过索引，分数从高到低</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ZREVRANGE rankList <span class="token number">0</span> <span class="token number">100</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"xiaohong"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"80"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"xiaowang"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"xiaoming"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
</code></pre></div><p>此时我们通过 <code>object</code> 指令查看 zset 的数据结构，可以看到当前有序集合存储的还是是<strong>ziplist(压缩列表)</strong>。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding rankList
<span class="token string">"ziplist"</span>
</code></pre></div><p>因为设计者考虑到 Redis 数据存放于内存，为了节约宝贵的内存空间在有序集合在元素小于 64 字节且个数小于 128 的时候，会使用 ziplist，而这个阈值的默认值的设置就来自下面这两个配置项。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>zset-max-ziplist-value <span class="token number">64</span>
zset-max-ziplist-entries <span class="token number">128</span>
</code></pre></div><p>一旦有序集合中的某个元素超出这两个其中的一个阈值它就会转为 <strong>skiplist</strong>（实际是 dict+skiplist，还会借用字典来提高获取指定元素的效率）。</p>
<p>我们不妨在添加一个大于 64 字节的元素，可以看到有序集合的底层存储转为 skiplist。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd rankList <span class="token number">90</span> yigemingzihuichaoguo64zijiedeyonghumingchengyongyuceshitiaobiaodeshijiyunyong
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token comment"># 超过阈值，转为跳表</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding rankList
<span class="token string">"skiplist"</span>
</code></pre></div><p>也就是说，ZSet 有两种不同的实现，分别是 ziplist 和 skiplist，具体使用哪种结构进行存储的规则如下：</p>
<ul>
<li>当有序集合对象同时满足以下两个条件时，使用 ziplist：
<ol>
<li>ZSet 保存的键值对数量少于 128 个；</li>
<li>每个元素的长度小于 64 字节。</li>
</ol>
</li>
<li>如果不满足上述两个条件，那么使用 skiplist 。</li>
</ul>
<h2>手写一个跳表</h2>
<p>为了更好的回答上述问题以及更好的理解和掌握跳表，这里可以通过手写一个简单的跳表的形式来帮助读者理解跳表这个数据结构。</p>
<p>我们都知道有序链表在添加、查询、删除的平均时间复杂都都是<strong>O(n)<strong>即线性增长，所以一旦节点数量达到一定体量后其性能表现就会非常差劲。而跳表我们完全可以理解为在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为</strong>O(log n)</strong>。</p>
<p>可能这里说的有些抽象，我们举个例子，以下图跳表为例，其原始链表存储按序存储 1-10，有 2 级索引，每级索引的索引个数都是基于下层元素个数的一半。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005436.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>假如我们需要查询元素 6，其工作流程如下：</p>
<ol>
<li>从 2 级索引开始，先来到节点 4。</li>
<li>查看 4 的后继节点，是 8 的 2 级索引，这个值大于 6，说明 2 级索引后续的索引都是大于 6 的，没有再往后搜寻的必要，我们索引向下查找。</li>
<li>来到 4 的 1 级索引，比对其后继节点为 6，查找结束。</li>
</ol>
<p>相较于原始有序链表需要 6 次，我们的跳表通过建立多级索引，我们只需两次就直接定位到了目标元素，其查寻的复杂度被直接优化为<strong>O(log n)</strong>。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005524.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>对应的添加也是一个道理，假如我们需要在这个有序集合中添加一个元素 7，那么我们就需要通过跳表找到<strong>小于元素 7 的最大值</strong>，也就是下图元素 6 的位置，将其插入到元素 6 的后面，让元素 6 的索引指向新插入的节点 7，其工作流程如下：</p>
<ol>
<li>从 2 级索引开始定位到了元素 4 的索引。</li>
<li>查看索引 4 的后继索引为 8，索引向下推进。</li>
<li>来到 1 级索引，发现索引 4 后继索引为 6，小于插入元素 7，指针推进到索引 6 位置。</li>
<li>继续比较 6 的后继节点为索引 8，大于元素 7，索引继续向下。</li>
<li>最终我们来到 6 的原始节点，发现其后继节点为 7，指针没有继续向下的空间，自此我们可知元素 6 就是小于插入元素 7 的最大值，于是便将元素 7 插入。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005480.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这里我们又面临一个问题，我们是否需要为元素 7 建立索引，索引多高合适？</p>
<p>我们上文提到，理想情况是每一层索引是下一层元素个数的二分之一，假设我们的总共有 16 个元素，对应各级索引元素个数应该是：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">1</span>. 一级索引:16/2<span class="token operator">=</span><span class="token number">8</span>
<span class="token number">2</span>. 二级索引:8/2 <span class="token operator">=</span><span class="token number">4</span>
<span class="token number">3</span>. 三级索引:4/2<span class="token operator">=</span><span class="token number">2</span>
</code></pre></div><p>由此我们用数学归纳法可知：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">1</span>. 一级索引:16/2<span class="token operator">=</span><span class="token number">16</span>/2^1<span class="token operator">=</span><span class="token number">8</span>
<span class="token number">2</span>. 二级索引:8/2 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">16</span>/2^2 <span class="token operator">=</span><span class="token number">4</span>
<span class="token number">3</span>. 三级索引:4/2<span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">16</span>/2^3<span class="token operator">=</span><span class="token number">2</span>
</code></pre></div><p>假设元素个数为 n，那么对应 k 层索引的元素个数 r 计算公式为:</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token assign-left variable">r</span><span class="token operator">=</span>n/2^k
</code></pre></div><p>同理我们再来推断以下索引的最大高度，一般来说最高级索引的元素个数为 2，我们设元素总个数为 n，索引高度为 h，代入上述公式可得：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token assign-left variable">2</span><span class="token operator">=</span> n/2^h
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span>*2^h<span class="token operator">=</span>n
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token number">2</span>^<span class="token punctuation">(</span>h+1<span class="token punctuation">)</span><span class="token operator">=</span>n
<span class="token operator">=</span><span class="token operator">&gt;</span> h+1<span class="token operator">=</span>log2^n
<span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token assign-left variable">h</span><span class="token operator">=</span>log2^n <span class="token parameter variable">-1</span>
</code></pre></div><p>而 Redis 又是内存数据库，我们假设元素最大个数是<strong>65536</strong>，我们把<strong>65536</strong>代入上述公式可知最大高度为 16。所以我们建议添加一个元素后为其建立的索引高度不超过 16。</p>
<p>因为我们要求尽可能保证每一个上级索引都是下级索引的一半，在实现高度生成算法时，我们可以这样设计：</p>
<ol>
<li>跳表的高度计算从原始链表开始，即默认情况下插入的元素的高度为 1，代表没有索引，只有元素节点。</li>
<li>设计一个为插入元素生成节点索引高度 level 的方法。</li>
<li>进行一次随机运算，随机数值范围为 0-1 之间。</li>
<li>如果随机数大于 0.5 则为当前元素添加一级索引，自此我们保证生成一级索引的概率为<strong>50%</strong>，这也就保证了 1 级索引理想情况下只有一半的元素会生成索引。</li>
<li>同理后续每次随机算法得到的值大于 0.5 时，我们的索引高度就加 1，这样就可以保证节点生成的 2 级索引概率为<strong>25%</strong>，3 级索引为<strong>12.5%</strong>……</li>
</ol>
<p>我们回过头，上述插入 7 之后，我们通过随机算法得到 2，即要为其建立 1 级索引：</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005505.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>最后我们再来说说删除，假设我们这里要删除元素 10，我们必须定位到当前跳表<strong>各层</strong>元素小于 10 的最大值，索引执行步骤为：</p>
<ol>
<li>2 级索引 4 的后继节点为 8，指针推进。</li>
<li>索引 8 无后继节点，该层无要删除的元素，指针直接向下。</li>
<li>1 级索引 8 后继节点为 10，说明 1 级索引 8 在进行删除时需要将自己的指针和 1 级索引 10 断开联系，将 10 删除。</li>
<li>1 级索引完成定位后，指针向下，后继节点为 9，指针推进。</li>
<li>9 的后继节点为 10，同理需要让其指向 null，将 10 删除。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005503.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3>模板定义</h3>
<p>有了整体的思路之后，我们可以开始实现一个跳表了，首先定义一下跳表中的节点<strong>Node</strong>，从上文的演示中可以看出每一个<strong>Node</strong>它都包含以下几个元素：</p>
<ol>
<li>存储的<strong>value</strong>值。</li>
<li>后继节点的地址。</li>
<li>多级索引。</li>
</ol>
<p>为了更方便统一管理<strong>Node</strong>后继节点地址和多级索引指向的元素地址，笔者在<strong>Node</strong>中设置了一个<strong>forwards</strong>数组，用于记录原始链表节点的后继节点和多级索引的后继节点指向。</p>
<p>以下图为例，我们<strong>forwards</strong>数组长度为 5，其中<strong>索引 0</strong>记录的是原始链表节点的后继节点地址，而其余自底向上表示从 1 级索引到 4 级索引的后继节点指向。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005347.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>于是我们的就有了这样一个代码定义，可以看出笔者对于数组的长度设置为固定的 16**(上文的推算最大高度建议是 16)<strong>，默认</strong>data<strong>为-1，节点最大高度</strong>maxLevel<strong>初始化为 1，注意这个</strong>maxLevel**的值代表原始链表加上索引的总高度。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 跳表索引最大高度为16
 */</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_LEVEL</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> forwards <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token constant">MAX_LEVEL</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h3>元素添加</h3>
<p>定义好节点之后，我们先实现以下元素的添加，添加元素时首先自然是设置<strong>data</strong>这一步我们直接根据将传入的<strong>value</strong>设置到<strong>data</strong>上即可。</p>
<p>然后就是高度<strong>maxLevel</strong>的设置 ，我们在上文也已经给出了思路，默认高度为 1，即只有一个原始链表节点，通过随机算法每次大于 0.5 索引高度加 1，由此我们得出高度计算的算法<code>randomLevel()</code>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。
 * 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。
 * 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：
 * 50%的概率返回 1
 * 25%的概率返回 2
 *  12.5%的概率返回 3 ...
 * <span class="token keyword">@return</span>
 */</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">PROB</span> <span class="token operator">&amp;&amp;</span> level <span class="token operator">&lt;</span> <span class="token constant">MAX_LEVEL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>level<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后再设置当前要插入的<strong>Node</strong>和<strong>Node</strong>索引的后继节点地址，这一步稍微复杂一点，我们假设当前节点的高度为 4，即 1 个节点加 3 个索引，所以我们创建一个长度为 4 的数组<strong>maxOfMinArr</strong> ，遍历各级索引节点中小于当前<strong>value</strong>的最大值。</p>
<p>假设我们要插入的<strong>value</strong>为 5，我们的数组查找结果当前节点的前驱节点和 1 级索引、2 级索引的前驱节点都为 4，三级索引为空。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005299.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>然后我们基于这个数组<strong>maxOfMinArr</strong> 定位到各级的后继节点，让插入的元素 5 指向这些后继节点，而<strong>maxOfMinArr</strong>指向 5，结果如下图：</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005369.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>转化成代码就是下面这个形式，是不是很简单呢？我们继续：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 默认情况下的高度为1，即只有自己一个节点
 */</span>
<span class="token keyword">private</span> <span class="token keyword">int</span> levelCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 跳表最底层的节点，即头节点
 */</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">//随机生成高度</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token punctuation">.</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
    newNode<span class="token punctuation">.</span>maxLevel <span class="token operator">=</span> level<span class="token punctuation">;</span>

    <span class="token comment">//创建一个node数组，用于记录小于当前value的最大值</span>
    <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxOfMinArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//默认情况下指向头节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//基于上述结果拿到当前节点的后继节点</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//更新前驱节点的后继节点为当前节点newNode</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        newNode<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//如果当前newNode高度大于跳表最高高度则更新levelCount</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>levelCount <span class="token operator">&lt;</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        levelCount <span class="token operator">=</span> level<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h3>元素查询</h3>
<p>查询逻辑比较简单，从跳表最高级的索引开始定位找到小于要查的 value 的最大值，以下图为例，我们希望查找到节点 8：</p>
<ol>
<li>跳表的 3 级索引首先找找到 5 的索引，5 的 3 级索引**forwards[3]**指向空，索引直接向下。</li>
<li>来到 5 的 2 级索引，其后继**forwards[2]**指向 8，继续向下。</li>
<li>5 的 1 级索引**forwards[1]**指向索引 6，继续向前。</li>
<li>索引 6 的**forwards[1]**指向索引 8，继续向下。</li>
<li>我们在原始节点向前找到节点 7。</li>
<li>节点 7 后续就是节点 8，继续向前为节点 8，无法继续向下，结束搜寻。</li>
<li>判断 7 的前驱，等于 8，查找结束。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005323.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>所以我们的代码实现也很上述步骤差不多，从最高级索引开始向前查找，如果不为空且小于要查找的值，则继续向前搜寻，遇到不小于的节点则继续向下，如此往复，直到得到当前跳表中小于查找值的最大节点，查看其前驱是否等于要查找的值：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token comment">//找到小于value的最大值</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果p的前驱节点等于value则直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>元素删除</h3>
<p>最后是删除逻辑，需要查找各层级小于要删除节点的最大值，假设我们要删除 10：</p>
<ol>
<li>3 级索引得到小于 10 的最大值为 5，继续向下。</li>
<li>2 级索引从索引 5 开始查找，发现小于 10 的最大值为 8，继续向下。</li>
<li>同理 1 级索引得到 8，继续向下。</li>
<li>原始节点找到 9。</li>
<li>从最高级索引开始，查看每个小于 10 的节点后继节点是否为 10，如果等于 10，则让这个节点指向 10 的后继节点，将节点 10 及其索引交由 GC 回收。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005350.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 删除
 *
 * <span class="token keyword">@param</span> <span class="token parameter">value</span>
 */</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
    <span class="token comment">//找到各级节点小于value的最大值</span>
    <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> updateArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>levelCount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//查看原始层节点前驱是否等于value，若等于则说明存在要删除的值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//从最高级索引开始查看其前驱是否等于value，若等于则将当前节点指向value节点的后继节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//从最高级开始查看是否有一级索引为空，若为空则层级减1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>levelCount <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        levelCount<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h3>完整代码以及测试</h3>
<p>完整代码如下，读者可自行参阅:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SkipList</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * 跳表索引最大高度为16
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_LEVEL</span> <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 每个节点添加一层索引高度的概率为二分之一
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">PROB</span> <span class="token operator">=</span> <span class="token number">0.5</span> f<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 默认情况下的高度为1，即只有自己一个节点
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> levelCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 跳表最底层的节点，即头节点
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span> h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token doc-comment comment">/**
         *
         */</span>
        <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> forwards <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token constant">MAX_LEVEL</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> maxLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">"Node{"</span> <span class="token operator">+</span>
                <span class="token string">"data="</span> <span class="token operator">+</span> data <span class="token operator">+</span>
                <span class="token string">", maxLevel="</span> <span class="token operator">+</span> maxLevel <span class="token operator">+</span>
                <span class="token char">'}'</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">//随机生成高度</span>
        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        newNode<span class="token punctuation">.</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
        newNode<span class="token punctuation">.</span>maxLevel <span class="token operator">=</span> level<span class="token punctuation">;</span>

        <span class="token comment">//创建一个node数组，用于记录小于当前value的最大值</span>
        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> maxOfMinArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//默认情况下指向头节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//基于上述结果拿到当前节点的后继节点</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//更新前驱节点的后继节点为当前节点newNode</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            newNode<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            maxOfMinArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//如果当前newNode高度大于跳表最高高度则更新levelCount</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>levelCount <span class="token operator">&lt;</span> level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            levelCount <span class="token operator">=</span> level<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。
     * 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。
     * 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：
     * 50%的概率返回 1
     * 25%的概率返回 2
     *  12.5%的概率返回 3 ...
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">PROB</span> <span class="token operator">&amp;&amp;</span> level <span class="token operator">&lt;</span> <span class="token constant">MAX_LEVEL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>level<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> level<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token comment">//找到小于value的最大值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//如果p的前驱节点等于value则直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 删除
     *
     * <span class="token keyword">@param</span> <span class="token parameter">value</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token comment">//找到各级节点小于value的最大值</span>
        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> updateArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>levelCount<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//查看原始层节点前驱是否等于value，若等于则说明存在要删除的值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//从最高级索引开始查看其前驱是否等于value，若等于则将当前节点指向value节点的后继节点</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> updateArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//从最高级开始查看是否有一级索引为空，若为空则层级减1</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>levelCount <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            levelCount<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> p <span class="token operator">=</span> h<span class="token punctuation">;</span>
        <span class="token comment">//基于最底层的非索引层进行遍历，只要后继节点不为空，则速速出当前节点，并移动到后继节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>对应测试代码和输出结果如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SkipList</span> skipList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">24</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            skipList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********输出添加结果**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">SkipList<span class="token punctuation">.</span>Node</span> node <span class="token operator">=</span> skipList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********查询结果:"</span> <span class="token operator">+</span> node<span class="token operator">+</span><span class="token string">" **********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        skipList<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**********删除结果**********"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        skipList<span class="token punctuation">.</span><span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">}</span>
</code></pre></div><p>输出结果:</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>**********输出添加结果**********
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">3</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">5</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">6</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">7</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">9</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">10</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">11</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">12</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">13</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">14</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">15</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">16</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">17</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">18</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">19</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">20</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">21</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">22</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">23</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
**********查询结果:Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">22</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span> **********
**********删除结果**********
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">0</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">1</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">2</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">3</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">4</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">5</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">6</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">7</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">8</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">9</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">10</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">11</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">12</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">13</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">14</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">15</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">16</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">17</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">18</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">19</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">20</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">21</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">}</span>
Node<span class="token punctuation">{</span>data<span class="token operator">=</span><span class="token number">23</span>, <span class="token assign-left variable">maxLevel</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
</code></pre></div><h2>和其余三种数据结构的比较</h2>
<p>最后，我们再来回答一下文章开头的那道面试题: “Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？”。</p>
<h3>平衡树 vs 跳表</h3>
<p>先来说说它和平衡树的比较，平衡树我们又会称之为 <strong>AVL 树</strong>，是一个严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过 1，即平衡因子为范围为 <code>[-1,1]</code>）。平衡树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong>。</p>
<p>对于范围查询来说，它也可以通过中序遍历的方式达到和跳表一样的效果。但是它的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005312.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>跳表诞生的初衷就是为了克服平衡树的一些缺点，跳表的发明者在论文<a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf" target="_blank" rel="noopener noreferrer">《Skip lists: a probabilistic alternative to balanced trees》</a>中有详细提到：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/database/redis/skiplist-a-probabilistic-alternative-to-balanced-trees.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<blockquote>
<p>Skip lists are a data structure that can be used in place of balanced trees. Skip lists use probabilistic balancing rather than strictly enforced balancing and as a result the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.</p>
<p>跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</p>
</blockquote>
<p>笔者这里也贴出了 AVL 树插入操作的核心代码，可以看出每一次添加操作都需要进行一次递归定位插入位置，然后还需要根据回溯到根节点检查沿途的各层节点是否失衡，再通过旋转节点的方式进行调整。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 向二分搜索树中添加新的元素(key, value)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    root <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 向以node为根的二分搜索树中插入元素(key, value)，递归算法</span>
<span class="token comment">// 返回插入新节点后二分搜索树的根</span>
<span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token comment">// key.compareTo(node.key) == 0</span>
        node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>

    node<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> balanceFactor <span class="token operator">=</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// LL型需要右旋</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//RR型失衡需要左旋</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//LR需要先左旋成LL型，然后再右旋</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//RL</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>红黑树 vs 跳表</h3>
<p>红黑树（Red Black Tree）也是一种自平衡二叉查找树，它的查询性能略微逊色于 AVL 树，但插入和删除效率更高。红黑树的插入、删除和查询的时间复杂度和跳表一样都是 <strong>O(log n)</strong>。</p>
<p>红黑树是一个<strong>黑平衡树</strong>，即从任意节点到另外一个叶子叶子节点，它所经过的黑节点是一样的。当对它进行插入操作时，需要通过旋转和染色（红黑变换）来保证黑平衡。不过，相较于 AVL 树为了维持平衡的开销要小一些。关于红黑树的详细介绍，可以查看这篇文章：<a href="https://javaguide.cn/cs-basics/data-structure/red-black-tree.html" target="_blank" rel="noopener noreferrer">红黑树</a>。</p>
<p>相比较于红黑树来说，跳表的实现也更简单一些。并且，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005709.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>对应红黑树添加的核心代码如下，读者可自行参阅理解：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> node<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//左节点不为红，右节点为红，左旋</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node <span class="token operator">=</span> <span class="token function">leftRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//左链右旋</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node <span class="token operator">=</span> <span class="token function">rightRotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//颜色翻转</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">flipColors</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>B+树 vs 跳表</h3>
<p>想必使用 MySQL 的读者都知道 B+树这个数据结构，B+树是一种常用的数据结构，具有以下特点：</p>
<ol>
<li><strong>多叉树结构</strong>：它是一棵多叉树，每个节点可以包含多个子节点，减小了树的高度，查询效率高。</li>
<li><strong>存储效率高</strong>:其中非叶子节点存储多个 key，叶子节点存储 value，使得每个节点更够存储更多的键，根据索引进行范围查询时查询效率更高。-</li>
<li><strong>平衡性</strong>：它是绝对的平衡，即树的各个分支高度相差不大，确保查询和插入时间复杂度为<strong>O(log n)</strong>。</li>
<li><strong>顺序访问</strong>：叶子节点间通过链表指针相连，范围查询表现出色。</li>
<li><strong>数据均匀分布</strong>：B+树插入时可能会导致数据重新分布，使得数据在整棵树分布更加均匀，保证范围查询和删除效率。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005649.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>所以，B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
<h3>Redis 作者给出的理由</h3>
<p>当然我们也可以通过 Redis 的作者自己给出的理由:</p>
<blockquote>
<p>There are a few reasons:<br>
1、They are not very memory intensive. It's up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.<br>
2、A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.<br>
3、They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p>
</blockquote>
<p>翻译过来的意思就是:</p>
<blockquote>
<p>有几个原因：</p>
<p>1、它们不是很占用内存。这主要取决于你。改变节点拥有给定层数的概率的参数，会使它们比 B 树更节省内存。</p>
<p>2、有序集合经常是许多 ZRANGE 或 ZREVRANGE 操作的目标，也就是说，以链表的方式遍历跳表。通过这种操作，跳表的缓存局部性至少和其他类型的平衡树一样好。</p>
<p>3、它们更容易实现、调试等等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis 主分支中），用增强的跳表实现了 O(log(N))的 ZRANK。它只需要对代码做很少的修改。</p>
</blockquote>
<h2>小结</h2>
<p>本文通过大量篇幅介绍跳表的工作原理和实现，帮助读者更进一步的熟悉跳表这一数据结构的优劣，最后再结合各个数据结构操作的特点进行比对，从而帮助读者更好的理解这道面试题，建议读者实现理解跳表时，尽可能配合执笔模拟来了解跳表的增删改查详细过程。</p>
<h2>参考</h2>
<ul>
<li>为啥 redis 使用跳表(skiplist)而不是使用 red-black？:<a href="https://www.zhihu.com/question/20202931/answer/16086538" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/20202931/answer/16086538</a></li>
<li>Skip List--跳表（全网最详细的跳表文章没有之一）:<a href="https://www.jianshu.com/p/9d8296562806" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9d8296562806</a></li>
<li>Redis 对象与底层数据结构详解:<a href="https://blog.csdn.net/shark_chili3007/article/details/104171986" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/shark_chili3007/article/details/104171986</a></li>
<li>Redis 有序集合(sorted set):<a href="https://www.runoob.com/redis/redis-sorted-sets.html" target="_blank" rel="noopener noreferrer">https://www.runoob.com/redis/redis-sorted-sets.html</a></li>
<li>红黑树和跳表比较:<a href="https://zhuanlan.zhihu.com/p/576984787" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/576984787</a></li>
<li>为什么 redis 的 zset 用跳跃表而不用 b+ tree？:<a href="https://blog.csdn.net/f80407515/article/details/129136998" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/f80407515/article/details/129136998</a></li>
</ul>
]]></content>
    <category term="数据库"/>
    <published>2024-01-29T16:10:36.000Z</published>
  </entry>
  <entry>
    <title type="text">访问网页的全过程（知识串联）</title>
    <id>https://javaguide.cn/learning/cs-basics/network/the-whole-process-of-accessing-web-pages.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/the-whole-process-of-accessing-web-pages.html"/>
    <updated>2024-01-31T11:49:55.000Z</updated>
    <summary type="html"><![CDATA[<p>开发岗中总是会考很多计算机网络的知识点，但如果让面试官只靠一道题，便涵盖最多的计网知识点，那可能就是 <strong>网页浏览的全过程</strong> 了。本篇文章将带大家从头到尾过一遍这道被考烂的面试题，必会！！！</p>
<p>总的来说，网络通信模型可以用下图来表示，也就是大家只要熟记网络结构五层模型，按照这个体系，很多知识点都能顺出来了。访问网页的过程也是如此。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/five-layers.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>开发岗中总是会考很多计算机网络的知识点，但如果让面试官只靠一道题，便涵盖最多的计网知识点，那可能就是 <strong>网页浏览的全过程</strong> 了。本篇文章将带大家从头到尾过一遍这道被考烂的面试题，必会！！！</p>
<p>总的来说，网络通信模型可以用下图来表示，也就是大家只要熟记网络结构五层模型，按照这个体系，很多知识点都能顺出来了。访问网页的过程也是如此。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/five-layers.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>开始之前，我们先简单过一遍完整流程：</p>
<ol>
<li>在浏览器中输入指定网页的 URL。</li>
<li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li>
<li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li>
<li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li>
<li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li>
<li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li>
<li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li>
</ol>
<h2>应用层</h2>
<p>一切的开始——打开浏览器，在地址栏输入 URL，回车确认。那么，什么是 URL？访问 URL 有什么用？</p>
<h3>URL</h3>
<p>URL（Uniform Resource Locators），即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。理论上，文件资源和 URL 一一对应。实际上也有例外，比如某些 URL 指向的文件已经被重定位到另一个位置，这样就有多个 URL 指向同一个文件。</p>
<h3>URL 的组成结构</h3>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/URL-parts.png" alt="URL的组成结构" tabindex="0"><figcaption>URL的组成结构</figcaption></figure>
<ol>
<li>协议。URL 的前缀通常表示了该网址采用了何种应用层协议，通常有两种——HTTP 和 HTTPS。当然也有一些不太常见的前缀头，比如文件传输时用到的<code>ftp:</code>。</li>
<li>域名。域名便是访问网址的通用名，这里也有可能是网址的 IP 地址，域名可以理解为 IP 地址的可读版本，毕竟绝大部分人都不会选择记住一个网址的 IP 地址。</li>
<li>端口。如果指明了访问网址的端口的话，端口会紧跟在域名后面，并用一个冒号隔开。</li>
<li>资源路径。域名（端口）后紧跟的就是资源路径，从第一个<code>/</code>开始，表示从服务器上根目录开始进行索引到的文件路径，上图中要访问的文件就是服务器根目录下<code>/path/to/myfile.html</code>。早先的设计是该文件通常物理存储于服务器主机上，但现在随着网络技术的进步，该文件不一定会物理存储在服务器主机上，有可能存放在云上，而文件路径也有可能是虚拟的（遵循某种规则）。</li>
<li>参数。参数是浏览器在向服务器提交请求时，在 URL 中附带的参数。服务器解析请求时，会提取这些参数。参数采用键值对的形式<code>key=value</code>，每一个键值对使用<code>&amp;</code>隔开。参数的具体含义和请求操作的具体方法有关。</li>
<li>锚点。锚点顾名思义，是在要访问的页面上的一个锚。要访问的页面大部分都多于一页，如果指定了锚点，那么在客户端显示该网页是就会定位到锚点处，相当于一个小书签。值得一提的是，在 URL 中，锚点以<code>#</code>开头，并且<strong>不会</strong>作为请求的一部分发送给服务端。</li>
</ol>
<h3>DNS</h3>
<p>键入了 URL 之后，第一个重头戏登场——DNS 服务器解析。DNS（Domain Name System）域名系统，要解决的是 <strong>域名和 IP 地址的映射问题</strong> 。毕竟，域名只是一个网址便于记住的名字，而网址真正存在的地址其实是 IP 地址。</p>
<p>传送门：<a href="https://javaguide.cn/cs-basics/network/dns.html" target="_blank" rel="noopener noreferrer">DNS 域名系统详解（应用层）</a></p>
<h3>HTTP/HTTPS</h3>
<p>利用 DNS 拿到了目标主机的 IP 地址之后，浏览器便可以向目标 IP 地址发送 HTTP 报文，请求需要的资源了。在这里，根据目标网站的不同，请求报文可能是 HTTP 协议或安全性增强的 HTTPS 协议。</p>
<p>传送门：</p>
<ul>
<li><a href="https://javaguide.cn/cs-basics/network/http-vs-https.html" target="_blank" rel="noopener noreferrer">HTTP vs HTTPS（应用层）</a></li>
<li><a href="https://javaguide.cn/cs-basics/network/http1.0-vs-http1.1.html" target="_blank" rel="noopener noreferrer">HTTP 1.0 vs HTTP 1.1（应用层）</a></li>
<li><a href="https://javaguide.cn/cs-basics/network/http-status-codes.html" target="_blank" rel="noopener noreferrer">HTTP 常见状态码总结（应用层）</a></li>
</ul>
<h2>传输层</h2>
<p>由于 HTTP 协议是基于 TCP 协议的，在应用层的数据封装好以后，要交给传输层，经 TCP 协议继续封装。</p>
<p>TCP 协议保证了数据传输的可靠性，是数据包传输的主力协议。</p>
<p>传送门：</p>
<ul>
<li><a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html" target="_blank" rel="noopener noreferrer">TCP 三次握手和四次挥手（传输层）</a></li>
<li><a href="https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html" target="_blank" rel="noopener noreferrer">TCP 传输可靠性保障（传输层）</a></li>
</ul>
<h2>网络层</h2>
<p>终于，来到网络层，此时我们的主机不再是和另一台主机进行交互了，而是在和中间系统进行交互。也就是说，应用层和传输层都是端到端的协议，而网络层及以下都是中间件的协议了。</p>
<p><strong>网络层的的核心功能——转发与路由</strong>，必会！！！如果面试官问到了网络层，而你恰好又什么都不会的话，最最起码要说出这五个字——<strong>转发与路由</strong>。</p>
<ul>
<li>转发：将分组从路由器的输入端口转移到合适的输出端口。</li>
<li>路由：确定分组从源到目的经过的路径。</li>
</ul>
<p>所以到目前为止，我们的数据包经过了应用层、传输层的封装，来到了网络层，终于开始准备在物理层面传输了，第一个要解决的问题就是——**往哪里传输？或者说，要把数据包发到哪个路由器上？**这便是 BGP 协议要解决的问题。</p>
]]></content>
    <category term="计算机基础"/>
    <published>2024-01-29T14:06:19.000Z</published>
  </entry>
  <entry>
    <title type="text">数据冷热分离详解</title>
    <id>https://javaguide.cn/learning/high-performance/data-cold-hot-separation.html</id>
    <link href="https://javaguide.cn/learning/high-performance/data-cold-hot-separation.html"/>
    <updated>2024-03-06T11:10:40.000Z</updated>
    <summary type="html"><![CDATA[<h2>什么是数据冷热分离？</h2>
<p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>
<h3>冷数据和热数据</h3>
<p>热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</p>
<p>冷热数据到底如何区分呢？有两个常见的区分方法：</p>
<ol>
<li><strong>时间维度区分</strong>：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li>
<li><strong>访问频率区分</strong>：将高频访问的数据视为热数据，低频访问的数据视为冷数据。例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>什么是数据冷热分离？</h2>
<p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。</p>
<h3>冷数据和热数据</h3>
<p>热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。</p>
<p>冷热数据到底如何区分呢？有两个常见的区分方法：</p>
<ol>
<li><strong>时间维度区分</strong>：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</li>
<li><strong>访问频率区分</strong>：将高频访问的数据视为热数据，低频访问的数据视为冷数据。例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</li>
</ol>
<p>几年前的数据并不一定都是热数据，例如一些优质文章发表几年后依然有很多人访问，大部分普通用户新发表的文章却基本没什么人访问。</p>
<p>这两种区分冷热数据的方法各有优劣，实际项目中，可以将两者结合使用。</p>
<h3>冷热分离的思想</h3>
<p>冷热分离的思想非常简单，就是对数据进行分类，然后分开存储。冷热分离的思想可以应用到很多领域和场景中，而不仅仅是数据存储，例如：</p>
<ul>
<li>邮件系统中，可以将近期的比较重要的邮件放在收件箱，将比较久远的不太重要的邮件存入归档。</li>
<li>日常生活中，可以将常用的物品放在显眼的位置，不常用的物品放入储藏室或者阁楼。</li>
<li>图书馆中，可以将最受欢迎和最常借阅的图书单独放在一个显眼的区域，将较少借阅的书籍放在不起眼的位置。</li>
<li>……</li>
</ul>
<h3>数据冷热分离的优缺点</h3>
<ul>
<li>优点：热数据的查询性能得到优化（用户的绝大部分操作体验会更好）、节约成本（可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上）</li>
<li>缺点：系统复杂性和风险增加（需要分离冷热数据，数据错误的风险增加）、统计效率低（统计的时候可能需要用到冷库的数据）。</li>
</ul>
<h2>冷数据如何迁移？</h2>
<p>冷数据迁移方案：</p>
<ol>
<li>业务层代码实现：当有对数据进行写操作时，触发冷热分离的逻辑，判断数据是冷数据还是热数据，冷数据就入冷库，热数据就入热库。这种方案会影响性能且冷热数据的判断逻辑不太好确定，还需要修改业务层代码，因此一般不会使用。</li>
<li>任务调度：可以利用 xxl-job 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。</li>
<li>监听数据库的变更日志 binlog ：将满足冷数据条件的数据从 binlog 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。</li>
</ol>
<p>如果你的公司有 DBA 的话，也可以让 DBA 进行冷数据的人工迁移，一次迁移完成冷数据到冷库。然后，再搭配上面介绍的方案实现后续冷数据的迁移工作。</p>
<h2>冷数据如何存储？</h2>
<p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。</p>
<p>冷数据存储方案：</p>
<ul>
<li>中小厂：直接使用 MySQL/PostgreSQL 即可（不改变数据库选型和项目当前使用的数据库保持一致），比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据（涉及跨库查询，增加了系统复杂性和维护难度）</li>
<li>大厂：Hbase（常用）、RocksDB、Doris、Cassandra</li>
</ul>
<p>如果公司成本预算足的话，也可以直接上 TiDB 这种分布式关系型数据库，直接一步到位。TiDB 6.0 正式支持数据冷热存储分离，可以降低 SSD 使用成本。使用 TiDB 6.0 的数据放置功能，可以在同一个集群实现海量数据的冷热存储，将新的热数据存入 SSD，历史冷数据存入 HDD。</p>
<h2>案例分享</h2>
<ul>
<li><a href="https://www.cnblogs.com/fulongyuanjushi/p/17910420.html" target="_blank" rel="noopener noreferrer">如何快速优化几千万数据量的订单表 - 程序员济癫 - 2023</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZKRkZP6rLHuTE1wvnqmAPQ" target="_blank" rel="noopener noreferrer">海量数据冷热分离方案与实践 - 字节跳动技术团队 - 2022</a></li>
</ul>
]]></content>
    <category term="高性能"/>
    <published>2024-01-23T00:35:14.000Z</published>
  </entry>
  <entry>
    <title type="text">深度分页介绍及优化建议</title>
    <id>https://javaguide.cn/learning/high-performance/deep-pagination-optimization.html</id>
    <link href="https://javaguide.cn/learning/high-performance/deep-pagination-optimization.html"/>
    <updated>2024-02-23T08:44:05.000Z</updated>
    <summary type="html"><![CDATA[<h2>深度分页介绍</h2>
<p>查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如：</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># MySQL 在无法利用索引的情况下跳过1000000条记录后，再获取10条记录</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">LIMIT</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span>
</code></pre></div>]]></summary>
    <content type="html"><![CDATA[<h2>深度分页介绍</h2>
<p>查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如：</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># MySQL 在无法利用索引的情况下跳过1000000条记录后，再获取10条记录</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">LIMIT</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span>
</code></pre></div><h2>深度分页优化建议</h2>
<p>这里以 MySQL 数据库为例介绍一下如何优化深度分页。</p>
<h3>范围查询</h3>
<p>当可以保证 ID 的连续性时，根据 ID 范围进行分页是比较好的解决方案：</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 查询指定 ID 范围的数据</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token operator">AND</span> id <span class="token operator">&lt;=</span> <span class="token number">100010</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id
<span class="token comment"># 也可以通过记录上次查询结果的最后一条记录的ID进行下一页的查询：</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;</span> <span class="token number">100000</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span>
</code></pre></div><p>这种优化方式限制比较大，且一般项目的 ID 也没办法保证完全连续。</p>
<h3>子查询</h3>
<p>我们先查询出 limit 第一个参数对应的主键值，再根据这个主键值再去过滤并 limit，这样效率会更快一些。</p>
<p>阿里巴巴《Java 开发手册》中也有对应的描述：</p>
<blockquote>
<p>利用延迟关联或者子查询优化超多分页场景。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/mysql/alibaba-java-development-handbook-paging.png" alt="" tabindex="0"><figcaption></figcaption></figure>
</blockquote>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 通过子查询来获取 id 的起始值，把 limit 1000000 的条件转移到子查询</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_order <span class="token keyword">WHERE</span> id <span class="token operator">&gt;=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>不过，子查询的结果会产生一张新表，会影响性能，应该尽量避免大量使用子查询。并且，这种方法只适用于 ID 是正序的。在复杂分页场景，往往需要通过过滤条件，筛选到符合条件的 ID，此时的 ID 是离散且不连续的。</p>
<p>当然，我们也可以利用子查询先去获取目标分页的 ID 集合，然后再根据 ID 集合获取内容，但这种写法非常繁琐，不如使用 INNER JOIN 延迟关联。</p>
<h3>延迟关联</h3>
<p>延迟关联的优化思路，跟子查询的优化思路其实是一样的：都是把条件转移到主键索引树，减少回表的次数。不同点是，延迟关联使用了 INNER JOIN（内连接） 包含子查询。</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> t_order t1
<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> t2
<span class="token keyword">ON</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre></div><p>除了使用 INNER JOIN 之外，还可以使用逗号连接子查询。</p>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> t_order t1<span class="token punctuation">,</span>
<span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t_order <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> t2
<span class="token keyword">WHERE</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre></div><h3>覆盖索引</h3>
<p>索引中已经包含了所有需要获取的字段的查询方式称为覆盖索引。</p>
<p><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 InnoDB 表进行索引的二次查询，也就是回表操作:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询（回表），减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>
</ul>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 如果只需要查询 id, code, type 这三列，可建立 code 和 type 的覆盖索引</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> code<span class="token punctuation">,</span> <span class="token keyword">type</span> <span class="token keyword">FROM</span> t_order
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> code
<span class="token keyword">LIMIT</span> <span class="token number">1000000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>不过，当查询的结果集占表的总行数的很大一部分时，可能就不会走索引了，自动转换为全表扫描。当然了，也可以通过 <code>FORCE INDEX</code> 来强制查询优化器走索引，但这种提升效果一般不明显。</p>
<h2>参考</h2>
<ul>
<li>聊聊如何解决 MySQL 深分页问题 - 捡田螺的小男孩：<a href="https://juejin.cn/post/7012016858379321358" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7012016858379321358</a></li>
<li>数据库深分页介绍及优化方案 - 京东零售技术：<a href="https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/ZEwGKvRCyvAgGlmeseAS7g</a></li>
<li>MySQL 深分页优化 - 得物技术：<a href="https://juejin.cn/post/6985478936683610149" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6985478936683610149</a></li>
</ul>
]]></content>
    <category term="高性能"/>
    <published>2024-01-17T08:14:51.000Z</published>
  </entry>
  <entry>
    <title type="text">美团三年，总结的10条血泪教训</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：作者用了很多生动的例子和故事展示了自己在美团的成长和感悟，看了之后受益颇多！</p>
<p><strong>内容概览</strong>：</p>
<p>本文的作者提出了以下十条建议，希望能对其他职场人有所启发和帮助：</p>
<ol>
<li>结构化思考与表达，提高个人影响力</li>
<li>忘掉职级，该怼就怼，推动事情往前走</li>
<li>用好平台资源，结识优秀的人，学习通识课</li>
<li>一切都是争取来的，不要等待机会，要主动寻求</li>
<li>关注商业，升维到老板思维，看清趋势，及时止损</li>
<li>培养数据思维，利用数据了解世界，指导决策</li>
<li>做一个好"销售"，无论是自己还是产品，都要学会展示和说服</li>
<li>少加班多运动，保持身心健康，提高工作效率</li>
<li>有随时可以离开的底气，不要被职场所困，借假修真，提升自己</li>
<li>只是一份工作，不要过分纠结，相信自己，走出去看看</li>
</ol>
<p><strong>原文地址</strong>：<a href="https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ</a></p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：作者用了很多生动的例子和故事展示了自己在美团的成长和感悟，看了之后受益颇多！</p>
<p><strong>内容概览</strong>：</p>
<p>本文的作者提出了以下十条建议，希望能对其他职场人有所启发和帮助：</p>
<ol>
<li>结构化思考与表达，提高个人影响力</li>
<li>忘掉职级，该怼就怼，推动事情往前走</li>
<li>用好平台资源，结识优秀的人，学习通识课</li>
<li>一切都是争取来的，不要等待机会，要主动寻求</li>
<li>关注商业，升维到老板思维，看清趋势，及时止损</li>
<li>培养数据思维，利用数据了解世界，指导决策</li>
<li>做一个好"销售"，无论是自己还是产品，都要学会展示和说服</li>
<li>少加班多运动，保持身心健康，提高工作效率</li>
<li>有随时可以离开的底气，不要被职场所困，借假修真，提升自己</li>
<li>只是一份工作，不要过分纠结，相信自己，走出去看看</li>
</ol>
<p><strong>原文地址</strong>：<a href="https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ</a></p>
</blockquote>
<p>在美团的三年多时光，如同一部悠长的交响曲，高高低低，而今离开已有一段时间。闲暇之余，梳理了三年多的收获与感慨，总结成 10 条，既是对过去一段时光的的一个深情回眸，也是对未来之路的一份期许。</p>
<p>倘若一些感悟能为刚步入职场的年轻人，或是刚在职业生涯中崭露头角的后起之秀，带来一点点启示与帮助，也是莫大的荣幸。</p>
<h2>01 结构化思考与表达</h2>
<p>美团是一家特别讲究方法论的公司，人人都要熟读四大名著《高效能人士的七个习惯》、《金字塔原理》、《用图表说话》和《学会提问》。</p>
<p>与结构化思考和表达相关的，是《金字塔原理》，作者是麦肯锡公司第一位女性咨询顾问。这本书告诉我们，思考和表达的过程，就像构建金字塔（或者构建一棵树），先有整体结论，再寻找证据，证据之间要讲究相互独立、而且能穷尽（MECE 原则），论证的过程也要按特定的顺序进行，比如时间顺序、空间顺序、重要性顺序……</p>
<p>作为大厂社畜，日常很大一部分工作就是写文档、看别人文档。大家做的事，但最后呈现的结果却有很大差异。一篇逻辑清晰、详略得当的文档，给人一种如沐春风的感受，能提炼出重要信息，是好的参考指南。</p>
<p>结构化思考与表达算是职场最通用的能力，也是打造个人影响力最重要的途径之一。</p>
<h2>02 忘掉职级，该怼就怼</h2>
<p>在阿里工作时，能看到每个人的 Title，看到江湖地位高（职级高+入职时间早）的同学，即便跟自己没有汇报关系，不自然的会多一层敬畏。推进工作时，会多一层压力，对方未读或已读未回时，不知如何应对。</p>
<p>美团只能看到每个人的坑位信息，还有 Ta 的上级。工作相关的问题，可以向任何人提问，如果协同方没有及时响应，隔段时间@一次，甚至"怼一怼"，都没啥问题，事情一直往前推进才最重要。除了大象消息直接提问外，还有个大杀器--TT（公司级问题流转系统），在上面提问时，加上对方主管，如果对方未及时回应，问题会自动升级，每天定时 Push，直到解决为止。</p>
<p>我见到一些很年轻的同事，他们在推动 OKR、要资源的事上，很有一套，只要能达到自己的目标，不会考虑别人的感受，最终，他们还真能把事办成。</p>
<p>当然了，段位越高的人，越能用自己的人格魅力、影响力、资源等，去影响和推动事情的进程，而不是靠对他人的 Push。只是在拿结果的事上，不要把自己太当回事，把别人太当回事，大家在一起，也只是为了完成各自的任务，忘掉职级，该怼时还得怼。</p>
<h2>03 用好平台资源</h2>
<p>没有人能在一家公司待一辈子，公司再牛，跟自己关系不大，重要的是，在有限的时间内，最大化用好平台资源。</p>
<p>在美团除了认识自己节点的同事外，有幸认识一群特别棒的协作方，还有其他 BU 的同学。</p>
<p>这些优秀的人身上，有很多共同的特质：谦虚、利他、乐于分享、双赢思维。</p>
<p>有两位做运营的同学。</p>
<p>一位是无意中关注他公众号结识上的。他公众号记录了很多职场成长、家庭建造上的思考和收获，还有定期个人复盘。他和太太都是大厂中层管理者，从文章中看到的不是他多厉害，而是非常接地气的故事。我们约饭了两次，有很多共同话题，现在还时不时有一些互动。</p>
<p>一位职级更高的同学，他在内网发起了一个"请我喝一杯咖啡，和我一起聊聊个人困惑"的活动，我报名参与了一期。和他聊天的过程，特别像是一场教练对话（最近学习教练课程时才感受到的），帮我排除干扰、聚焦目标的同时，也从他分享个人成长蜕变的过程，收获很多动力。（刚好自己最近也学习了教练技术，后面也准备采用类似的方式，去帮助曾经像我一样迷茫的人）</p>
<p>还有一些协作方同学。他们工作做得超级到位，能感受到，他们在乎他人时间；稍微有点出彩的事儿，不忘记拉上更多人。利他和双赢思维，在他们身上是最好的阐释。</p>
<p>除了结识优秀的人，向他们学习外，还可以关注各个通道/工种的课程资源。</p>
<p>在大厂，多数人的角色都是螺丝钉，但千万不要局限于做一颗螺丝钉。多去学习一些通识课，了解商业交付的各个环节，看清商业世界，明白自己的定位，超越自己的定位。</p>
<h2>04 一切都是争取来的</h2>
<p>工作很多年了，很晚才明白这个道理。</p>
<p>之前一直认为，只要做好自己该做的，一定会被看见，被赏识，也会得到更多机会。但很多时候，这只是个人的一厢情愿。除了自己，不会有人关心你的权益。</p>
<p>社会主义初级阶段，我国国内的主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。无论在哪里，资源都是稀缺的，自己在乎的，就得去争取。</p>
<p>想成长某个技能、想参与哪个模块、想做哪个项目，升职加薪……自己不提，不去争取，不会有人主动给你。</p>
<p>争不争取是一回事，能不能得到是一回事，只有争取，才有可能得到。争取了，即便没有得到，最终也没失去什么。</p>
<h2>05 关注商业</h2>
<p>大公司，极度关注效率，大部分岗位，拆解的粒度越细，效率会越高，这些对组织是有利的。但对个人来说，则很容易螺丝钉化。</p>
<p>做技术的同学，更是这样。</p>
<p>做前端的同学，不会关注数据是如何落库的；做后端的同学，不会思考页面是否存在兼容性问题；做业务开发的，不用考虑微服务诸多中间件是如何搭建起来的……</p>
<p>大部分人都想着怎么把自己这摊子事搞好，不会去思考上下游同学在做些什么，更少有人真正关注商业，关心公司的盈利模式，关心每一次产品迭代到底带来哪些业务价值。</p>
<p>把手头的事做好是应该的，但绝不能停留在此。所有的产品，只有在商业社会产生交付，让客户真正获益，才是有价值的。</p>
<p>关注商业，能帮我们升维到老板思维，明白投入产出比，抓大放小；也帮助我们，在碰到不好的业务时，及时止损；更重要的是，它帮助我们真正看清趋势，提前做好准备。</p>
<p>《五分钟商学院》系列，是很好的商业入门级书籍。尽管作者刘润最近存在争议，但不可否认，他比我们大多数人段位还是高很多，他的书值得一读。</p>
<h2>06 培养数据思维</h2>
<p>当今数字化时代，数据思维显得尤为重要。数据不仅可以帮助我们更好地了解世界，还可以指导我们的决策和行动。</p>
<p>非常幸运的是，在阿里和美团的两份经历，都是做商业化广告业务，在离钱💰最近的地方，也培养了数据的敏感性。见过商业数据指标的定义、加工、生产和应用全流程，也在不断熏陶下，能看懂大部分指标背后的价值。</p>
<p>除了直接面向业务的数据，还有研发协作全流程产生的数据。数据被记录和汇总统计后，能直观地看到每个环节的效率和质量。螺丝钉们的工作，也彻彻底底被数字量化，除了积极面对虚拟化、线上化、数字化外，我们别无他法。</p>
<p>受工作数据化的影响，生活中，我也渐渐变成了一个数据记录狂，日常运动（骑行、跑步、健走等）必须通过智能手表记录下来，没带 Apple Watch，感觉这次白运动了。每天也在很努力地完成三个圆环。</p>
<p>数据时代，我们沦为了透明人。也得益于数据被记录和分析，我们做任何事，都能快速得到反馈，这也是自我提升的一个重要环节。</p>
<h2>07 做一个好"销售"</h2>
<p>就某种程度来说，所有的工作，本质都是销售。</p>
<p>这是很多大咖的观点，我也是很晚才明白这个道理。</p>
<p>我们去一家公司应聘，本质上是在讲一个「我很牛」的故事，销售的是自己；日常工作汇报、季度/年度述职、晋升答辩，是在销售自己；在任何一个场合曝光，也是在销售自己。</p>
<p>如果我们所服务的组织，对外提供的是一件产品或一项服务，所有上下游协作的同学，唯一在做的事就是，齐心协力把产品/服务卖出去， 我们本质做的还是销售。</p>
<p>所以， 千万不要看不起任何销售，也不要认为认为销售是一件很丢面子的事。</p>
<p>真正的大佬，随时随地都在销售。</p>
<h2>08 少加班多运动</h2>
<p>在职场，大家都认同一个观点，工作是做不完的。</p>
<p>我们要做的是，用好时间管理四象限法，识别重要程度和优先级，有限时间，聚焦在固定几件事上。</p>
<p>这要求我们不断提高自己的问题识别能力、拆解能力，还有专注力。</p>
<p>我们会因为部分项目的需要而加班，但不会长期加班。</p>
<p>加班时间短一点，就能腾出更多时间运动。</p>
<p>最近一次线下培训课，认识一位老师 Hubert，Hubert 是一位超级有魅力的中年大叔（可以通过「有意思教练」的课程链接到他），从外企高管的位置离开后，和太太一起创办了一家培训机构。作为公司高层，日常工作非常忙，头发也有些花白了，但一身腱子肉胜过很多健身教练，给人的状态也是很年轻。聊天得知，Hubert 经常 5 点多起来泡健身房~</p>
<p>我身边还有一些同事，跟我年龄差不多，因为长期加班，发福严重，比实际年龄看起来苍老 10+岁；</p>
<p>还有同事曾经加班进 ICU，幸好后面身体慢慢恢复过来。</p>
<p>某某厂员工长期加班猝死的例子，更是屡见不鲜。</p>
<p>减少加班，增加运动，绝对是一件性价比极高的事。</p>
<h2>09 有随时可以离开的底气</h2>
<p>当今职场，跟父辈时候完全不一样，职业的多样性和变化性越来越快，很少有人能够在同一份工作或同一个公司待一辈子。除了某些特定的岗位，如公务员、事业单位等，大多数人都会在职业生涯中经历多次的职业变化和调整。</p>
<p>在商业组织里，个体是弱势群体，但不要做弱者。每一段职场，每一项工作，都是上天给我们的修炼。</p>
<p>我很喜欢"借假修真"这个词。我们参与的大大小小的项目， 重要吗？对公司来说可能重要，对个人来说，则未必。我们去做，一方面是迫于生计；</p>
<p>另外一方面，参与每个项目的感悟、心得、体会，是真实存在的，很多的能力，都是在这个过程得到提升。</p>
<p>明白这一点，就不会被职场所困，会刻意在各样事上提升自己，积累的越多，对事务的本质理解的越深、越广，也越发相信很多底层知识是通用的，内心越平静，也会建立起随时都可以离开的底气。</p>
<h2>10 只是一份工作</h2>
<p>工作中，我们时常会遇到各种挑战和困难，如发展瓶颈、难以处理的人和事，甚至职场 PUA 等。这些经历可能会让我们感到疲惫、沮丧，甚至怀疑自己的能力和价值。然而，重要的是要明白，困难只是成长道路上的暂时阻碍，而不是我们的定义。</p>
<p>写总结和复盘是很好的方式，可以帮我们理清思路，找到问题的根源，并学习如何应对类似的情况。但也要注意不要陷入自我怀疑和内耗的陷阱。遇到困难时，应该学会相信自己，积极寻找解决问题的方法，而不是过分纠结于自己的不足和错误。</p>
<p>内网常有同学匿名分享工作压力过大，常常失眠甚至中度抑郁，每次看到这些话题，非常难过。大环境不好，是不争的事实，但并不代表个体就没有出路。</p>
<p>我们容易预设困难，容易加很多"可是"，当窗户布满灰尘时，不要试图努力把窗户擦干净，走出去吧，你将看到一片蔚蓝的天空。</p>
<h2>最后</h2>
<p>写到最后，特别感恩美团三年多的经历。感谢我的 Leader 们，感谢曾经并肩作战过的小伙伴，感谢遇到的每一位和我一样在平凡的岗位，努力想带给身边一片微光的同学。所有的相遇，都是缘分。</p>
]]></content>
    <author>
      <name>CityDreamer部落</name>
    </author>
    <category term="技术文章精选集"/>
    <contributor>
      <name>CityDreamer部落</name>
    </contributor>
    <published>2023-12-17T07:37:37.000Z</published>
    <rights>Copyright by CityDreamer部落</rights>
  </entry>
  <entry>
    <title type="text">程序员如何快速学习新技术</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology.html"/>
    <updated>2024-01-07T16:20:15.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这是<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>练级攻略篇中的一篇文章，分享了我对于如何快速学习一门新技术的看法。</p>
<figure><img src="https://oss.javaguide.cn/javamianshizhibei/training-strategy-articles.png" alt="《Java 面试指北》练级攻略篇" tabindex="0"><figcaption>《Java 面试指北》练级攻略篇</figcaption></figure>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这是<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>练级攻略篇中的一篇文章，分享了我对于如何快速学习一门新技术的看法。</p>
<figure><img src="https://oss.javaguide.cn/javamianshizhibei/training-strategy-articles.png" alt="《Java 面试指北》练级攻略篇" tabindex="0"><figcaption>《Java 面试指北》练级攻略篇</figcaption></figure>
</blockquote>
<p>很多时候，我们因为工作原因需要快速学习某项技术，进而在项目中应用。或者说，我们想要去面试的公司要求的某项技术我们之前没有接触过，为了应对面试需要，我们需要快速掌握这项技术。</p>
<p>作为一个人纯自学出生的程序员，这篇文章简单聊聊自己对于如何快速学习某项技术的看法。</p>
<p>学习任何一门技术的时候，一定要先搞清楚这个技术是为了解决什么问题的。深入学习这个技术的之前，一定先从全局的角度来了解这个技术，思考一下它是由哪些模块构成的，提供了哪些功能，和同类的技术想必它有什么优势。</p>
<p>比如说我们在学习 Spring 的时候，通过 Spring 官方文档你就可以知道 Spring 最新的技术动态，Spring 包含哪些模块 以及 Spring 可以帮你解决什么问题。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/20210506110341207.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>再比如说我在学习消息队列的时候，我会先去了解这个消息队列一般在系统中有什么作用，帮助我们解决了什么问题。消息队列的种类很多，具体学习研究某个消息队列的时候，我会将其和自己已经学习过的消息队列作比较。像我自己在学习 RocketMQ 的时候，就会先将其和自己曾经学习过的第 1 个消息队列 ActiveMQ 进行比较，思考 RocketMQ 相对于 ActiveMQ 有了哪些提升，解决了 ActiveMQ 的哪些痛点，两者有哪些相似的地方，又有哪些不同的地方。</p>
<p><strong>学习一个技术最有效最快的办法就是将这个技术和自己之前学到的技术建立连接，形成一个网络。</strong></p>
<p>然后，我建议你先去看看官方文档的教程，运行一下相关的 Demo ，做一些小项目。</p>
<p>不过，官方文档通常是英文的，通常只有国产项目以及少部分国外的项目提供了中文文档。并且，官方文档介绍的往往也比较粗糙，不太适合初学者作为学习资料。</p>
<p>如果你看不太懂官网的文档，你也可以搜索相关的关键词找一些高质量的博客或者视频来看。 <strong>一定不要一上来就想着要搞懂这个技术的原理。</strong></p>
<p>就比如说我们在学习 Spring 框架的时候，我建议你在搞懂 Spring 框架所解决的问题之后，不是直接去开始研究 Spring 框架的原理或者源码，而是先实际去体验一下 Spring 框架提供的核心功能 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)，使用 Spring 框架写一些 Demo，甚至是使用 Spring 框架做一些小项目。</p>
<p>一言以蔽之， <strong>在研究这个技术的原理之前，先要搞懂这个技术是怎么使用的。</strong></p>
<p>这样的循序渐进的学习过程，可以逐渐帮你建立学习的快感，获得即时的成就感，避免直接研究原理性的知识而被劝退。</p>
<p><strong>研究某个技术原理的时候，为了避免内容过于抽象，我们同样可以动手实践。</strong></p>
<p>比如说我们学习 Tomcat 原理的时候，我们发现 Tomcat 的自定义线程池挺有意思，那我们自己也可以手写一个定制版的线程池。再比如我们学习 Dubbo 原理的时候，可以自己动手造一个简易版的 RPC 框架。</p>
<p>另外，学习项目中需要用到的技术和面试中需要用到的技术其实还是有一些差别的。</p>
<p>如果你学习某一项技术是为了在实际项目中使用的话，那你的侧重点就是学习这项技术的使用以及最佳实践，了解这项技术在使用过程中可能会遇到的问题。你的最终目标就是这项技术为项目带来了实际的效果，并且，这个效果是正面的。</p>
<p>如果你学习某一项技术仅仅是为了面试的话，那你的侧重点就应该放在这项技术在面试中最常见的一些问题上，也就是我们常说的八股文。</p>
<p>很多人一提到八股文，就是一脸不屑。在我看来，如果你不是死记硬背八股文，而是去所思考这些面试题的本质。那你在准备八股文的过程中，同样也能让你加深对这项技术的了解。</p>
<p>最后，最重要同时也是最难的还是 <strong>知行合一！知行合一！知行合一！</strong> 不论是编程还是其他领域，最重要不是你知道的有多少，而是要尽量做到知行合一。</p>
]]></content>
    <category term="技术文章精选集"/>
    <published>2023-11-09T08:24:19.000Z</published>
  </entry>
  <entry>
    <title type="text">经典算法思想总结（含LeetCode题目推荐）</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/classical-algorithm-problems-recommendations.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/classical-algorithm-problems-recommendations.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>贪心算法</h2>
<h3>算法思想</h3>
<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<h3>一般解题步骤</h3>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3>LeetCode</h3>
<p>455.分发饼干：<a href="https://leetcode.cn/problems/assign-cookies/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/assign-cookies/</a></p>]]></summary>
    <content type="html"><![CDATA[<h2>贪心算法</h2>
<h3>算法思想</h3>
<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<h3>一般解题步骤</h3>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h3>LeetCode</h3>
<p>455.分发饼干：<a href="https://leetcode.cn/problems/assign-cookies/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/assign-cookies/</a></p>
<p>121.买卖股票的最佳时机：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>122.买卖股票的最佳时机 II：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>55.跳跃游戏：<a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/jump-game/</a></p>
<p>45.跳跃游戏 II：<a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/jump-game-ii/</a></p>
<h2>动态规划</h2>
<h3>算法思想</h3>
<p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。</p>
<p>经典题目：01 背包、完全背包</p>
<h3>一般解题步骤</h3>
<ul>
<li>确定 dp 数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp 数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导 dp 数组</li>
</ul>
<h3>LeetCode</h3>
<p>509.斐波那契数：<a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/fibonacci-number/</a></p>
<p>746.使用最小花费爬楼梯：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>416.分割等和子集：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>518.零钱兑换：<a href="https://leetcode.cn/problems/coin-change-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/coin-change-ii/</a></p>
<p>647.回文子串：<a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/palindromic-substrings/</a></p>
<p>516.最长回文子序列：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p>
<h2>回溯算法</h2>
<h3>算法思想</h3>
<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条</p>
<p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。</p>
<p>经典题目：8 皇后</p>
<h3>一般解题步骤</h3>
<ul>
<li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li>
<li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</li>
<li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li>
</ul>
<h3>leetcode</h3>
<p>77.组合：<a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combinations/</a></p>
<p>39.组合总和：<a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combination-sum/</a></p>
<p>40.组合总和 II：<a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/combination-sum-ii/</a></p>
<p>78.子集：<a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/subsets/</a></p>
<p>90.子集 II：<a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/subsets-ii/</a></p>
<p>51.N 皇后：<a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/n-queens/</a></p>
<h2>分治算法</h2>
<h3>算法思想</h3>
<p>将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<p>经典题目：二分查找、汉诺塔问题</p>
<h3>一般解题步骤</h3>
<ul>
<li>将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>将各个子问题的解合并为原问题的解。</li>
</ul>
<h3>LeetCode</h3>
<p>108.将有序数组转换成二叉搜索数：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<p>148.排序列表：<a href="https://leetcode.cn/problems/sort-list/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/sort-list/</a></p>
<p>23.合并 k 个升序链表：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
]]></content>
    <category term="计算机基础"/>
    <published>2023-11-07T08:25:02.000Z</published>
  </entry>
  <entry>
    <title type="text">常见数据结构经典LeetCode题目推荐</title>
    <id>https://javaguide.cn/learning/cs-basics/algorithms/common-data-structures-leetcode-recommendations.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/algorithms/common-data-structures-leetcode-recommendations.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>数组</h2>
<p>704.二分查找：<a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/binary-search/</a></p>
<p>80.删除有序数组中的重复项 II：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a></p>]]></summary>
    <content type="html"><![CDATA[<h2>数组</h2>
<p>704.二分查找：<a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/binary-search/</a></p>
<p>80.删除有序数组中的重复项 II：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii</a></p>
<p>977.有序数组的平方：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/squares-of-a-sorted-array/</a></p>
<h2>链表</h2>
<p>707.设计链表：<a href="https://leetcode.cn/problems/design-linked-list/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/design-linked-list/</a></p>
<p>206.反转链表：<a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>92.反转链表 II：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>61.旋转链表：<a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/rotate-list/</a></p>
<h2>栈与队列</h2>
<p>232.用栈实现队列：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>225.用队列实现栈：<a href="https://leetcode.cn/problems/implement-stack-using-queues/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<p>347.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<p>239.滑动窗口最大值：<a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
<h2>二叉树</h2>
<p>105.从前序与中序遍历构造二叉树：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>117.填充每个节点的下一个右侧节点指针 II：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii</a></p>
<p>236.二叉树的最近公共祖先：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>129.求根节点到叶节点数字之和：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<p>102.二叉树的层序遍历：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<p>530.二叉搜索树的最小绝对差：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
<h2>图</h2>
<p>200.岛屿数量：<a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/number-of-islands/</a></p>
<p>207.课程表：<a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/course-schedule/</a></p>
<p>210.课程表 II：<a href="https://leetcode.cn/problems/course-schedule-ii/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/course-schedule-ii/</a></p>
<h2>堆</h2>
<p>215.数组中的第 K 个最大元素:<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<p>216.数据流的中位数:<a href="https://leetcode.cn/problems/find-median-from-data-stream/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
<p>217.前 K 个高频元素：<a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
]]></content>
    <category term="计算机基础"/>
    <published>2023-11-07T08:25:02.000Z</published>
  </entry>
  <entry>
    <title type="text">虚拟线程极简入门</title>
    <id>https://javaguide.cn/learning/java/concurrent/virtual-thread.html</id>
    <link href="https://javaguide.cn/learning/java/concurrent/virtual-thread.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文部分内容来自 <a href="https://github.com/Lorin-github" target="_blank" rel="noopener noreferrer">Lorin</a> 的<a href="https://github.com/Snailclimb/JavaGuide/pull/2190" target="_blank" rel="noopener noreferrer">PR</a>。</p>
</blockquote>
<p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>
<h2>什么是虚拟线程？</h2>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文部分内容来自 <a href="https://github.com/Lorin-github" target="_blank" rel="noopener noreferrer">Lorin</a> 的<a href="https://github.com/Snailclimb/JavaGuide/pull/2190" target="_blank" rel="noopener noreferrer">PR</a>。</p>
</blockquote>
<p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。</p>
<h2>什么是虚拟线程？</h2>
<p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p>
<h2>虚拟线程和平台线程有什么关系？</h2>
<p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程（Platform Thread），也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p>
<p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：<a href="https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7" target="_blank" rel="noopener noreferrer">How to Use Java 19 Virtual Threads</a>）：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png" alt="虚拟线程、平台线程和系统内核线程的关系" tabindex="0"><figcaption>虚拟线程、平台线程和系统内核线程的关系</figcaption></figure>
<p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: <a href="https://www.zhihu.com/question/23096638/answer/29617153" target="_blank" rel="noopener noreferrer">JVM 中的线程模型是用户级的么？</a>。</p>
<h2>虚拟线程有什么优点和缺点？</h2>
<h3>优点</h3>
<ul>
<li>非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li>
<li>简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</li>
<li>减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li>
</ul>
<h3>缺点</h3>
<ul>
<li>不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</li>
<li>依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</li>
</ul>
<h2>四种创建虚拟线程的方法</h2>
<p>Java 21 已经正式支持虚拟线程，大家可以在官网下载使用，在使用上官方为了降低使用门槛，尽量复用原有的 <code>Thread</code> 类，让大家可以更加平滑的使用。</p>
<p>官方提供了以下四种方式创建虚拟线程：</p>
<ol>
<li>使用 <code>Thread.startVirtualThread()</code> 创建</li>
<li>使用 <code>Thread.ofVirtual()</code> 创建</li>
<li>使用 <code>ThreadFactory</code> 创建</li>
</ol>
<h4>使用 Thread.startVirtualThread()创建</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CustomThread</span> customThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">startVirtualThread</span><span class="token punctuation">(</span>customThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>使用 Thread.ofVirtual()创建</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CustomThread</span> customThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建不启动</span>
    <span class="token class-name">Thread</span> unStarted <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unstarted</span><span class="token punctuation">(</span>customThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    unStarted<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建直接启动</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>customThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>使用 ThreadFactory 创建</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CustomThread</span> customThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ThreadFactory</span> factory <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">ofVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>customThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4>使用 Executors.newVirtualThreadPerTaskExecutor()创建</h4>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadTest</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CustomThread</span> customThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>customThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThread run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>虚拟线程和平台线程性能对比</h2>
<p>通过多线程和虚拟线程的方式处理相同的任务，对比创建的系统线程数和处理耗时。</p>
<p><strong>说明</strong>：统计创建的系统线程中部分为后台线程（比如 GC 线程），两种场景下都一样，所以并不影响对比。</p>
<p><strong>测试代码</strong>：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 开启线程 统计平台线程数</span>
        <span class="token class-name">ScheduledExecutorService</span> scheduledExecutorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        scheduledExecutorService<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">ThreadMXBean</span> threadBean <span class="token operator">=</span> <span class="token class-name">ManagementFactory</span><span class="token punctuation">.</span><span class="token function">getThreadMXBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ThreadInfo</span><span class="token punctuation">[</span><span class="token punctuation">]</span> threadInfo <span class="token operator">=</span> threadBean<span class="token punctuation">.</span><span class="token function">dumpAllThreads</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">updateMaxThreadNum</span><span class="token punctuation">(</span>threadInfo<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 虚拟线程</span>
        <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span>  <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用平台线程</span>
        <span class="token comment">// ExecutorService executor =  Executors.newFixedThreadPool(200);</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 线程睡眠 0.5 s，模拟业务处理</span>
                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        executor<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"max："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" platform thread/os thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"totalMillis：%dms\n"</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">}</span>
    <span class="token comment">// 更新创建的平台最大线程数</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">updateMaxThreadNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">Integer</span> integer <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&gt;</span> integer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>请求数 10000 单请求耗时 1s</strong>：</p>
<div class="language-plain" data-ext="plain" data-title="plain"><pre class="language-plain"><code>// Virtual Thread
max：22 platform thread/os thread
totalMillis：1806ms

// Platform Thread  线程数200
max：209 platform thread/os thread
totalMillis：50578ms

// Platform Thread  线程数500
max：509 platform thread/os thread
totalMillis：20254ms

// Platform Thread  线程数1000
max：1009 platform thread/os thread
totalMillis：10214ms

// Platform Thread  线程数2000
max：2009 platform thread/os thread
totalMillis：5358ms
</code></pre></div><p><strong>请求数 10000 单请求耗时 0.5s</strong>：</p>
<div class="language-plain" data-ext="plain" data-title="plain"><pre class="language-plain"><code>// Virtual Thread
max：22 platform thread/os thread
totalMillis：1316ms

// Platform Thread  线程数200
max：209 platform thread/os thread
totalMillis：25619ms

// Platform Thread  线程数500
max：509 platform thread/os thread
totalMillis：10277ms

// Platform Thread  线程数1000
max：1009 platform thread/os thread
totalMillis：5197ms

// Platform Thread  线程数2000
max：2009 platform thread/os thread
totalMillis：2865ms
</code></pre></div><ul>
<li>可以看到在密集 IO 的场景下，需要创建大量的平台线程异步处理才能达到虚拟线程的处理速度。</li>
<li>因此，在密集 IO 的场景，虚拟线程可以大幅提高线程的执行效率，减少线程资源的创建以及上下文切换。</li>
<li>吐槽：虽然虚拟线程我很想用，但是我 Java8 有机会升级到 Java21 吗？呜呜</li>
</ul>
<p><strong>注意</strong>：有段时间 JDK 一直致力于 Reactor 响应式编程来提高 Java 性能，但响应式编程难以理解、调试、使用，最终又回到了同步编程，最终虚拟线程诞生。</p>
]]></content>
    <category term="Java"/>
    <published>2023-10-15T12:01:30.000Z</published>
  </entry>
  <entry>
    <title type="text">Java 21 新特性概览(重要)</title>
    <id>https://javaguide.cn/learning/java/new-features/java21.html</id>
    <link href="https://javaguide.cn/learning/java/new-features/java21.html"/>
    <updated>2024-04-18T13:17:50.000Z</updated>
    <summary type="html"><![CDATA[<p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。</p>
<p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。</p>
<p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：</p>
<ul>
<li>
<p><a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">JEP 430：String Templates（字符串模板）</a>（预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/431" target="_blank" rel="noopener noreferrer">JEP 431：Sequenced Collections（序列化集合）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener noreferrer">JEP 439：Generational ZGC（分代 ZGC）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">JEP 440：Record Patterns（记录模式）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">JEP 441：Pattern Matching for switch（switch 的模式匹配）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第三次预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/443" target="_blank" rel="noopener noreferrer">JEP 443：Unnamed Patterns and Variables（未命名模式和变量</a>（预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/444" target="_blank" rel="noopener noreferrer">JEP 444：Virtual Threads（虚拟线程）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/445" target="_blank" rel="noopener noreferrer">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）</a>（预览）</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。</p>
<p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。</p>
<p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：</p>
<ul>
<li>
<p><a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">JEP 430：String Templates（字符串模板）</a>（预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/431" target="_blank" rel="noopener noreferrer">JEP 431：Sequenced Collections（序列化集合）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener noreferrer">JEP 439：Generational ZGC（分代 ZGC）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">JEP 440：Record Patterns（记录模式）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">JEP 441：Pattern Matching for switch（switch 的模式匹配）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">JEP 442：Foreign Function &amp; Memory API（外部函数和内存 API）</a>（第三次预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/443" target="_blank" rel="noopener noreferrer">JEP 443：Unnamed Patterns and Variables（未命名模式和变量</a>（预览）</p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/444" target="_blank" rel="noopener noreferrer">JEP 444：Virtual Threads（虚拟线程）</a></p>
</li>
<li>
<p><a href="https://openjdk.org/jeps/445" target="_blank" rel="noopener noreferrer">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）</a>（预览）</p>
</li>
</ul>
<h2>JEP 430：字符串模板（预览）</h2>
<p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。</p>
<p>String Templates 提供了一种更简洁、更直观的方式来动态构建字符串。通过使用占位符<code>${}</code>，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。在运行时，Java 编译器会将这些占位符替换为实际的变量值。并且，表达式支持局部变量、静态/非静态字段甚至方法、计算结果等特性。</p>
<p>实际上，String Templates（字符串模板）再大多数编程语言中都存在:</p>
<div class="language-typescript" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token string">"Greetings {{ name }}!"</span><span class="token punctuation">;</span>  <span class="token comment">//Angular</span>
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Greetings </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>    <span class="token comment">//Typescript</span>
$<span class="token string">"Greetings { name }!"</span>    <span class="token comment">//Visual basic</span>
f<span class="token string">"Greetings { name }!"</span>    <span class="token comment">//Python</span>
</code></pre></div><p>Java 在没有 String Templates 之前，我们通常使用字符串拼接或格式化方法来构建字符串：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//concatenation</span>
message <span class="token operator">=</span> <span class="token string">"Greetings "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">;</span>

<span class="token comment">//String.format()</span>
message <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"Greetings %s!"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//concatenation</span>

<span class="token comment">//MessageFormat</span>
message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageFormat</span><span class="token punctuation">(</span><span class="token string">"Greetings {0}!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//StringBuilder</span>
message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"Greetings "</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这些方法或多或少都存在一些缺点，比如难以阅读、冗长、复杂。</p>
<p>Java 使用 String Templates 进行字符串拼接，可以直接在字符串中嵌入表达式，而无需进行额外的处理：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings \{name}!"</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的模板表达式中：</p>
<ul>
<li>STR 是模板处理器。</li>
<li><code>\{name}</code>为表达式，运行时，这些表达式将被相应的变量值替换。</li>
</ul>
<p>Java 目前支持三种模板处理器：</p>
<ul>
<li>STR：自动执行字符串插值，即将模板中的每个嵌入式表达式替换为其值（转换为字符串）。</li>
<li>FMT：和 STR 类似，但是它还可以接受格式说明符，这些格式说明符出现在嵌入式表达式的左边，用来控制输出的样式。</li>
<li>RAW：不会像 STR 和 FMT 模板处理器那样自动处理字符串模板，而是返回一个 <code>StringTemplate</code> 对象，这个对象包含了模板中的文本和表达式的信息。</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"Lokesh"</span><span class="token punctuation">;</span>

<span class="token comment">//STR</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings \{name}."</span><span class="token punctuation">;</span>

<span class="token comment">//FMT</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings %-12s\{name}."</span><span class="token punctuation">;</span>

<span class="token comment">//RAW</span>
<span class="token class-name">StringTemplate</span> st <span class="token operator">=</span> <span class="token constant">RAW</span><span class="token punctuation">.</span><span class="token string">"Greetings \{name}."</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>除了 JDK 自带的三种模板处理器外，你还可以实现 <code>StringTemplate.Processor</code> 接口来创建自己的模板处理器，只需要继承 <code>StringTemplate.Processor</code>接口，然后实现 <code>process</code> 方法即可。</p>
<p>我们可以使用局部变量、静态/非静态字段甚至方法作为嵌入表达式：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//variable</span>
message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings \{name}!"</span><span class="token punctuation">;</span>

<span class="token comment">//method</span>
message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings \{getName()}!"</span><span class="token punctuation">;</span>

<span class="token comment">//field</span>
message <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"Greetings \{this.name}!"</span><span class="token punctuation">;</span>
</code></pre></div><p>还可以在表达式中执行计算并打印结果：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span><span class="token string">"\{x} + \{y} = \{x + y}"</span><span class="token punctuation">;</span>  <span class="token comment">//"10 + 20 = 30"</span>
</code></pre></div><p>为了提高可读性，我们可以将嵌入的表达式分成多行:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> time <span class="token operator">=</span> <span class="token constant">STR</span><span class="token punctuation">.</span>"<span class="token class-name">The</span> current time is \<span class="token punctuation">{</span>
    <span class="token comment">//sample comment - current time in HH:mm:ss</span>
    <span class="token class-name">DateTimeFormatter</span>
      <span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"HH:mm:ss"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">.</span>"<span class="token punctuation">;</span>
</code></pre></div><h2>JEP431：序列化集合</h2>
<p>JDK 21 引入了一种新的集合类型：<strong>Sequenced Collections（序列化集合，也叫有序集合）</strong>，这是一种具有确定出现顺序（encounter order）的集合（无论我们遍历这样的集合多少次，元素的出现顺序始终是固定的）。序列化集合提供了处理集合的第一个和最后一个元素以及反向视图（与原始集合相反的顺序）的简单方法。</p>
<p>Sequenced Collections 包括以下三个接口：</p>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedCollection.html" target="_blank" rel="noopener noreferrer"><code>SequencedCollection</code></a></li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html" target="_blank" rel="noopener noreferrer"><code>SequencedSet</code></a></li>
<li><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedMap.html" target="_blank" rel="noopener noreferrer"><code>SequencedMap</code></a></li>
</ul>
<p><code>SequencedCollection</code> 接口继承了 <code>Collection</code>接口， 提供了在集合两端访问、添加或删除元素以及获取集合的反向视图的方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

  <span class="token comment">// New Method</span>

  <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Promoted methods from Deque&lt;E&gt;</span>

  <span class="token keyword">void</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>List</code> 和 <code>Deque</code> 接口实现了<code>SequencedCollection</code> 接口。</p>
<p>这里以 <code>ArrayList</code> 为例，演示一下实际使用效果：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arrayList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

arrayList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// List contains: [1]</span>

arrayList<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// List contains: [0, 1]</span>
arrayList<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// List contains: [0, 1, 2]</span>

<span class="token class-name">Integer</span> firstElement <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 0</span>
<span class="token class-name">Integer</span> lastElement <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> reversed <span class="token operator">=</span> arrayList<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reversed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints [2, 1, 0]</span>
</code></pre></div><p><code>SequencedSet</code>接口直接继承了 <code>SequencedCollection</code> 接口并重写了 <code>reversed()</code> 方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SortedSet</code> 和 <code>LinkedHashSet</code> 实现了<code>SequencedSet</code>接口。</p>
<p>这里以 <code>LinkedHashSet</code> 为例，演示一下实际使用效果：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> linkedHashSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Integer</span> firstElement <span class="token operator">=</span> linkedHashSet<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1</span>
<span class="token class-name">Integer</span> lastElement <span class="token operator">=</span> linkedHashSet<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3</span>

linkedHashSet<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//List contains: [0, 1, 2, 3]</span>
linkedHashSet<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//List contains: [0, 1, 2, 3, 4]</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>linkedHashSet<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//Prints [5, 3, 2, 1, 0]</span>
</code></pre></div><p><code>SequencedMap</code> 接口继承了 <code>Map</code>接口， 提供了在集合两端访问、添加或删除键值对、获取包含 key 的 <code>SequencedSet</code>、包含 value 的 <code>SequencedCollection</code>、包含 entry（键值对） 的 <code>SequencedSet</code>以及获取集合的反向视图的方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">SequencedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

  <span class="token comment">// New Methods</span>

  <span class="token class-name">SequencedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SequencedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">SequencedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">sequencedEntrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">V</span> <span class="token function">putFirst</span><span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">V</span> <span class="token function">putLast</span><span class="token punctuation">(</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token comment">// Promoted Methods from NavigableMap&lt;K, V&gt;</span>

  <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">firstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">lastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">pollFirstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">pollLastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>SortedMap</code> 和<code>LinkedHashMap</code> 实现了<code>SequencedMap</code> 接口。</p>
<p>这里以 <code>LinkedHashMap</code> 为例，演示一下实际使用效果：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">firstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1=One</span>
map<span class="token punctuation">.</span><span class="token function">lastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//3=Three</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//{1=One, 2=Two, 3=Three}</span>

<span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">pollFirstEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//1=One</span>
<span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> last <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">pollLastEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//3=Three</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//{2=Two}</span>

map<span class="token punctuation">.</span><span class="token function">putFirst</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//{1=One, 2=Two}</span>
map<span class="token punctuation">.</span><span class="token function">putLast</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//{1=One, 2=Two, 3=Three}</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//{1=One, 2=Two, 3=Three}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//{3=Three, 2=Two, 1=One}</span>
</code></pre></div><h2>JEP 439：分代 ZGC</h2>
<p>JDK21 中对 ZGC 进行了功能扩展，增加了分代 GC 功能。不过，默认是关闭的，需要通过配置打开：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>// 启用分代ZGC
<span class="token function">java</span> <span class="token parameter variable">-XX:+UseZGC</span> <span class="token parameter variable">-XX:+ZGenerational</span> <span class="token punctuation">..</span>.
</code></pre></div><p>在未来的版本中，官方会把 ZGenerational 设为默认值，即默认打开 ZGC 的分代 GC。在更晚的版本中，非分代 ZGC 就被移除。</p>
<blockquote>
<p>In a future release we intend to make Generational ZGC the default, at which point -XX:-ZGenerational will select non-generational ZGC. In an even later release we intend to remove non-generational ZGC, at which point the ZGenerational option will become obsolete.</p>
<p>在将来的版本中，我们打算将 Generational ZGC 作为默认选项，此时-XX:-ZGenerational 将选择非分代 ZGC。在更晚的版本中，我们打算移除非分代 ZGC，此时 ZGenerational 选项将变得过时。</p>
</blockquote>
<p>分代 ZGC 可以显著减少垃圾回收过程中的停顿时间，并提高应用程序的响应性能。这对于大型 Java 应用程序和高并发场景下的性能优化非常有价值。</p>
<h2>JEP 440：记录模式</h2>
<p>记录模式在 Java 19 进行了第一次预览， 由 <a href="https://openjdk.org/jeps/405" target="_blank" rel="noopener noreferrer">JEP 405</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/432" target="_blank" rel="noopener noreferrer">JEP 432</a> 提出。最终，记录模式在 JDK21 顺利转正。</p>
<p><a href="/learning/java/new-features/java20.html" target="_blank">Java 20 新特性概览</a>已经详细介绍过记录模式，这里就不重复了。</p>
<h2>JEP 441：switch 的模式匹配</h2>
<p>增强 Java 中的 switch 表达式和语句，允许在 case 标签中使用模式。当模式匹配时，执行 case 标签对应的代码。</p>
<p>在下面的代码中，switch 表达式使用了类型模式来进行匹配。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">formatterPatternSwitch</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">switch</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token class-name">Integer</span> i <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"int %d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Long</span> l    <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"long %d"</span><span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">Double</span> d  <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"double %f"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token class-name">String</span> s  <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"String %s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span>        <span class="token operator">-&gt;</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>JEP 442: 外部函数和内存 API（第三次预览）</h2>
<p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。</p>
<p>外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 <a href="https://openjdk.java.net/jeps/412" target="_blank" rel="noopener noreferrer">JEP 412</a> 提出。Java 18 中进行了第二次孵化，由<a href="https://openjdk.org/jeps/419" target="_blank" rel="noopener noreferrer">JEP 419</a> 提出。Java 19 中是第一次预览，由 <a href="https://openjdk.org/jeps/424" target="_blank" rel="noopener noreferrer">JEP 424</a> 提出。JDK 20 中是第二次预览，由 <a href="https://openjdk.org/jeps/434" target="_blank" rel="noopener noreferrer">JEP 434</a> 提出。JDK 21 中是第三次预览，由 <a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">JEP 442</a> 提出。</p>
<p>在 <a href="/learning/java/new-features/java19.html" target="_blank">Java 19 新特性概览</a> 中，我有详细介绍到外部函数和内存 API，这里就不再做额外的介绍了。</p>
<h2>JEP 443：未命名模式和变量（预览）</h2>
<p>未命名模式和变量使得我们可以使用下划线 <code>_</code> 表示未命名的变量以及模式匹配时不使用的组件，旨在提高代码的可读性和可维护性。</p>
<p>未命名变量的典型场景是 <code>try-with-resources</code> 语句、 <code>catch</code> 子句中的异常变量和<code>for</code>循环。当变量不需要使用的时候就可以使用下划线 <code>_</code>代替，这样清晰标识未被使用的变量。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _ <span class="token operator">=</span> <span class="token class-name">ScopedContext</span><span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// No use of acquired resource</span>
<span class="token punctuation">}</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> _<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> _<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> _ <span class="token operator">=</span> <span class="token function">runOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>未命名模式是一个无条件的模式，并不绑定任何值。未命名模式变量出现在类型模式中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token keyword">instanceof</span> <span class="token class-name">ColoredPoint</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token class-name">Color</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> c <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token keyword">switch</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token class-name">RedBall</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token class-name">BlueBall</span> _<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">processBox</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">Box</span><span class="token punctuation">(</span><span class="token class-name">GreenBall</span> _<span class="token punctuation">)</span>                <span class="token operator">-&gt;</span> <span class="token function">stopProcessing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token class-name">Box</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>                          <span class="token operator">-&gt;</span> <span class="token function">pickAnotherBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>JEP 444：虚拟线程</h2>
<p>虚拟线程是一项重量级的更新，一定一定要重视！</p>
<p>虚拟线程在 Java 19 中进行了第一次预览，由<a href="https://openjdk.org/jeps/425" target="_blank" rel="noopener noreferrer">JEP 425</a>提出。JDK 20 中是第二次预览。最终，虚拟线程在 JDK21 顺利转正。</p>
<p><a href="/learning/java/new-features/java20.html" target="_blank">Java 20 新特性概览</a>已经详细介绍过虚拟线程，这里就不重复了。</p>
<h2>JEP 445：未命名类和实例 main 方法 （预览）</h2>
<p>这个特性主要简化了 <code>main</code> 方法的的声明。对于 Java 初学者来说，这个 <code>main</code> 方法的声明引入了太多的 Java 语法概念，不利于初学者快速上手。</p>
<p>没有使用该特性之前定义一个 <code>main</code> 方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用该新特性之后定义一个 <code>main</code> 方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>进一步精简(未命名的类允许我们不定义类名)：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>参考</h2>
<ul>
<li>Java 21 String Templates：<a href="https://howtodoinjava.com/java/java-string-templates/" target="_blank" rel="noopener noreferrer">https://howtodoinjava.com/java/java-string-templates/</a></li>
<li>Java 21 Sequenced Collections：<a href="https://howtodoinjava.com/java/sequenced-collections/" target="_blank" rel="noopener noreferrer">https://howtodoinjava.com/java/sequenced-collections/</a></li>
</ul>
]]></content>
    <category term="Java"/>
    <published>2023-10-08T07:27:41.000Z</published>
  </entry>
  <entry>
    <title type="text">Maven最佳实践</title>
    <id>https://javaguide.cn/learning/tools/maven/maven-best-practices.html</id>
    <link href="https://javaguide.cn/learning/tools/maven/maven-best-practices.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文由 JavaGuide 翻译并完善，原文地址：<a href="https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b" target="_blank" rel="noopener noreferrer">https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b</a> 。</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文由 JavaGuide 翻译并完善，原文地址：<a href="https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b" target="_blank" rel="noopener noreferrer">https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b</a> 。</p>
</blockquote>
<p>Maven 是一种广泛使用的 Java 项目构建自动化工具。它简化了构建过程并帮助管理依赖关系，使开发人员的工作更轻松。Maven 详细介绍可以参考我写的这篇 <a href="/learning/tools/maven/maven-core-concepts.html" target="_blank">Maven 核心概念总结</a> 。</p>
<p>这篇文章不会涉及到 Maven 概念的介绍，主要讨论一些最佳实践、建议和技巧，以优化我们在项目中对 Maven 的使用并改善我们的开发体验。</p>
<h2>Maven 标准目录结构</h2>
<p>Maven 遵循标准目录结构来保持项目之间的一致性。遵循这种结构可以让其他开发人员更轻松地理解我们的项目。</p>
<p>Maven 项目的标准目录结构如下：</p>
<div class="language-groovy" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>src <span class="token operator">/</span>
  main <span class="token operator">/</span>
    java<span class="token operator">/</span>
    resources<span class="token operator">/</span>
  test<span class="token operator">/</span> java
     <span class="token operator">/</span>
    resources<span class="token operator">/</span>
pom<span class="token punctuation">.</span>xml
</code></pre></div><ul>
<li><code>src/main/java</code>：源代码目录</li>
<li><code>src/main/resources</code>：资源文件目录</li>
<li><code>src/test/java</code>：测试代码目录</li>
<li><code>src/test/resources</code>：测试资源文件目录</li>
</ul>
<p>这只是一个最简单的 Maven 项目目录示例。实际项目中，我们还会根据项目规范去做进一步的细分。</p>
<h2>指定 Maven 编译器插件</h2>
<p>默认情况下，Maven 使用 Java5 编译我们的项目。要使用不同的 JDK 版本，请在 <code>pom.xml</code> 文件中配置 Maven 编译器插件。</p>
<p>例如，如果你想要使用 Java8 来编译你的项目，你可以在<code>&lt;build&gt;</code>标签下添加以下的代码片段：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这样，Maven 就会使用 Java8 的编译器来编译你的项目。如果你想要使用其他版本的 JDK，你只需要修改<code>&lt;source&gt;</code>和<code>&lt;target&gt;</code>标签的值即可。例如，如果你想要使用 Java11，你可以将它们的值改为 11。</p>
<h2>有效管理依赖关系</h2>
<p>Maven 的依赖管理系统是其最强大的功能之一。在顶层 pom 文件中，通过标签 <code>dependencyManagement</code> 定义公共的依赖关系，这有助于避免冲突并确保所有模块使用相同版本的依赖项。</p>
<p>例如，假设我们有一个父模块和两个子模块 A 和 B，我们想要在所有模块中使用 JUnit 5.7.2 作为测试框架。我们可以在父模块的<code>pom.xml</code>文件中使用<code>&lt;dependencyManagement&gt;</code>标签来定义 JUnit 的版本：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.junit.jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit-jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.7.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在子模块 A 和 B 的 <code>pom.xml</code> 文件中，我们只需要引用 JUnit 的 <code>groupId</code> 和 <code>artifactId</code> 即可:</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.junit.jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit-jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2>针对不同环境使用配置文件</h2>
<p>Maven 配置文件允许我们配置不同环境的构建设置，例如开发、测试和生产。在 <code>pom.xml</code> 文件中定义配置文件并使用命令行参数激活它们：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>development<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span><span class="token punctuation">&gt;</span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>production<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span><span class="token punctuation">&gt;</span></span>prod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>使用命令行激活配置文件：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>mvn clean <span class="token function">install</span> <span class="token parameter variable">-P</span> production
</code></pre></div><h2>保持 pom.xml 干净且井然有序</h2>
<p>组织良好的 <code>pom.xml</code> 文件更易于维护和理解。以下是维护干净的 <code>pom.xml</code> 的一些技巧：</p>
<ul>
<li>将相似的依赖项和插件组合在一起。</li>
<li>使用注释来描述特定依赖项或插件的用途。</li>
<li>将插件和依赖项的版本号保留在 <code>&lt;properties&gt;</code> 标签内以便于管理。</li>
</ul>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>junit.version</span><span class="token punctuation">&gt;</span></span>5.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>junit.version</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mockito.version</span><span class="token punctuation">&gt;</span></span>3.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mockito.version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><h2>使用 Maven Wrapper</h2>
<p>Maven Wrapper 是一个用于管理和使用 Maven 的工具，它允许在没有预先安装 Maven 的情况下运行和构建 Maven 项目。</p>
<p>Maven 官方文档是这样介绍 Maven Wrapper 的：</p>
<blockquote>
<p>The Maven Wrapper is an easy way to ensure a user of your Maven build has everything necessary to run your Maven build.</p>
<p>Maven Wrapper 是一种简单的方法，可以确保 Maven 构建的用户拥有运行 Maven 构建所需的一切。</p>
</blockquote>
<p>Maven Wrapper 可以确保构建过程使用正确的 Maven 版本，非常方便。要使用 Maven Wrapper，请在项目目录中运行以下命令：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>mvn wrapper:wrapper
</code></pre></div><p>此命令会在我们的项目中生成 Maven Wrapper 文件。现在我们可以使用 <code>./mvnw</code> （或 Windows 上的 <code>./mvnw.cmd</code>）而不是 <code>mvn</code> 来执行 Maven 命令。</p>
<h2>通过持续集成实现构建自动化</h2>
<p>将 Maven 项目与持续集成 (CI) 系统（例如 Jenkins 或 GitHub Actions）集成，可确保自动构建、测试和部署我们的代码。CI 有助于及早发现问题并在整个团队中提供一致的构建流程。以下是 Maven 项目的简单 GitHub Actions 工作流程示例：</p>
<div class="language-groovy" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>name<span class="token punctuation">:</span> Java CI with Maven

on<span class="token punctuation">:</span> <span class="token punctuation">[</span>push<span class="token punctuation">]</span>

jobs<span class="token punctuation">:</span>
  build<span class="token punctuation">:</span>
    runs<span class="token operator">-</span>on<span class="token punctuation">:</span> ubuntu<span class="token operator">-</span>latest

    steps<span class="token punctuation">:</span>
    <span class="token operator">-</span> name<span class="token punctuation">:</span> Checkout code
      uses<span class="token punctuation">:</span> actions<span class="token operator">/</span>checkout<span class="token annotation punctuation">@v2</span>

    <span class="token operator">-</span> name<span class="token punctuation">:</span> Set up JDK <span class="token number">11</span>
      uses<span class="token punctuation">:</span> actions<span class="token operator">/</span>setup<span class="token operator">-</span>java<span class="token annotation punctuation">@v2</span>
      with<span class="token punctuation">:</span>
        java<span class="token operator">-</span>version<span class="token punctuation">:</span> <span class="token string">'11'</span>
        distribution<span class="token punctuation">:</span> <span class="token string">'adopt'</span>

    <span class="token operator">-</span> name<span class="token punctuation">:</span> Build with Maven
      run<span class="token punctuation">:</span> <span class="token punctuation">.</span>/mvnw clean install
</code></pre></div><h2>利用 Maven 插件获得附加功能</h2>
<p>有许多 Maven 插件可用于扩展 Maven 的功能。一些流行的插件包括（前三个是 Maven 自带的插件，后三个是第三方提供的插件）：</p>
<ul>
<li>maven-surefire-plugin：配置并执行单元测试。</li>
<li>maven-failsafe-plugin：配置并执行集成测试。</li>
<li>maven-javadoc-plugin：生成 Javadoc 格式的项目文档。</li>
<li>maven-checkstyle-plugin：强制执行编码标准和最佳实践。</li>
<li>jacoco-maven-plugin: 单测覆盖率。</li>
<li>sonar-maven-plugin：分析代码质量。</li>
<li>……</li>
</ul>
<p>jacoco-maven-plugin 使用示例：</p>
<div class="language-xml" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.jacoco<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jacoco-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.8.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>prepare-agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>generate-code-coverage-report<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">&gt;</span></span>report<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">&gt;</span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果这些已有的插件无法满足我们的需求，我们还可以自定义插件。</p>
<p>探索可用的插件并在 <code>pom.xml</code> 文件中配置它们以增强我们的开发过程。</p>
<h2>总结</h2>
<p>Maven 是一个强大的工具，可以简化 Java 项目的构建过程和依赖关系管理。通过遵循这些最佳实践和技巧，我们可以优化 Maven 的使用并改善我们的 Java 开发体验。请记住使用标准目录结构，有效管理依赖关系，利用不同环境的配置文件，并将项目与持续集成系统集成，以确保构建一致。</p>
]]></content>
    <category term="开发工具"/>
    <published>2023-09-15T13:14:19.000Z</published>
  </entry>
  <entry>
    <title type="text">IoC &amp; AOP详解（快速搞懂）</title>
    <id>https://javaguide.cn/learning/system-design/framework/spring/ioc-and-aop.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/spring/ioc-and-aop.html"/>
    <updated>2024-02-16T02:58:48.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章会从下面从以下几个问题展开对 IoC &amp; AOP 的解释</p>
<ul>
<li>什么是 IoC？</li>
<li>IoC 解决了什么问题？</li>
<li>IoC 和 DI 的区别？</li>
<li>什么是 AOP？</li>
<li>AOP 解决了什么问题？</li>
<li>AOP 的应用场景有哪些？</li>
<li>AOP 为什么叫做切面编程？</li>
<li>AOP 实现方式有哪些？</li>
</ul>
<p>首先声明：IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章会从下面从以下几个问题展开对 IoC &amp; AOP 的解释</p>
<ul>
<li>什么是 IoC？</li>
<li>IoC 解决了什么问题？</li>
<li>IoC 和 DI 的区别？</li>
<li>什么是 AOP？</li>
<li>AOP 解决了什么问题？</li>
<li>AOP 的应用场景有哪些？</li>
<li>AOP 为什么叫做切面编程？</li>
<li>AOP 实现方式有哪些？</li>
</ul>
<p>首先声明：IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p>
<h2>IoC （Inversion of control ）</h2>
<h3>什么是 IoC?</h3>
<p>IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p>
<p>例如：现有类 A 依赖于类 B</p>
<ul>
<li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li>
<li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。</li>
</ul>
<p>从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）</p>
<p><strong>为什么叫控制反转?</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li>
</ul>
<figure><img src="https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="IoC 图解" tabindex="0"><figcaption>IoC 图解</figcaption></figure>
<h3>IoC 解决了什么问题?</h3>
<p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p>
<ol>
<li>对象之间的耦合度或者说依赖程度降低；</li>
<li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li>
</ol>
<p>例如：现有一个针对 User 的操作，利用 Service 和 Dao 两层结构进行开发</p>
<p>在没有使用 IoC 思想的情况下，Service 层想要使用 Dao 层的具体实现的话，需要通过 new 关键字在<code>UserServiceImpl</code> 中手动 new 出 <code>IUserDao</code> 的具体实现类 <code>UserDaoImpl</code>（不能直接 new 接口类）。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/ioc-kfji3.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>很完美，这种方式也是可以实现的，但是我们想象一下如下场景：</p>
<p>开发过程中突然接到一个新的需求，针对<code>IUserDao</code> 接口开发出另一个具体实现类。因为 Server 层依赖了<code>IUserDao</code>的具体实现，所以我们需要修改<code>UserServiceImpl</code>中 new 的对象。如果只有一个类引用了<code>IUserDao</code>的具体实现，可能觉得还好，修改起来也不是很费力气，但是如果有许许多多的地方都引用了<code>IUserDao</code>的具体实现的话，一旦需要更换<code>IUserDao</code> 的实现方式，那修改起来将会非常的头疼。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>使用 IoC 的思想，我们将对象的控制权（创建、管理）交有 IoC 容器去管理，我们在使用的时候直接向 IoC 容器 “要” 就可以了</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/why-ioc-2.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3>IoC 和 DI 有区别吗？</h3>
<p>IoC（Inverse of Control:控制反转）是一种设计思想或者说是某种模式。这个设计思想就是 <strong>将原本在程序中手动创建对象的控制权交给第三方比如 IoC 容器。</strong> 对于我们常用的 Spring 框架来说， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。不过，IoC 在其他语言中也有应用，并非 Spring 特有。</p>
<p>IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p>
<p>老马（Martin Fowler）在一篇文章中提到将 IoC 改名为 DI，原文如下，原文地址：<a href="https://martinfowler.com/articles/injection.html" target="_blank" rel="noopener noreferrer">https://martinfowler.com/articles/injection.html</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/martin-fowler-injection.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>老马的大概意思是 IoC 太普遍并且不表意，很多人会因此而迷惑，所以，使用 DI 来精确指名这个模式比较好。</p>
<h2>AOP（Aspect oriented programming）</h2>
<p>这里不会涉及太多专业的术语，核心目的是将 AOP 的思想说清楚。</p>
<h3>什么是 AOP？</h3>
<p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p>
<p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p>
<h3>AOP 为什么叫面向切面编程？</h3>
<p>AOP 之所以叫面向切面编程，是因为它的核心思想就是将横切关注点从核心业务逻辑中分离出来，形成一个个的<strong>切面（Aspect）</strong>。</p>
<p>这里顺带总结一下 AOP 关键术语（不理解也没关系，可以继续往下看）：</p>
<ul>
<li><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</li>
<li><strong>切面（Aspect）</strong>：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</li>
<li><strong>连接点（JoinPoint）</strong>：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</li>
<li><strong>通知（Advice）</strong>：通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。</li>
<li><strong>切点（Pointcut）</strong>：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。</li>
<li><strong>织入（Weaving）</strong>：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（AspectJ）和运行期织入（AspectJ）。</li>
</ul>
<h3>AOP 解决了什么问题？</h3>
<p>OOP 不能很好地处理一些分散在多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等），这些行为通常被称为 <strong>横切关注点（cross-cutting concerns）</strong> 。如果我们在每个类或对象中都重复实现这些行为，那么会导致代码的冗余、复杂和难以维护。</p>
<p>AOP 可以将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从 <strong>核心业务逻辑（core concerns，核心关注点）</strong> 中分离出来，实现关注点的分离。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/crosscut-logic-and-businesslogic-separation      .png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>以日志记录为例进行介绍，假如我们需要对某些方法进行统一格式的日志记录，没有使用 AOP 技术之前，我们需要挨个写日志记录的逻辑代码，全是重复的的逻辑。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">CommonResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 业务逻辑</span>
      xxService<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 省略具体的业务处理逻辑</span>
      <span class="token comment">// 日志记录</span>
      <span class="token class-name">ServletRequestAttributes</span> attributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 省略记录日志的具体逻辑 如：获取各种信息，写入数据库等操作...</span>
      <span class="token keyword">return</span> <span class="token class-name">CommonResponse</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">CommonResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 业务逻辑</span>
      xxService<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 省略具体的业务处理逻辑</span>
      <span class="token comment">// 日志记录</span>
      <span class="token class-name">ServletRequestAttributes</span> attributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span> <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> attributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 省略记录日志的具体逻辑 如：获取各种信息，写入数据库等操作...</span>
      <span class="token keyword">return</span> <span class="token class-name">CommonResponse</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ...</span>
</code></pre></div><p>使用 AOP 技术之后，我们可以将日志记录的逻辑封装成一个切面，然后通过切入点和通知来指定在哪些方法需要执行日志记录的操作。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>
<span class="token comment">// 日志注解</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">PARAMETER</span><span class="token punctuation">,</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Log</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/**
     * 描述
     */</span>
    <span class="token class-name">String</span> <span class="token function">description</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 方法类型 INSERT DELETE UPDATE OTHER
     */</span>
    <span class="token class-name">MethodType</span> <span class="token function">methodType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token constant">OTHER</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 日志切面</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Aspect</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogAspect</span> <span class="token punctuation">{</span>
  <span class="token comment">// 切入点，所有被 Log 注解标注的方法</span>
  <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"@annotation(cn.javaguide.annotation.Log)"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">webLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>

   <span class="token doc-comment comment">/**
   * 环绕通知
   */</span>
  <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"webLog()"</span><span class="token punctuation">)</span>
  <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略具体的处理逻辑</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 省略其他代码</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样的话，我们一行注解即可实现日志记录：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Log</span><span class="token punctuation">(</span>description <span class="token operator">=</span> <span class="token string">"method1"</span><span class="token punctuation">,</span>methodType <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token constant">INSERT</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">CommonResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 业务逻辑</span>
      xxService<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 省略具体的业务处理逻辑</span>
      <span class="token keyword">return</span> <span class="token class-name">CommonResponse</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>AOP 的应用场景有哪些？</h3>
<ul>
<li>日志记录：自定义日志记录注解，利用 AOP，一行代码即可实现日志记录。</li>
<li>性能统计：利用 AOP 在目标方法的执行前后统计方法的执行时间，方便优化和分析。</li>
<li>事务管理：<code>@Transactional</code> 注解可以让 Spring 为我们进行事务管理比如回滚异常操作，免去了重复的事务管理逻辑。<code>@Transactional</code>注解就是基于 AOP 实现的。</li>
<li>权限控制：利用 AOP 在目标方法执行前判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。例如，SpringSecurity 利用<code>@PreAuthorize</code> 注解一行代码即可自定义权限校验。</li>
<li>接口限流：利用 AOP 在目标方法执行前通过具体的限流算法和实现对请求进行限流处理。</li>
<li>缓存管理：利用 AOP 在目标方法执行前后进行缓存的读取和更新。</li>
<li>……</li>
</ul>
<h3>AOP 实现方式有哪些？</h3>
<p>AOP 的常见实现方式有动态代理、字节码操作等方式。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess" tabindex="0"><figcaption>SpringAOPProcess</figcaption></figure>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
]]></content>
    <category term="框架"/>
    <published>2023-09-10T14:59:47.000Z</published>
  </entry>
  <entry>
    <title type="text">Spring Boot核心源码解读（付费）</title>
    <id>https://javaguide.cn/learning/system-design/framework/spring/springboot-source-code.html</id>
    <link href="https://javaguide.cn/learning/system-design/framework/spring/springboot-source-code.html"/>
    <updated>2024-02-18T03:33:12.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>Spring Boot 核心源码解读</strong> 为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/source-code-reading.html" target="_blank" rel="noopener noreferrer">《Java 必读源码系列》</a>中。</p>]]></summary>
    <content type="html"><![CDATA[<p><strong>Spring Boot 核心源码解读</strong> 为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/source-code-reading.html" target="_blank" rel="noopener noreferrer">《Java 必读源码系列》</a>中。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/springboot-source-code.png" alt="Spring Boot核心源码解读" tabindex="0"><figcaption>Spring Boot核心源码解读</figcaption></figure>
<p><a href="/learning/zhuanlan/source-code-reading.html" target="_blank">《Java 必读源码系列》</a>（点击链接即可查看详细介绍）的部分内容展示如下。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20220621091832348.png" alt="《Java 必读源码系列》" tabindex="0"><figcaption>《Java 必读源码系列》</figcaption></figure>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>
<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiufuwu.png" alt="星球服务" tabindex="0"></a><figcaption>星球服务</figcaption></figure>
<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 知识星球详细介绍</a> 。</p>
<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg" alt="知识星球30元优惠卷" tabindex="0"><figcaption>知识星球30元优惠卷</figcaption></figure>
<p>进入星球之后，记得查看 <strong><a href="https://t.zsxq.com/0d18KSarv" target="_blank" rel="noopener noreferrer">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href="https://t.zsxq.com/12uSKgTIm" target="_blank" rel="noopener noreferrer">星球优质主题汇总</a></strong> 。</p>
<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>
<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="框架"/>
    <published>2023-07-27T01:08:19.000Z</published>
  </entry>
  <entry>
    <title type="text">SQL常见面试题总结（2）</title>
    <id>https://javaguide.cn/learning/database/sql/sql-questions-02.html</id>
    <link href="https://javaguide.cn/learning/database/sql/sql-questions-02.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<h2>增删改操作</h2>
<p>SQL 插入记录的方式汇总：</p>
<ul>
<li><strong>普通插入（全字段）</strong> ：<code>INSERT INTO table_name VALUES (value1, value2, ...)</code></li>
<li><strong>普通插入（限定字段）</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)</code></li>
<li><strong>多条一次性插入</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</code></li>
<li><strong>从另一个表导入</strong> ：<code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]</code></li>
<li><strong>带更新的插入</strong> ：<code>REPLACE INTO table_name VALUES (value1, value2, ...)</code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<h2>增删改操作</h2>
<p>SQL 插入记录的方式汇总：</p>
<ul>
<li><strong>普通插入（全字段）</strong> ：<code>INSERT INTO table_name VALUES (value1, value2, ...)</code></li>
<li><strong>普通插入（限定字段）</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)</code></li>
<li><strong>多条一次性插入</strong> ：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...</code></li>
<li><strong>从另一个表导入</strong> ：<code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]</code></li>
<li><strong>带更新的插入</strong> ：<code>REPLACE INTO table_name VALUES (value1, value2, ...)</code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）</li>
</ul>
<h3>插入记录（一）</h3>
<p><strong>描述</strong>：牛客后台会记录每个用户的试卷作答记录到 <code>exam_record</code> 表，现在有两个用户的作答记录详情如下：</p>
<ul>
<li>用户 1001 在 2021 年 9 月 1 日晚上 10 点 11 分 12 秒开始作答试卷 9001，并在 50 分钟后提交，得了 90 分；</li>
<li>用户 1002 在 2021 年 9 月 4 日上午 7 点 1 分 2 秒开始作答试卷 9002，并在 10 分钟后退出了平台。</li>
</ul>
<p>试卷作答记录表<code>exam_record</code>中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。</p>
<p>| Filed       | Type       | Null | Key | Extra          | Default | Comment  |<br>
|</p>
]]></content>
    <category term="数据库"/>
    <published>2023-07-13T14:23:50.000Z</published>
  </entry>
  <entry>
    <title type="text">SQL常见面试题总结（3）</title>
    <id>https://javaguide.cn/learning/database/sql/sql-questions-03.html</id>
    <link href="https://javaguide.cn/learning/database/sql/sql-questions-03.html"/>
    <updated>2024-01-13T06:48:32.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>聚合函数</h2>
<h3>SQL 类别高难度试卷得分的截断平均值（较难）</h3>
<p><strong>描述</strong>： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>聚合函数</h2>
<h3>SQL 类别高难度试卷得分的截断平均值（较难）</h3>
<p><strong>描述</strong>： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。</p>
<p>请你帮她从<code>exam_record</code>数据表中计算所有用户完成 SQL 类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。</p>
<p>示例数据：<code>examination_info</code>（<code>exam_id</code> 试卷 ID, tag 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）</p>
<p>| id  | exam_id | tag  | difficulty | duration | release_time        |<br>
|</p>
]]></content>
    <category term="数据库"/>
    <published>2023-07-13T14:23:50.000Z</published>
  </entry>
  <entry>
    <title type="text">SQL常见面试题总结（4）</title>
    <id>https://javaguide.cn/learning/database/sql/sql-questions-04.html</id>
    <link href="https://javaguide.cn/learning/database/sql/sql-questions-04.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>专用窗口函数</h2>
<p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：</p>
]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>专用窗口函数</h2>
<p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：</p>
<ol>
<li><code>ROW_NUMBER()</code>: 为查询结果集中的每一行分配一个唯一的整数值。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> row_num
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2">
<li><code>RANK()</code>: 计算每一行在排序结果中的排名。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="3">
<li><code>DENSE_RANK()</code>: 计算每一行在排序结果中的排名，保留相同的排名。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> DENSE_RANK<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1 <span class="token keyword">DESC</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> ranking
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="4">
<li><code>NTILE(n)</code>: 将结果分成 n 个基本均匀的桶，并为每个桶分配一个标识号。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> NTILE<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> bucket
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="5">
<li><code>SUM()</code>, <code>AVG()</code>,<code>COUNT()</code>, <code>MIN()</code>, <code>MAX()</code>: 这些聚合函数也可以与窗口函数结合使用，计算窗口内指定列的汇总、平均值、计数、最小值和最大值。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>col1<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> sum_col
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="6">
<li><code>LEAD()</code> 和 <code>LAG()</code>: LEAD 函数用于获取当前行之后的某个偏移量的行的值，而 LAG 函数用于获取当前行之前的某个偏移量的行的值。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> LEAD<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> next_col1<span class="token punctuation">,</span>
                 LAG<span class="token punctuation">(</span>col1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col1<span class="token punctuation">)</span> <span class="token keyword">AS</span> prev_col1
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><ol start="7">
<li><code>FIRST_VALUE()</code> 和 <code>LAST_VALUE()</code>: FIRST_VALUE 函数用于获取窗口内指定列的第一个值，LAST_VALUE 函数用于获取窗口内指定列的最后一个值。</li>
</ol>
<div class="language-sql" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> col1<span class="token punctuation">,</span> col2<span class="token punctuation">,</span> FIRST_VALUE<span class="token punctuation">(</span>col2<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> col1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col2<span class="token punctuation">)</span> <span class="token keyword">AS</span> first_val<span class="token punctuation">,</span>
                 LAST_VALUE<span class="token punctuation">(</span>col2<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> col1 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> col2<span class="token punctuation">)</span> <span class="token keyword">AS</span> last_val
<span class="token keyword">FROM</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
</code></pre></div><p>窗口函数通常需要配合 OVER 子句一起使用，用于定义窗口的大小、排序规则和分组方式。</p>
<h3>每类试卷得分前三名</h3>
<p><strong>描述</strong>：</p>
<p>现有试卷信息表 <code>examination_info</code>（<code>exam_id</code> 试卷 ID, <code>tag</code> 试卷类别, <code>difficulty</code> 试卷难度, <code>duration</code> 考试时长, <code>release_time</code> 发布时间）：</p>
<p>| id  | exam_id | tag  | difficulty | duration | release_time        |<br>
|</p>
]]></content>
    <category term="数据库"/>
    <published>2023-07-13T14:23:50.000Z</published>
  </entry>
  <entry>
    <title type="text">SQL常见面试题总结（5）</title>
    <id>https://javaguide.cn/learning/database/sql/sql-questions-05.html</id>
    <link href="https://javaguide.cn/learning/database/sql/sql-questions-05.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>空值处理</h2>
<h3>统计有未完成状态的试卷的未完成数和未完成率</h3>
<p><strong>描述</strong>：</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>题目来源于：<a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=240" target="_blank" rel="noopener noreferrer">牛客题霸 - SQL 进阶挑战</a></p>
</blockquote>
<p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。</p>
<h2>空值处理</h2>
<h3>统计有未完成状态的试卷的未完成数和未完成率</h3>
<p><strong>描述</strong>：</p>
<p>现有试卷作答记录表 <code>exam_record</code>（<code>uid</code> 用户 ID, <code>exam_id</code> 试卷 ID, <code>start_time</code> 开始作答时间, <code>submit_time</code> 交卷时间, <code>score</code> 得分），数据如下：</p>
<p>| id  | uid  | exam_id | start_time          | submit_time         | score  |<br>
|</p>
]]></content>
    <category term="数据库"/>
    <published>2023-07-13T14:23:50.000Z</published>
  </entry>
  <entry>
    <title type="text">LinkedHashMap 源码分析</title>
    <id>https://javaguide.cn/learning/java/collection/linkedhashmap-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/linkedhashmap-source-code.html"/>
    <updated>2024-04-01T14:21:25.000Z</updated>
    <summary type="html"><![CDATA[<h2>LinkedHashMap 简介</h2>
<p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，使得具备如下特性:</p>
<ol>
<li>支持遍历时会按照插入顺序有序进行迭代。</li>
<li>支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。</li>
<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<h2>LinkedHashMap 简介</h2>
<p><code>LinkedHashMap</code> 是 Java 提供的一个集合类，它继承自 <code>HashMap</code>，并在 <code>HashMap</code> 基础上维护一条双向链表，使得具备如下特性:</p>
<ol>
<li>支持遍历时会按照插入顺序有序进行迭代。</li>
<li>支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。</li>
<li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。</li>
</ol>
<p><code>LinkedHashMap</code> 逻辑结构如下图所示，它是在 <code>HashMap</code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构" tabindex="0"><figcaption>LinkedHashMap 逻辑结构</figcaption></figure>
<h2>LinkedHashMap 使用示例</h2>
<h3>插入顺序遍历</h3>
<p>如下所示，我们按照顺序往 <code>LinkedHashMap</code> 添加元素然后进行遍历。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">HashMap</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span> <span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"g"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"e"</span><span class="token punctuation">,</span> <span class="token string">"23"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span> <span class="token punctuation">&gt;</span></span> entry<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code>a<span class="token operator">:</span><span class="token number">2</span>
g<span class="token operator">:</span><span class="token number">3</span>
r<span class="token operator">:</span><span class="token number">1</span>
e<span class="token operator">:</span><span class="token number">23</span>
</code></pre></div><p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和插入顺序一致的,这一点是 <code>HashMap</code> 所不具备的。</p>
<h3>访问顺序遍历</h3>
<p><code>LinkedHashMap</code> 定义了排序模式 <code>accessOrder</code>(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。</p>
<p>为了实现访问顺序遍历，我们可以使用传入 <code>accessOrder</code> 属性的 <code>LinkedHashMap</code> 构造方法，并将 <code>accessOrder</code> 设置为 true，表示其具备访问有序性。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//访问元素2,该元素会被移动至链表末端</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//访问元素3,该元素会被移动至链表末端</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token number">1</span> <span class="token operator">:</span> one
<span class="token number">4</span> <span class="token operator">:</span> four
<span class="token number">5</span> <span class="token operator">:</span> five
<span class="token number">2</span> <span class="token operator">:</span> two
<span class="token number">3</span> <span class="token operator">:</span> three
</code></pre></div><p>可以看出，<code>LinkedHashMap</code> 的迭代顺序是和访问顺序一致的。</p>
<h3>LRU 缓存</h3>
<p>从上一个我们可以了解到通过 <code>LinkedHashMap</code> 我们可以封装一个简易版的 LRU（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/lru-cache.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>具体实现思路如下：</p>
<ul>
<li>继承 <code>LinkedHashMap</code>;</li>
<li>构造方法中指定 <code>accessOrder</code> 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>
<li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 <code>LinkedHashMap</code> 是否需要移除链表首元素（缓存容量有限）。</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>测试代码如下，笔者初始化缓存容量为 3，然后按照次序先后添加 4 个元素。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LRUCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">null</span>
<span class="token keyword">null</span>
three
four
five
</code></pre></div><p>从输出结果来看，由于缓存容量为 3 ，因此，添加第 4 个元素时，第 1 个元素会被删除。添加第 5 个元素时，第 2 个元素会被删除。</p>
<h2>LinkedHashMap 源码解析</h2>
<h3>Node 的设计</h3>
<p>在正式讨论 <code>LinkedHashMap</code> 前，我们先来聊聊 <code>LinkedHashMap</code> 节点 <code>Entry</code> 的设计,我们都知道 <code>HashMap</code> 的 bucket 上的因为冲突转为链表的节点会在符合以下两个条件时会将链表转为红黑树:</p>
<ol>
<li><s>链表上的节点个数达到树化的阈值 7，即<code>TREEIFY_THRESHOLD - 1</code>。</s></li>
<li>bucket 的容量达到最小的树化容量即<code>MIN_TREEIFY_CAPACITY</code>。</li>
</ol>
<blockquote>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/2147" target="_blank" rel="noopener noreferrer">issue#2147</a>）</strong>：</p>
<p>链表上的节点个数达到树化的阈值是 8 而非 7。因为源码的判断是从链表初始元素开始遍历，下标是从 0 开始的，所以判断条件设置为 8-1=7，其实是迭代到尾部元素时再判断整个链表长度大于等于 8 才进行树化操作。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/LinkedHashMap-putval-TREEIFY.png" alt="" tabindex="0"><figcaption></figcaption></figure>
</blockquote>
<p>而 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 <code>TreeNode</code> 的设计就是一个比较棘手的问题。</p>
<p>对此我们不妨来看看两者之间节点类的类图，可以看到:</p>
<ol>
<li><code>LinkedHashMap</code> 的节点内部类 <code>Entry</code> 基于 <code>HashMap</code> 的基础上，增加 <code>before</code> 和 <code>after</code> 指针使节点具备双向链表的特性。</li>
<li><code>HashMap</code> 的树节点 <code>TreeNode</code> 继承了具备双向链表特性的 <code>LinkedHashMap</code> 的 <code>Entry</code>。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/map-hashmap-linkedhashmap.png" alt="LinkedHashMap 和 HashMap 之间的关系" tabindex="0"><figcaption>LinkedHashMap 和 HashMap 之间的关系</figcaption></figure>
<p>很多读者此时就会有这样一个疑问，为什么 <code>HashMap</code> 的树节点 <code>TreeNode</code> 要通过 <code>LinkedHashMap</code> 获取双向链表的特性呢?为什么不直接在 <code>Node</code> 上实现前驱和后继指针呢?</p>
<p>先来回答第一个问题，我们都知道 <code>LinkedHashMap</code> 是在 <code>HashMap</code> 基础上对节点增加双向指针实现双向链表的特性,所以 <code>LinkedHashMap</code> 内部链表转红黑树时，对应的节点会转为树节点 <code>TreeNode</code>,为了保证使用 <code>LinkedHashMap</code> 时树节点具备双向链表的特性，所以树节点 <code>TreeNode</code> 需要继承 <code>LinkedHashMap</code> 的 <code>Entry</code>。</p>
<p>再来说说第二个问题，我们直接在 <code>HashMap</code> 的节点 <code>Node</code> 上直接实现前驱和后继指针,然后 <code>TreeNode</code> 直接继承 <code>Node</code> 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 <code>HashMap</code> 时存储键值对的节点类 <code>Node</code> 多了两个没有必要的引用，占用没必要的内存空间。</p>
<p>所以，为了保证 <code>HashMap</code> 底层的节点类 <code>Node</code> 没有多余的引用，又要保证 <code>LinkedHashMap</code> 的节点类 <code>Entry</code> 拥有存储链表的引用，设计者就让 <code>LinkedHashMap</code> 的节点 <code>Entry</code> 去继承 Node 并增加存储前驱后继节点的引用 <code>before</code>、<code>after</code>，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 <code>TreeNode</code> 再通过继承 <code>Entry</code> 获取 <code>before</code>、<code>after</code> 两个指针。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>但是这样做，不也使得使用 <code>HashMap</code> 时的 <code>TreeNode</code> 多了两个没有必要的引用吗?这不也是一种空间的浪费吗？</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token comment">//略</span>

<span class="token punctuation">}</span>
</code></pre></div><p>对于这个问题,引用作者的一段注释，作者们认为在良好的 <code>hashCode</code> 算法时，<code>HashMap</code> 转红黑树的概率不大。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Because TreeNodes are about twice the size of regular nodes, we
use them only when bins contain enough nodes to warrant use
<span class="token punctuation">(</span>see TREEIFY_THRESHOLD<span class="token punctuation">)</span>. And when they become too small <span class="token punctuation">(</span>due to
removal or resizing<span class="token punctuation">)</span> they are converted back to plain bins.  In
usages with well-distributed user hashCodes, tree bins are
rarely used.  Ideally, under random hashCodes, the frequency of
nodes <span class="token keyword">in</span> bins follows a Poisson distribution
</code></pre></div><h3>构造方法</h3>
<p><code>LinkedHashMap</code> 构造方法有 4 个实现也比较简单，直接调用父类即 <code>HashMap</code> 的构造方法完成初始化。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    accessOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
    <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>
    <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们上面也提到了，默认情况下 <code>accessOrder</code> 为 false，如果我们要让 <code>LinkedHashMap</code> 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 <code>accessOrder</code> 设置为 true。</p>
<h3>get 方法</h3>
<p><code>get</code> 方法是 <code>LinkedHashMap</code> 增删改查操作中唯一一个重写的方法， <code>accessOrder</code> 为 true 的情况下， 它会在元素查询完成之后，将当前访问的元素移到链表的末尾。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
     <span class="token comment">//获取key的键值对,若为空直接返回</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
     <span class="token comment">//若accessOrder为true，则调用afterNodeAccess将当前元素移到链表末尾</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
         <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//返回键值对的值</span>
     <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>从源码可以看出，<code>get</code> 的执行步骤非常简单:</p>
<ol>
<li>调用父类即 <code>HashMap</code> 的 <code>getNode</code> 获取键值对，若为空则直接返回。</li>
<li>判断 <code>accessOrder</code> 是否为 true，若为 true 则说明需要保证 <code>LinkedHashMap</code> 的链表访问有序性，执行步骤 3。</li>
<li>调用 <code>LinkedHashMap</code> 重写的 <code>afterNodeAccess</code> 将当前元素添加到链表末尾。</li>
</ol>
<p>关键点在于 <code>afterNodeAccess</code> 方法的实现，这个方法负责将元素移动到链表末尾。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// move node to last</span>
    <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> last<span class="token punctuation">;</span>
    <span class="token comment">//如果accessOrder 且当前节点不未链表尾节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>last <span class="token operator">=</span> tail<span class="token punctuation">)</span> <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token comment">//获取当前节点、以及前驱节点和后继节点</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">)</span> e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>

        <span class="token comment">//将当前节点的后继节点指针指向空，使其和后继节点断开联系</span>
        p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

        <span class="token comment">//如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">//如果后继节点不为空，则让前驱节点指向后继节点</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>

        <span class="token comment">//如果后继节点不为空，则让后继节点指向前驱节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">//如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null</span>
            last <span class="token operator">=</span> b<span class="token punctuation">;</span>

        <span class="token comment">//如果last为空，则说明当前链表只有一个节点p，则将head指向p</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p</span>
            p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
            last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//tail指向p，自此将节点p移动到链表末尾</span>
        tail <span class="token operator">=</span> p<span class="token punctuation">;</span>

        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从源码可以看出， <code>afterNodeAccess</code> 方法完成了下面这些操作:</p>
<ol>
<li>如果 <code>accessOrder</code> 为 true 且链表尾部不为当前节点 p，我们则需要将当前节点移到链表尾部。</li>
<li>获取当前节点 p、以及它的前驱节点 b 和后继节点 a。</li>
<li>将当前节点 p 的后继指针设置为 null，使其和后继节点 p 断开联系。</li>
<li>尝试将前驱节点指向后继节点，若前驱节点为空，则说明当前节点 p 就是链表首节点，故直接将后继节点 a 设置为首节点，随后我们再将 p 追加到 a 的末尾。</li>
<li>再尝试让后继节点 a 指向前驱节点 b。</li>
<li>上述操作让前驱节点和后继节点完成关联，并将当前节点 p 独立出来，这一步则是将当前节点 p 追加到链表末端，如果链表末端为空，则说明当前链表只有一个节点 p，所以直接让 head 指向 p 即可。</li>
<li>上述操作已经将 p 成功到达链表末端，最后我们将 tail 指针即指向链表末端的指针指向 p 即可。</li>
</ol>
<p>可以结合这张图理解，展示了 key 为 13 的元素被移动到了链表尾部。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-get.png" alt="LinkedHashMap 移动元素 13 到链表尾部" tabindex="0"><figcaption>LinkedHashMap 移动元素 13 到链表尾部</figcaption></figure>
<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>
<h3>remove 方法后置操作——afterNodeRemoval</h3>
<p><code>LinkedHashMap</code> 并没有对 <code>remove</code> 方法进行重写，而是直接继承 <code>HashMap</code> 的 <code>remove</code> 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，<code>LinkedHashMap</code> 重写了 <code>HashMap</code> 的空实现方法 <code>afterNodeRemoval</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">,</span>
                               <span class="token keyword">boolean</span> matchValue<span class="token punctuation">,</span> <span class="token keyword">boolean</span> movable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//略</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>matchValue <span class="token operator">||</span> <span class="token punctuation">(</span>v <span class="token operator">=</span> node<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> value <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeTreeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> movable<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> p<span class="token punctuation">)</span>
                    tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">else</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
                <span class="token operator">--</span>size<span class="token punctuation">;</span>
                <span class="token comment">//HashMap的removeNode完成元素移除后会调用afterNodeRemoval进行移除后置操作</span>
                <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> node<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token comment">//空实现</span>
<span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到从 <code>HashMap</code> 继承来的 <code>remove</code> 方法内部调用的 <code>removeNode</code> 方法将节点从 bucket 删除后，调用了 <code>afterNodeRemoval</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">afterNodeRemoval</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// unlink</span>

    <span class="token comment">//获取当前节点p、以及e的前驱节点b和后继节点a</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
            <span class="token punctuation">(</span><span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">,</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>before<span class="token punctuation">,</span> a <span class="token operator">=</span> p<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
    <span class="token comment">//将p的前驱和后继指针都设置为null，使其和前驱、后继节点断开联系</span>
        p<span class="token punctuation">.</span>before <span class="token operator">=</span> p<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">//如果前驱节点为空，则说明当前节点p是链表首节点，让head指针指向后继节点a即可</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            head <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token comment">//如果前驱节点b不为空，则让b直接指向后继节点a</span>
            b<span class="token punctuation">.</span>after <span class="token operator">=</span> a<span class="token punctuation">;</span>

    <span class="token comment">//如果后继节点为空，则说明当前节点p在链表末端，所以直接让tail指针指向前驱节点a即可</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            tail <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token comment">//反之后继节点的前驱指针直接指向前驱节点</span>
            a<span class="token punctuation">.</span>before <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>从源码可以看出， <code>afterNodeRemoval</code> 方法的整体操作就是让当前节点 p 和前驱节点、后继节点断开联系，等待 gc 回收，整体步骤为:</p>
<ol>
<li>获取当前节点 p、以及 e 的前驱节点 b 和后继节点 a。</li>
<li>让当前节点 p 和其前驱、后继节点断开联系。</li>
<li>尝试让前驱节点 b 指向后继节点 a，若 b 为空则说明当前节点 p 在链表首部，我们直接将 head 指向后继节点 a 即可。</li>
<li>尝试让后继节点 a 指向前驱节点 b，若 a 为空则说明当前节点 p 在链表末端，所以直接让 tail 指针指向前驱节点 a 即可。</li>
</ol>
<p>可以结合这张图理解，展示了 key 为 13 的元素被删除，也就是从链表中移除了这个元素。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-remove.png" alt="LinkedHashMap 删除元素 13" tabindex="0"><figcaption>LinkedHashMap 删除元素 13</figcaption></figure>
<p>看不太懂也没关系，知道这个方法的作用就够了，后续有时间再慢慢消化。</p>
<h3>put 方法后置操作——afterNodeInsertion</h3>
<p>同样的 <code>LinkedHashMap</code> 并没有实现插入方法，而是直接继承 <code>HashMap</code> 的所有插入方法交由用户使用，但为了维护双向链表访问的有序性，它做了这样两件事:</p>
<ol>
<li>重写 <code>afterNodeAccess</code>(上文提到过),如果当前被插入的 key 已存在与 <code>map</code> 中，因为 <code>LinkedHashMap</code> 的插入操作会将新节点追加至链表末尾，所以对于存在的 key 则调用 <code>afterNodeAccess</code> 将其放到链表末端。</li>
<li>重写了 <code>HashMap</code> 的 <code>afterNodeInsertion</code> 方法，当 <code>removeEldestEntry</code> 返回 true 时，会将链表首节点移除。</li>
</ol>
<p>这一点我们可以在 <code>HashMap</code> 的插入操作核心方法 <code>putVal</code> 中看到。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">//略</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// existing mapping for key</span>
                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                 <span class="token comment">//如果当前的key在map中存在，则调用afterNodeAccess</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">//调用插入后置方法，该方法被LinkedHashMap重写</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>上述步骤的源码上文已经解释过了，所以这里我们着重了解一下 <code>afterNodeInsertion</code> 的工作流程，假设我们的重写了 <code>removeEldestEntry</code>，当链表 <code>size</code> 超过 <code>capacity</code> 时，就返回 true。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
 */</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以下图为例，假设笔者最后新插入了一个不存在的节点 19,假设 <code>capacity</code> 为 4，所以 <code>removeEldestEntry</code> 返回 true，我们要将链表首节点移除。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-1.png" alt="LinkedHashMap 中插入新元素 19" tabindex="0"><figcaption>LinkedHashMap 中插入新元素 19</figcaption></figure>
<p>移除的步骤很简单，查看链表首节点是否存在，若存在则断开首节点和后继节点的关系，并让首节点指针指向下一节点，所以 head 指针指向了 12，节点 10 成为没有任何引用指向的空对象，等待 GC。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedhashmap-after-insert-2.png" alt="LinkedHashMap 中插入新元素 19" tabindex="0"><figcaption>LinkedHashMap 中插入新元素 19</figcaption></figure>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// possibly remove eldest</span>
        <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
        <span class="token comment">//如果evict为true且队首元素不为空以及removeEldestEntry返回true，则说明我们需要最老的元素(即在链表首部的元素)移除。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">//获取链表首部的键值对的key</span>
            <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
            <span class="token comment">//调用removeNode将元素从HashMap的bucket中移除，并和LinkedHashMap的双向链表断开，等待gc回收</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>从源码可以看出， <code>afterNodeInsertion</code> 方法完成了下面这些操作:</p>
<ol>
<li>判断 <code>eldest</code> 是否为 true，只有为 true 才能说明可能需要将最年长的键值对(即链表首部的元素)进行移除，具体是否具体要进行移除，还得确定链表是否为空<code>((first = head) != null)</code>，以及 <code>removeEldestEntry</code> 方法是否返回 true，只有这两个方法返回 true 才能确定当前链表不为空，且链表需要进行移除操作了。</li>
<li>获取链表第一个元素的 key。</li>
<li>调用 <code>HashMap</code> 的 <code>removeNode</code> 方法，该方法我们上文提到过，它会将节点从 <code>HashMap</code> 的 bucket 中移除，并且 <code>LinkedHashMap</code> 还重写了 <code>removeNode</code> 中的 <code>afterNodeRemoval</code> 方法，所以这一步将通过调用 <code>removeNode</code> 将元素从 <code>HashMap</code> 的 bucket 中移除，并和 <code>LinkedHashMap</code> 的双向链表断开，等待 gc 回收。</li>
</ol>
<h2>LinkedHashMap 和 HashMap 遍历性能比较</h2>
<p><code>LinkedHashMap</code> 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 <code>HashMap</code> 那种遍历整个 bucket 的方式来说，高效需多。</p>
<p>这一点我们可以从两者的迭代器中得以印证，先来看看 <code>HashMap</code> 的迭代器，可以看到 <code>HashMap</code> 迭代键值对时会用到一个 <code>nextNode</code> 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">EntryIterator</span> <span class="token keyword">extends</span> <span class="token class-name">HashIterator</span>
 <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span>
     <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token comment">//获取下一个Node</span>
 <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">[</span><span class="token punctuation">]</span> t<span class="token punctuation">;</span>
     <span class="token comment">//获取下一个元素next</span>
     <span class="token class-name">Node</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//将next指向bucket中下一个不为空的Node</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>current <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>next <span class="token operator">=</span> t<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> e<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>相比之下 <code>LinkedHashMap</code> 的迭代器则是直接使用通过 <code>after</code> 指针快速定位到当前节点的后继节点，简洁高效需多。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">LinkedEntryIterator</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashIterator</span>
 <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span>
     <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
 <span class="token comment">//获取下一个Node</span>
 <span class="token keyword">final</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//获取下一个节点next</span>
     <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span> <span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//current 指针指向当前节点</span>
     current <span class="token operator">=</span> e<span class="token punctuation">;</span>
     <span class="token comment">//next直接当前节点的after指针快速定位到下一个节点</span>
     next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
     <span class="token keyword">return</span> e<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>为了验证笔者所说的观点，笔者对这两个容器进行了压测，测试插入 1000w 和迭代 1000w 条数据的耗时，代码如下:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1000_0000</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> linkedHashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">long</span> start<span class="token punctuation">,</span> end<span class="token punctuation">;</span>

start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    hashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map time putVal: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    linkedHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"linkedHashMap putVal time: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> v <span class="token operator">:</span> hashMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> num <span class="token operator">+</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map get time: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> v <span class="token operator">:</span> linkedHashMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> num <span class="token operator">+</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"linkedHashMap get time: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从输出结果来看，因为 <code>LinkedHashMap</code> 需要维护双向链表的缘故，插入元素相较于 <code>HashMap</code> 会更耗时，但是有了双向链表明确的前后节点关系，迭代效率相对于前者高效了需多。不过，总体来说却别不大，毕竟数据量这么庞大。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>map <span class="token function">time</span> putVal: <span class="token number">5880</span>
linkedHashMap putVal time: <span class="token number">7567</span>
map get time: <span class="token number">143</span>
linkedHashMap get time: <span class="token number">67</span>
<span class="token number">63208969074998</span>
</code></pre></div><h2>LinkedHashMap 常见面试题</h2>
<h3>什么是 LinkedHashMap？</h3>
<p><code>LinkedHashMap</code> 是 Java 集合框架中 <code>HashMap</code> 的一个子类，它继承了 <code>HashMap</code> 的所有属性和方法，并且在 <code>HashMap</code> 的基础重写了 <code>afterNodeRemoval</code>、<code>afterNodeInsertion</code>、<code>afterNodeAccess</code> 方法。使之拥有顺序插入和访问有序的特性。</p>
<h3>LinkedHashMap 如何按照插入顺序迭代元素？</h3>
<p><code>LinkedHashMap</code> 按照插入顺序迭代元素是它的默认行为。<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序。因此，当使用迭代器迭代元素时，元素的顺序与它们最初插入的顺序相同。</p>
<h3>LinkedHashMap 如何按照访问顺序迭代元素？</h3>
<p><code>LinkedHashMap</code> 可以通过构造函数中的 <code>accessOrder</code> 参数指定按照访问顺序迭代元素。当 <code>accessOrder</code> 为 true 时，每次访问一个元素时，该元素会被移动到链表的末尾，因此下次访问该元素时，它就会成为链表中的最后一个元素，从而实现按照访问顺序迭代元素。</p>
<h3>LinkedHashMap 如何实现 LRU 缓存？</h3>
<p>将 <code>accessOrder</code> 设置为 true 并重写 <code>removeEldestEntry</code> 方法当链表大小超过容量时返回 true，使得每次访问一个元素时，该元素会被移动到链表的末尾。一旦插入操作让 <code>removeEldestEntry</code> 返回 true 时，视为缓存已满，<code>LinkedHashMap</code> 就会将链表首元素移除，由此我们就能实现一个 LRU 缓存。</p>
<h3>LinkedHashMap 和 HashMap 有什么区别？</h3>
<p><code>LinkedHashMap</code> 和 <code>HashMap</code> 都是 Java 集合框架中的 Map 接口的实现类。它们的最大区别在于迭代元素的顺序。<code>HashMap</code> 迭代元素的顺序是不确定的，而 <code>LinkedHashMap</code> 提供了按照插入顺序或访问顺序迭代元素的功能。此外，<code>LinkedHashMap</code> 内部维护了一个双向链表，用于记录元素的插入顺序或访问顺序，而 <code>HashMap</code> 则没有这个链表。因此，<code>LinkedHashMap</code> 的插入性能可能会比 <code>HashMap</code> 略低，但它提供了更多的功能并且迭代效率相较于 <code>HashMap</code> 更加高效。</p>
<h2>参考文献</h2>
<ul>
<li>LinkedHashMap 源码详细分析（JDK1.8）:<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener noreferrer">https://www.imooc.com/article/22931</a></li>
<li>HashMap 与 LinkedHashMap:<a href="https://www.cnblogs.com/Spground/p/8536148.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Spground/p/8536148.html</a></li>
<li>源于 LinkedHashMap 源码: <a href="https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-07-11T13:02:50.000Z</published>
  </entry>
  <entry>
    <title type="text">DelayQueue 源码分析</title>
    <id>https://javaguide.cn/learning/java/collection/delayqueue-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/delayqueue-source-code.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>DelayQueue 简介</h2>
<p><code>DelayQueue</code> 是 JUC 包(<code>java.util.concurrent)</code>为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 <code>BlockingQueue</code> 的一种，底层是一个基于 <code>PriorityQueue</code> 实现的一个无界队列，是线程安全的。关于<code>PriorityQueue</code>可以参考笔者编写的这篇文章：<a href="/learning/java/collection/priorityqueue-source-code.html" target="_blank">PriorityQueue 源码分析</a> 。</p>]]></summary>
    <content type="html"><![CDATA[<h2>DelayQueue 简介</h2>
<p><code>DelayQueue</code> 是 JUC 包(<code>java.util.concurrent)</code>为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 <code>BlockingQueue</code> 的一种，底层是一个基于 <code>PriorityQueue</code> 实现的一个无界队列，是线程安全的。关于<code>PriorityQueue</code>可以参考笔者编写的这篇文章：<a href="/learning/java/collection/priorityqueue-source-code.html" target="_blank">PriorityQueue 源码分析</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png" alt="BlockingQueue 的实现类" tabindex="0"><figcaption>BlockingQueue 的实现类</figcaption></figure>
<p><code>DelayQueue</code> 中存放的元素必须实现 <code>Delayed</code> 接口，并且需要重写 <code>getDelay()</code>方法（计算是否到期）。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Delayed</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Delayed</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>默认情况下, <code>DelayQueue</code> 会按照到期时间升序编排任务。只有当元素过期时（<code>getDelay()</code>方法返回值小于等于 0），才能从队列中取出。</p>
<h2>DelayQueue 发展史</h2>
<ul>
<li><code>DelayQueue</code> 最早是在 Java 5 中引入的，作为 <code>java.util.concurrent</code> 包中的一部分，用于支持基于时间的任务调度和缓存过期删除等场景，该版本仅仅支持延迟功能的实现，还未解决线程安全问题。</li>
<li>在 Java 6 中，<code>DelayQueue</code> 的实现进行了优化，通过使用 <code>ReentrantLock</code> 和 <code>Condition</code> 解决线程安全及线程间交互的效率，提高了其性能和可靠性。</li>
<li>在 Java 7 中，<code>DelayQueue</code> 的实现进行了进一步的优化，通过使用 CAS 操作实现元素的添加和移除操作，提高了其并发操作性能。</li>
<li>在 Java 8 中，<code>DelayQueue</code> 的实现没有进行重大变化，但是在 <code>java.time</code> 包中引入了新的时间类，如 <code>Duration</code> 和 <code>Instant</code>，使得使用 <code>DelayQueue</code> 进行基于时间的调度更加方便和灵活。</li>
<li>在 Java 9 中，<code>DelayQueue</code> 的实现进行了一些微小的改进，主要是对代码进行了一些优化和精简。</li>
</ul>
<p>总的来说，<code>DelayQueue</code> 的发展史主要是通过优化其实现方式和提高其性能和可靠性，使其更加适用于基于时间的调度和缓存过期删除等场景。</p>
<h2>DelayQueue 常见使用场景示例</h2>
<p>我们这里希望任务可以按照我们预期的时间执行，例如提交 3 个任务，分别要求 1s、2s、3s 后执行，即使是乱序添加，1s 后要求 1s 执行的任务会准时执行。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/delayed-task.png" alt="延迟任务" tabindex="0"><figcaption>延迟任务</figcaption></figure>
<p>对此我们可以使用 <code>DelayQueue</code> 来实现,所以我们首先需要继承 <code>Delayed</code> 实现 <code>DelayedTask</code>，实现 <code>getDelay</code> 方法以及优先级比较 <code>compareTo</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 延迟任务
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayedTask</span> <span class="token keyword">implements</span> <span class="token class-name">Delayed</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/**
     * 任务到期时间
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> executeTime<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/**
     * 任务
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Runnable</span> task<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token keyword">long</span> delay<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>executeTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delay<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 查看当前任务还有多久到期
     * <span class="token keyword">@param</span> <span class="token parameter">unit</span>
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>executeTime <span class="token operator">-</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 延迟队列需要到期时间升序入队，所以我们需要实现compareTo进行到期时间比较
     * <span class="token keyword">@param</span> <span class="token parameter">o</span>
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Delayed</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>executeTime<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">DelayedTask</span><span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span>executeTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>完成任务的封装之后，使用就很简单了，设置好多久到期然后将任务提交到延迟队列中即可。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建延迟队列，并添加任务</span>
<span class="token class-name">DelayQueue</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token class-name">DelayedTask</span> <span class="token punctuation">&gt;</span></span> delayQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueue</span> <span class="token generics"><span class="token punctuation">&lt;</span> <span class="token punctuation">&gt;</span></span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//分别添加1s、2s、3s到期的任务</span>
delayQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task 2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
delayQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task 1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
delayQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedTask</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Task 3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 取出任务并执行</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>delayQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//阻塞获取最先到期的任务</span>
  <span class="token class-name">DelayedTask</span> task <span class="token operator">=</span> delayQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    task<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从输出结果可以看出，即使笔者先提到 2s 到期的任务，1s 到期的任务 Task1 还是优先执行的。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Task</span> <span class="token number">1</span>
<span class="token class-name">Task</span> <span class="token number">2</span>
<span class="token class-name">Task</span> <span class="token number">3</span>
</code></pre></div><h2>DelayQueue 源码解析</h2>
<p>这里以 JDK1.8 为例，分析一下 <code>DelayQueue</code> 的底层核心源码。</p>
<p><code>DelayQueue</code> 的类定义如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">Delayed</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>DelayQueue</code> 继承了 <code>AbstractQueue</code> 类，实现了 <code>BlockingQueue</code> 接口。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-class-diagram.png" alt="DelayQueue类图" tabindex="0"><figcaption>DelayQueue类图</figcaption></figure>
<h3>核心成员变量</h3>
<p><code>DelayQueue</code> 的 4 个核心成员变量如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//可重入锁，实现线程安全的关键</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//延迟队列底层存储数据的集合,确保元素按照到期时间升序排列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//指向准备执行优先级最高的线程</span>
<span class="token keyword">private</span> <span class="token class-name">Thread</span> leader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">//实现多线程之间等待唤醒的交互</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> available <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul>
<li><code>lock</code> : 我们都知道 <code>DelayQueue</code> 存取是线程安全的，所以为了保证存取元素时线程安全，我们就需要在存取时上锁，而 <code>DelayQueue</code> 就是基于 <code>ReentrantLock</code> 独占锁确保存取操作的线程安全。</li>
<li><code>q</code> : 延迟队列要求元素按照到期时间进行升序排列，所以元素添加时势必需要进行优先级排序,所以 <code>DelayQueue</code> 底层元素的存取都是通过这个优先队列 <code>PriorityQueue</code> 的成员变量 <code>q</code> 来管理的。</li>
<li><code>leader</code> : 延迟队列的任务只有到期之后才会执行,对于没有到期的任务只有等待,为了确保优先级最高的任务到期后可以即刻被执行,设计者就用 <code>leader</code> 来管理延迟任务，只有 <code>leader</code> 所指向的线程才具备定时等待任务到期执行的权限，而其他那些优先级低的任务只能无限期等待，直到 <code>leader</code> 线程执行完手头的延迟任务后唤醒它。</li>
<li><code>available</code> : 上文讲述 <code>leader</code> 线程时提到的等待唤醒操作的交互就是通过 <code>available</code> 实现的，假如线程 1 尝试在空的 <code>DelayQueue</code> 获取任务时，<code>available</code> 就会将其放入等待队列中。直到有一个线程添加一个延迟任务后通过 <code>available</code> 的 <code>signal</code> 方法将其唤醒。</li>
</ul>
<h3>构造方法</h3>
<p>相较于其他的并发容器，延迟队列的构造方法比较简单，它只有两个构造方法，因为所有成员变量在类加载时都已经初始完成了，所以默认构造方法什么也没做。还有一个传入 <code>Collection</code> 对象的构造方法，它会将调用 <code>addAll()</code>方法将集合元素存到优先队列 <code>q</code> 中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">DelayQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">DelayQueue</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>添加元素</h3>
<p><code>DelayQueue</code> 添加元素的方法无论是 <code>add</code>、<code>put</code> 还是 <code>offer</code>,本质上就是调用一下 <code>offer</code> ,所以了解延迟队列的添加逻辑我们只需阅读 offer 方法即可。</p>
<p><code>offer</code> 方法的整体逻辑为:</p>
<ol>
<li>尝试获取 <code>lock</code> 。</li>
<li>如果上锁成功,则调 <code>q</code> 的 <code>offer</code> 方法将元素存放到优先队列中。</li>
<li>调用 <code>peek</code> 方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)，于是将 <code>leader</code> 设置为空,通知因为队列为空时调用 <code>take</code> 等方法导致阻塞的线程来争抢元素。</li>
<li>上述步骤执行完成，释放 <code>lock</code>。</li>
<li>返回 true。</li>
</ol>
<p>源码如下，笔者已详细注释，读者可自行参阅:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//尝试获取lock</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果上锁成功,则调q的offer方法将元素存放到优先队列中</span>
        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用peek方法看看当前队首元素是否就是本次入队的元素,如果是则说明当前这个元素是即将到期的任务(即优先级最高的元素)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//将leader设置为空,通知调用取元素方法而阻塞的线程来争抢这个任务</span>
            leader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">//上述步骤执行完成，释放lock</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>获取元素</h3>
<p><code>DelayQueue</code> 中获取元素的方式分为阻塞式和非阻塞式，先来看看逻辑比较复杂的阻塞式获取元素方法 <code>take</code>,为了让读者可以更直观的了解阻塞式获取元素的全流程，笔者将以 3 个线程并发获取元素为例讲述 <code>take</code> 的工作流程。</p>
<blockquote>
<p>想要理解下面的内容，需要用到 AQS 相关的知识，推荐阅读下面这两篇文章：</p>
<ul>
<li><a href="https://xie.infoq.cn/article/5a3cc0b709012d40cb9f41986" target="_blank" rel="noopener noreferrer">图文讲解 AQS ，一起看看 AQS 的源码……(图文较长)</a></li>
<li><a href="https://xie.infoq.cn/article/0223d5e5f19726b36b084b10d" target="_blank" rel="noopener noreferrer">AQS 都看完了，Condition 原理可不能少！</a></li>
</ul>
</blockquote>
<p>1、首先， 3 个线程会尝试获取可重入锁 <code>lock</code>,假设我们现在有 3 个线程分别是 t1、t2、t3,随后 t1 得到了锁，而 t2、t3 没有抢到锁，故将这两个线程存入等待队列中。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-0.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>2、紧接着 t1 开始进行元素获取的逻辑。</p>
<p>3、线程 t1 首先会查看 <code>DelayQueue</code> 队列首元素是否为空。</p>
<p>4、如果元素为空，则说明当前队列没有任何元素，故 t1 就会被阻塞存到 <code>conditionWaiter</code> 这个队列中。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-1.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>注意，调用 <code>await</code> 之后 t1 就会释放 <code>lcok</code> 锁，假如 <code>DelayQueue</code> 持续为空，那么 t2、t3 也会像 t1 一样执行相同的逻辑并进入 <code>conditionWaiter</code> 队列中。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/delayqueue-take-2.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如果元素不为空，则判断当前任务是否到期，如果元素到期，则直接返回出去。如果元素未到期，则判断当前 <code>leader</code> 线程(<code>DelayQueue</code> 中唯一一个可以等待并获取元素的线程引用)是否为空，若不为空，则说明当前 <code>leader</code> 正在等待执行一个优先级比当前元素还高的元素到期，故当前线程 t1 只能调用 <code>await</code> 进入无限期等待，等到 <code>leader</code> 取得元素后唤醒。反之，若 <code>leader</code> 线程为空，则将当前线程设置为 leader 并进入有限期等待,到期后取出元素并返回。</p>
<p>自此我们阻塞式获取元素的逻辑都已完成后,源码如下，读者可自行参阅:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试获取可重入锁,将底层AQS的state设置为1,并设置为独占锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//查看队列第一个元素</span>
            <span class="token class-name">E</span> first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//若为空,则将当前线程放入ConditionObject的等待队列中，并将底层AQS的state设置为0，表示释放锁并进入无限期等待</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">//若元素不为空，则查看当前元素多久到期</span>
                <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//如果小于0则说明已到期直接返回出去</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//如果大于0则说明任务还没到期，首先需要释放对这个元素的引用</span>
                first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// don't retain ref while waiting</span>
                <span class="token comment">//判断leader是否为空，如果不为空，则说明正有线程作为leader并等待一个任务到期，则当前线程进入无限期等待</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                    available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">//反之将我们的线程成为leader</span>
                    <span class="token class-name">Thread</span> thisThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    leader <span class="token operator">=</span> thisThread<span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token comment">//并进入有限期等待</span>
                        available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                        <span class="token comment">//等待任务到期时，释放leader引用，进入下一次循环将任务return出去</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> thisThread<span class="token punctuation">)</span>
                            leader <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 收尾逻辑:当leader为null，并且队列中有任务时，唤醒等待的获取元素的线程。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们再来看看非阻塞的获取元素方法 <code>poll</code> ，逻辑比较简单，整体步骤如下:</p>
<ol>
<li>尝试获取可重入锁。</li>
<li>查看队列第一个元素,判断元素是否为空。</li>
<li>若元素为空，或者元素未到期，则直接返回空。</li>
<li>若元素不为空且到期了，直接调用 <code>poll</code> 返回出去。</li>
<li>释放可重入锁 <code>lock</code> 。</li>
</ol>
<p>源码如下,读者可自行参阅源码及注释:</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//尝试获取可重入锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">//查看队列第一个元素,判断元素是否为空</span>
        <span class="token class-name">E</span> first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//若元素为空，或者元素未到期，则直接返回空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span><span class="token constant">NANOSECONDS</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">//若元素不为空且到期了，直接调用poll返回出去</span>
            <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">//释放可重入锁lock</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>查看元素</h3>
<p>上文获取元素时都会调用到 <code>peek</code> 方法，peek 顾名思义仅仅窥探一下队列中的元素，它的步骤就 4 步:</p>
<ol>
<li>上锁。</li>
<li>调用优先队列 q 的 peek 方法查看索引 0 位置的元素。</li>
<li>释放锁。</li>
<li>将元素返回出去。</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>DelayQueue 常见面试题</h2>
<h3>DelayQueue 的实现原理是什么？</h3>
<p><code>DelayQueue</code> 底层是使用优先队列 <code>PriorityQueue</code> 来存储元素，而 <code>PriorityQueue</code> 采用二叉小顶堆的思想确保值小的元素排在最前面，这就使得 <code>DelayQueue</code> 对于延迟任务优先级的管理就变得十分方便了。同时 <code>DelayQueue</code> 为了保证线程安全还用到了可重入锁 <code>ReentrantLock</code>,确保单位时间内只有一个线程可以操作延迟队列。最后，为了实现多线程之间等待和唤醒的交互效率，<code>DelayQueue</code> 还用到了 <code>Condition</code>，通过 <code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法完成多线程之间的等待唤醒。</p>
<h3>DelayQueue 的实现是否线程安全？</h3>
<p><code>DelayQueue</code> 的实现是线程安全的，它通过 <code>ReentrantLock</code> 实现了互斥访问和 <code>Condition</code> 实现了线程间的等待和唤醒操作，可以保证多线程环境下的安全性和可靠性。</p>
<h3>DelayQueue 的使用场景有哪些？</h3>
<p><code>DelayQueue</code> 通常用于实现定时任务调度和缓存过期删除等场景。在定时任务调度中，需要将需要执行的任务封装成延迟任务对象，并将其添加到 <code>DelayQueue</code> 中，<code>DelayQueue</code> 会自动按照剩余延迟时间进行升序排序(默认情况)，以保证任务能够按照时间先后顺序执行。对于缓存过期这个场景而言，在数据被缓存到内存之后，我们可以将缓存的 key 封装成一个延迟的删除任务，并将其添加到 <code>DelayQueue</code> 中，当数据过期时，拿到这个任务的 key，将这个 key 从内存中移除。</p>
<h3>DelayQueue 中 Delayed 接口的作用是什么？</h3>
<p><code>Delayed</code> 接口定义了元素的剩余延迟时间(<code>getDelay</code>)和元素之间的比较规则(该接口继承了 <code>Comparable</code> 接口)。若希望元素能够存放到 <code>DelayQueue</code> 中，就必须实现 <code>Delayed</code> 接口的 <code>getDelay()</code> 方法和 <code>compareTo()</code> 方法，否则 <code>DelayQueue</code> 无法得知当前任务剩余时长和任务优先级的比较。</p>
<h3>DelayQueue 和 Timer/TimerTask 的区别是什么？</h3>
<p><code>DelayQueue</code> 和 <code>Timer/TimerTask</code> 都可以用于实现定时任务调度，但是它们的实现方式不同。<code>DelayQueue</code> 是基于优先级队列和堆排序算法实现的，可以实现多个任务按照时间先后顺序执行；而 <code>Timer/TimerTask</code> 是基于单线程实现的，只能按照任务的执行顺序依次执行，如果某个任务执行时间过长，会影响其他任务的执行。另外，<code>DelayQueue</code> 还支持动态添加和移除任务，而 <code>Timer/TimerTask</code> 只能在创建时指定任务。</p>
<h2>参考文献</h2>
<ul>
<li>《深入理解高并发编程：JDK 核心技术》:</li>
<li>一口气说出 Java 6 种延时队列的实现方法(面试官也得服):<a href="https://www.jb51.net/article/186192.htm" target="_blank" rel="noopener noreferrer">https://www.jb51.net/article/186192.htm</a></li>
<li>图解 DelayQueue 源码（java 8）——延时队列的小九九: <a href="https://blog.csdn.net/every__day/article/details/113810985" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/every__day/article/details/113810985</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-06-30T11:46:59.000Z</published>
  </entry>
  <entry>
    <title type="text">PriorityQueue 源码分析（付费）</title>
    <id>https://javaguide.cn/learning/java/collection/priorityqueue-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/priorityqueue-source-code.html"/>
    <updated>2024-02-18T03:33:12.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>PriorityQueue 源码分析</strong> 为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/source-code-reading.html" target="_blank" rel="noopener noreferrer">《Java 必读源码系列》</a>中。</p>]]></summary>
    <content type="html"><![CDATA[<p><strong>PriorityQueue 源码分析</strong> 为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/source-code-reading.html" target="_blank" rel="noopener noreferrer">《Java 必读源码系列》</a>中。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20230727084055593.png" alt="PriorityQueue 源码分析" tabindex="0"><figcaption>PriorityQueue 源码分析</figcaption></figure>
<p><a href="/learning/zhuanlan/source-code-reading.html" target="_blank">《Java 必读源码系列》</a>（点击链接即可查看详细介绍）的部分内容展示如下。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20220621091832348.png" alt="《Java 必读源码系列》" tabindex="0"><figcaption>《Java 必读源码系列》</figcaption></figure>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>
<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiufuwu.png" alt="星球服务" tabindex="0"></a><figcaption>星球服务</figcaption></figure>
<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 知识星球详细介绍</a> 。</p>
<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg" alt="知识星球30元优惠卷" tabindex="0"><figcaption>知识星球30元优惠卷</figcaption></figure>
<p>进入星球之后，记得查看 <strong><a href="https://t.zsxq.com/0d18KSarv" target="_blank" rel="noopener noreferrer">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href="https://t.zsxq.com/12uSKgTIm" target="_blank" rel="noopener noreferrer">星球优质主题汇总</a></strong> 。</p>
<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>
<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-06-30T11:46:59.000Z</published>
  </entry>
  <entry>
    <title type="text">常见加密算法总结</title>
    <id>https://javaguide.cn/learning/system-design/security/encryption-algorithms.html</id>
    <link href="https://javaguide.cn/learning/system-design/security/encryption-algorithms.html"/>
    <updated>2024-04-11T13:27:43.000Z</updated>
    <summary type="html"><![CDATA[<p>加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。</p>
<p>日常开发中常见的需要用到加密算法的场景：</p>
<ol>
<li>保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。</li>
<li>保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。</li>
<li>网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。</li>
<li>……</li>
</ol>]]></summary>
    <content type="html"><![CDATA[<p>加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。</p>
<p>日常开发中常见的需要用到加密算法的场景：</p>
<ol>
<li>保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。</li>
<li>保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。</li>
<li>网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。</li>
<li>……</li>
</ol>
<p>ps: 严格上来说，哈希算法其实不属于加密算法，只是可以用到某些加密场景中（例如密码加密），两者可以看作是并列关系。加密算法通常指的是可以将明文转换为密文，并且能够通过某种方式（如密钥）再将密文还原为明文的算法。而哈希算法是一种单向过程，它将输入信息转换成一个固定长度的、看似随机的哈希值，但这个过程是不可逆的，也就是说，不能从哈希值还原出原始信息。</p>
<h2>哈希算法</h2>
<p>哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/hash-function-effect-demonstration.png" alt="哈希算法效果演示" tabindex="0"><figcaption>哈希算法效果演示</figcaption></figure>
<p>哈希算法的是不可逆的，你无法通过哈希之后的值再得到原值。</p>
<p>哈希值的作用是可以用来验证数据的完整性和一致性。</p>
<p>举两个实际的例子：</p>
<ul>
<li>保存密码到数据库时使用哈希算法进行加密，可以通过比较用户输入密码的哈希值和数据库保存的哈希值是否一致，来判断密码是否正确。</li>
<li>我们下载一个文件时，可以通过比较文件的哈希值和官方提供的哈希值是否一致，来判断文件是否被篡改或损坏；</li>
</ul>
<p>这种算法的特点是不可逆：</p>
<ul>
<li>不能从哈希值还原出原始数据。</li>
<li>原始数据的任何改变都会导致哈希值的巨大变化。</li>
</ul>
<p>哈希算法可以简单分为两类：</p>
<ol>
<li><strong>加密哈希算法</strong>：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。</li>
<li><strong>非加密哈希算法</strong>：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。</li>
</ol>
<p>除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的<strong>慢哈希算法</strong>。</p>
<p>常见的哈希算法有：</p>
<ul>
<li>MD（Message Digest，消息摘要算法）：MD2、MD4、MD5 等，已经不被推荐使用。</li>
<li>SHA（Secure Hash Algorithm，安全哈希算法）：SHA-1 系列安全性低，SHA2，SHA3 系列安全性较高。</li>
<li>国密算法：例如 SM2、SM3、SM4，其中 SM2 为非对称加密算法，SM4 为对称加密算法，SM3 为哈希算法（安全性及效率和 SHA-256 相当，但更适合国内的应用环境）。</li>
<li>Bcrypt（密码哈希算法）：基于 Blowfish 加密算法的密码哈希算法，专门为密码加密而设计，安全性高，属于慢哈希算法。</li>
<li>MAC（Message Authentication Code，消息认证码算法）：HMAC 是一种基于哈希的 MAC，可以与任何安全的哈希算法结合使用，例如 SHA-256。</li>
<li>CRC：（Cyclic Redundancy Check，循环冗余校验）：CRC32 是一种 CRC 算法，它的特点是生成 32 位的校验值，通常用于数据完整性校验、文件校验等场景。</li>
<li>SipHash：加密哈希算法，它的设计目的是在速度和安全性之间达到一个平衡，用于防御<a href="https://aumasson.jp/siphash/siphashdos_29c3_slides.pdf" target="_blank" rel="noopener noreferrer">哈希泛洪 DoS 攻击</a>。Rust 默认使用 SipHash 作为哈希算法，从 Redis4.0 开始，哈希算法被替换为 SipHash。</li>
<li>MurMurHash：经典快速的非加密哈希算法，目前最新的版本是 MurMurHash3，可以生成 32 位或者 128 位哈希值；</li>
<li>……</li>
</ul>
<p>哈希算法一般是不需要密钥的，但也存在部分特殊哈希算法需要密钥。例如，MAC 和 SipHash 就是一种基于密钥的哈希算法，它在哈希算法的基础上增加了一个密钥，使得只有知道密钥的人才能验证数据的完整性和来源。</p>
<h3>MD</h3>
<p>MD 算法有多个版本，包括 MD2、MD4、MD5 等，其中 MD5 是最常用的版本，它可以生成一个 128 位（16 字节）的哈希值。从安全性上说：MD5 &gt; MD4 &gt; MD2。除了这些版本，还有一些基于 MD4 或 MD5 改进的算法，如 RIPEMD、HAVAL 等。</p>
<p>即使是最安全 MD 算法 MD5 也存在被破解的风险，攻击者可以通过暴力破解或彩虹表攻击等方式，找到与原始数据相同的哈希值，从而破解数据。</p>
<p>为了增加破解难度，通常可以选择加盐。盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为“加盐”。</p>
<p>加盐之后就安全了吗？并不一定，这只是增加了破解难度，不代表无法破解。而且，MD5 算法本身就存在弱碰撞（Collision）问题，即多个不同的输入产生相同的 MD5 值。</p>
<p>因此，MD 算法已经不被推荐使用，建议使用更安全的哈希算法比如 SHA-2、Bcrypt。</p>
<p>Java 提供了对 MD 算法系列的支持，包括 MD2、MD5。</p>
<p>MD5 代码示例（未加盐）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> originalString <span class="token operator">=</span> <span class="token string">"Java学习 + 面试指南：javaguide.cn"</span><span class="token punctuation">;</span>
<span class="token comment">// 创建MD5摘要对象</span>
<span class="token class-name">MessageDigest</span> messageDigest <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messageDigest<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>originalString<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 计算哈希值</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> messageDigest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将哈希值转换为十六进制字符串</span>
<span class="token class-name">String</span> hexString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HexBinaryAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">marshal</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Original String: "</span> <span class="token operator">+</span> originalString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MD5 Hash: "</span> <span class="token operator">+</span> hexString<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Original String: Java学习 + 面试指南：javaguide.cn
MD5 Hash: fb246796f5b1b60d4d0268c817c608fa
</code></pre></div><h3>SHA</h3>
<p>SHA（Secure Hash Algorithm）系列算法是一组密码哈希算法，用于将任意长度的数据映射为固定长度的哈希值。SHA 系列算法由美国国家安全局（NSA）于 1993 年设计，目前共有 SHA-1、SHA-2、SHA-3 三种版本。</p>
<p>SHA-1 算法将任意长度的数据映射为 160 位的哈希值。然而，SHA-1 算法存在一些严重的缺陷，比如安全性低，容易受到碰撞攻击和长度扩展攻击。因此，SHA-1 算法已经不再被推荐使用。 SHA-2 家族（如 SHA-256、SHA-384、SHA-512 等）和 SHA-3 系列是 SHA-1 算法的替代方案，它们都提供了更高的安全性和更长的哈希值长度。</p>
<p>SHA-2 家族是在 SHA-1 算法的基础上改进而来的，它们采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。</p>
<p>为了寻找一种更安全和更先进的密码哈希算法，美国国家标准与技术研究院（National Institute of Standards and Technology，简称 NIST）在 2007 年公开征集 SHA-3 的候选算法。NIST 一共收到了 64 个算法方案，经过多轮的评估和筛选，最终在 2012 年宣布 Keccak 算法胜出，成为 SHA-3 的标准算法（SHA-3 与 SHA-2 算法没有直接的关系）。 Keccak 算法具有与 MD 和 SHA-1/2 完全不同的设计思路，即海绵结构（Sponge Construction），使得传统攻击方法无法直接应用于 SHA-3 的攻击中（能够抵抗目前已知的所有攻击方式包括碰撞攻击、长度扩展攻击、差分攻击等）。</p>
<p>由于 SHA-2 算法还没有出现重大的安全漏洞，而且在软件中的效率更高，所以大多数人还是倾向于使用 SHA-2 算法。</p>
<p>相比 MD5 算法，SHA-2 算法之所以更强，主要有两个原因：</p>
<ul>
<li>哈希值长度更长：例如 SHA-256 算法的哈希值长度为 256 位，而 MD5 算法的哈希值长度为 128 位，这就提高了攻击者暴力破解或者彩虹表攻击的难度。</li>
<li>更强的碰撞抗性：SHA 算法采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。目前还没有找到任何两个不同的数据，它们的 SHA-256 哈希值相同。</li>
</ul>
<p>当然，SHA-2 也不是绝对安全的，也有被暴力破解或者彩虹表攻击的风险，所以，在实际的应用中，加盐还是必不可少的。</p>
<p>Java 提供了对 SHA 算法系列的支持，包括 SHA-1、SHA-256、SHA-384 和 SHA-512。</p>
<p>SHA-256 代码示例（未加盐）：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> originalString <span class="token operator">=</span> <span class="token string">"Java学习 + 面试指南：javaguide.cn"</span><span class="token punctuation">;</span>
<span class="token comment">// 创建SHA-256摘要对象</span>
<span class="token class-name">MessageDigest</span> messageDigest <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"SHA-256"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messageDigest<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>originalString<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 计算哈希值</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> messageDigest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将哈希值转换为十六进制字符串</span>
<span class="token class-name">String</span> hexString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HexBinaryAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">marshal</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Original String: "</span> <span class="token operator">+</span> originalString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SHA-256 Hash: "</span> <span class="token operator">+</span> hexString<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Original String: Java学习 + 面试指南：javaguide.cn
SHA-256 Hash: 184eb7e1d7fb002444098c9bde3403c6f6722c93ecfac242c0e35cd9ed3b41cd
</code></pre></div><h3>Bcrypt</h3>
<p>Bcrypt 算法是一种基于 Blowfish 加密算法的密码哈希算法，专门为密码加密而设计，安全性高。</p>
<p>由于 Bcrypt 采用了 salt（盐） 和 cost（成本） 两种机制，它可以有效地防止彩虹表攻击和暴力破解攻击，从而保证密码的安全性。salt 是一个随机生成的字符串，用于和密码混合，增加密码的复杂度和唯一性。cost 是一个数值参数，用于控制 Bcrypt 算法的迭代次数，增加密码哈希的计算时间和资源消耗。</p>
<p>Bcrypt 算法可以根据实际情况进行调整加密的复杂度，可以设置不同的 cost 值和 salt 值，从而满足不同的安全需求，灵活性很高。</p>
<p>Java 应用程序的安全框架 Spring Security 支持多种密码编码器，其中 <code>BCryptPasswordEncoder</code> 是官方推荐的一种，它使用 BCrypt 算法对用户的密码进行加密存储。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">PasswordEncoder</span> <span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>对称加密</h2>
<p>对称加密算法是指加密和解密使用同一个密钥的算法，也叫共享密钥加密算法。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/symmetric-encryption.png" alt="对称加密" tabindex="0"><figcaption>对称加密</figcaption></figure>
<p>常见的对称加密算法有 DES、3DES、AES 等。</p>
<h3>DES 和 3DES</h3>
<p>DES（Data Encryption Standard）使用 64 位的密钥(有效秘钥长度为 56 位,8 位奇偶校验位)和 64 位的明文进行加密。</p>
<p>虽然 DES 一次只能加密 64 位，但我们只需要把明文划分成 64 位一组的块，就可以实现任意长度明文的加密。如果明文长度不是 64 位的倍数，必须进行填充，常用的模式有 PKCS5Padding, PKCS7Padding, NOPADDING。</p>
<p>DES 加密算法的基本思想是将 64 位的明文分成两半，然后对每一半进行多轮的变换，最后再合并成 64 位的密文。这些变换包括置换、异或、选择、移位等操作，每一轮都使用了一个子密钥，而这些子密钥都是由同一个 56 位的主密钥生成的。DES 加密算法总共进行了 16 轮变换，最后再进行一次逆置换，得到最终的密文。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/des-steps.jpg" alt="DES（Data Encryption Standard）" tabindex="0"><figcaption>DES（Data Encryption Standard）</figcaption></figure>
<p>这是一个经典的对称加密算法，但也有明显的缺陷，即 56 位的密钥安全性不足，已被证实可以在短时间内破解。</p>
<p>为了提高 DES 算法的安全性，人们提出了一些变种或者替代方案，例如 3DES（Triple DES）。</p>
<p>3DES（Triple DES）是 DES 向 AES 过渡的加密算法，它使用 2 个或者 3 个 56 位的密钥对数据进行三次加密。3DES 相当于是对每个数据块应用三次 DES 的对称加密算法。</p>
<p>为了兼容普通的 DES，3DES 并没有直接使用 加密-&gt;加密-&gt;加密 的方式，而是采用了加密-&gt;解密-&gt;加密 的方式。当三种密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通 DES 加密算法的兼容。3DES 比 DES 更为安全，但其处理速度不高。</p>
<h3>AES</h3>
<p>AES（Advanced Encryption Standard）算法是一种更先进的对称密钥加密算法，它使用 128 位、192 位或 256 位的密钥对数据进行加密或解密，密钥越长，安全性越高。</p>
<p>AES 也是一种分组(或者叫块)密码，分组长度只能是 128 位，也就是说，每个分组为 16 个字节。AES 加密算法有多种工作模式（mode of operation），如：ECB、CBC、OFB、CFB、CTR、XTS、OCB、GCM（目前使用最广泛的模式）。不同的模式参数和加密流程不同，但是核心仍然是 AES 算法。</p>
<p>和 DES 类似，对于不是 128 位倍数的明文需要进行填充，常用的填充模式有 PKCS5Padding, PKCS7Padding, NOPADDING。不过，AES-GCM 是流加密算法，可以对任意长度的明文进行加密，所以对应的填充模式为 NoPadding，即无需填充。</p>
<p>AES 的速度比 3DES 快，而且更安全。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/aes-steps.jpg" alt="AES（Advanced Encryption Standard）" tabindex="0"><figcaption>AES（Advanced Encryption Standard）</figcaption></figure>
<p>DES 算法和 AES 算法简单对比（图片来自于：<a href="https://cheapsslweb.com/blog/rsa-vs-aes-encryption" target="_blank" rel="noopener noreferrer">RSA vs. AES Encryption: Key Differences Explained</a>）：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/des-vs-aes.png" alt="DES 和 AES 对比" tabindex="0"><figcaption>DES 和 AES 对比</figcaption></figure>
<p>基于 Java 实现 AES 算法代码示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">AES_ALGORITHM</span> <span class="token operator">=</span> <span class="token string">"AES"</span><span class="token punctuation">;</span>
<span class="token comment">// AES密钥</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">AES_SECRET_KEY</span> <span class="token operator">=</span> <span class="token string">"4128D9CDAC7E2F82951CBAF7FDFE675B"</span><span class="token punctuation">;</span>
<span class="token comment">// AES加密模式为GCM，填充方式为NoPadding</span>
<span class="token comment">// AES-GCM 是流加密（Stream cipher）算法，所以对应的填充模式为 NoPadding，即无需填充。</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">AES_TRANSFORMATION</span> <span class="token operator">=</span> <span class="token string">"AES/GCM/NoPadding"</span><span class="token punctuation">;</span>
<span class="token comment">// 加密器</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Cipher</span> encryptionCipher<span class="token punctuation">;</span>
<span class="token comment">// 解密器</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Cipher</span> decryptionCipher<span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 完成一些初始化工作
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将AES密钥转换为SecretKeySpec对象</span>
    <span class="token class-name">SecretKeySpec</span> secretKeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span><span class="token constant">AES_SECRET_KEY</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">AES_ALGORITHM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用指定的AES加密模式和填充方式获取对应的加密器并初始化</span>
    encryptionCipher <span class="token operator">=</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token constant">AES_TRANSFORMATION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    encryptionCipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">ENCRYPT_MODE</span><span class="token punctuation">,</span> secretKeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 使用指定的AES加密模式和填充方式获取对应的解密器并初始化</span>
    decryptionCipher <span class="token operator">=</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token constant">AES_TRANSFORMATION</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    decryptionCipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">DECRYPT_MODE</span><span class="token punctuation">,</span> secretKeySpec<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GCMParameterSpec</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> encryptionCipher<span class="token punctuation">.</span><span class="token function">getIV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 加密
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataInBytes <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 加密数据</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encryptedBytes <span class="token operator">=</span> encryptionCipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>dataInBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>encryptedBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 解密
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> encryptedData<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataInBytes <span class="token operator">=</span> <span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 解密数据</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> decryptedBytes <span class="token operator">=</span> decryptionCipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>dataInBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>decryptedBytes<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> originalString <span class="token operator">=</span> <span class="token string">"Java学习 + 面试指南：javaguide.cn"</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> encryptedData <span class="token operator">=</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>originalString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> decryptedData <span class="token operator">=</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Original String: "</span> <span class="token operator">+</span> originalString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AES Encrypted Data : "</span> <span class="token operator">+</span> encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AES Decrypted Data : "</span> <span class="token operator">+</span> decryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Original String: Java学习 + 面试指南：javaguide.cn
AES Encrypted Data <span class="token builtin class-name">:</span> E1qTkK91suBqToag7WCyoFP9uK5hR1nSfM6p+oBlYj71bFiIVnk5TsQRT+zpjv8stha7oyKi3jQ<span class="token operator">=</span>
AES Decrypted Data <span class="token builtin class-name">:</span> Java学习 + 面试指南：javaguide.cn
</code></pre></div><h2>非对称加密</h2>
<p>非对称加密算法是指加密和解密使用不同的密钥的算法，也叫公开密钥加密算法。这两个密钥互不相同，一个称为公钥，另一个称为私钥。公钥可以公开给任何人使用，私钥则要保密。</p>
<p>如果用公钥加密数据，只能用对应的私钥解密（加密）；如果用私钥加密数据，只能用对应的公钥解密（签名）。这样就可以实现数据的安全传输和身份认证。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/asymmetric-encryption.png" alt="非对称加密" tabindex="0"><figcaption>非对称加密</figcaption></figure>
<p>常见的非对称加密算法有 RSA、DSA、ECC 等。</p>
<h3>RSA</h3>
<p>RSA（Rivest–Shamir–Adleman algorithm）算法是一种基于大数分解的困难性的非对称加密算法，它需要选择两个大素数作为私钥的一部分，然后计算出它们的乘积作为公钥的一部分（寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难）。RSA 算法原理的详细介绍，可以参考这篇文章：<a href="https://www.cnblogs.com/xiaofuge/p/16954187.html" target="_blank" rel="noopener noreferrer">你真的了解 RSA 加密算法吗？ - 小傅哥</a>。</p>
<p>RSA 算法的安全性依赖于大数分解的难度，目前已经有 512 位和 768 位的 RSA 公钥被成功分解，因此建议使用 2048 位或以上的密钥长度。</p>
<p>RSA 算法的优点是简单易用，可以用于数据加密和数字签名；缺点是运算速度慢，不适合大量数据的加密。</p>
<p>RSA 算法是是目前应用最广泛的非对称加密算法，像 SSL/TLS、SSH 等协议中就用到了 RSA 算法。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/https-rsa-sha-256.png" alt="HTTPS 证书签名算法中带RSA 加密的SHA-256 " tabindex="0"><figcaption>HTTPS 证书签名算法中带RSA 加密的SHA-256 </figcaption></figure>
<p>基于 Java 实现 RSA 算法代码示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">RSA_ALGORITHM</span> <span class="token operator">=</span> <span class="token string">"RSA"</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * 生成RSA密钥对
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">KeyPair</span> <span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NoSuchAlgorithmException</span> <span class="token punctuation">{</span>
    <span class="token class-name">KeyPairGenerator</span> keyPairGenerator <span class="token operator">=</span> <span class="token class-name">KeyPairGenerator</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token constant">RSA_ALGORITHM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 密钥大小为2048位</span>
    keyPairGenerator<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> keyPairGenerator<span class="token punctuation">.</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 使用公钥加密数据
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">,</span> <span class="token class-name">PublicKey</span> publicKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Cipher</span> cipher <span class="token operator">=</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token constant">RSA_ALGORITHM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">ENCRYPT_MODE</span><span class="token punctuation">,</span> publicKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> encryptedData <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 使用私钥解密数据
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">decrypt</span><span class="token punctuation">(</span><span class="token class-name">String</span> encryptedData<span class="token punctuation">,</span> <span class="token class-name">PrivateKey</span> privateKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> decodedData <span class="token operator">=</span> <span class="token class-name">Base64</span><span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Cipher</span> cipher <span class="token operator">=</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token constant">RSA_ALGORITHM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">DECRYPT_MODE</span><span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> decryptedData <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>decodedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>decryptedData<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">KeyPair</span> keyPair <span class="token operator">=</span> <span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">PublicKey</span> publicKey <span class="token operator">=</span> keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">PrivateKey</span> privateKey <span class="token operator">=</span> keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> originalString <span class="token operator">=</span> <span class="token string">"Java学习 + 面试指南：javaguide.cn"</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> encryptedData <span class="token operator">=</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>originalString<span class="token punctuation">,</span> publicKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> decryptedData <span class="token operator">=</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>encryptedData<span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Original String: "</span> <span class="token operator">+</span> originalString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RSA Encrypted Data : "</span> <span class="token operator">+</span> encryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"RSA Decrypted Data : "</span> <span class="token operator">+</span> decryptedData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出：</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Original String: Java学习 + 面试指南：javaguide.cn
RSA Encrypted Data <span class="token builtin class-name">:</span> T9ey/CEPUAhZm4UJjuVNIg8RPd1fQ32S9w6+rvOKxmuMumkJY2daFfWuCn8A73Mk5bL6TigOJI0GHfKOt/W2x968qLM3pBGCcPX17n4pR43f32IIIz9iPdgF/INOqDxP5ZAtCDvTiuzcSgDHXqiBSK5TDjtj7xoGjfudYAXICa8pWitnqDgJYoo2J0F8mKzxoi8D8eLE455MEx8ZT1s7FUD/z7/H8CfShLRbO9zq/zFI06TXn123ufg+F4lDaq/5jaIxGVEUB/NFeX4N6OZCFHtAV32mw71BYUadzI9TgvkkUr1rSKmQ0icNhnRdKedJokGUh8g9QQ768KERu92Ibg<span class="token operator">==</span>
RSA Decrypted Data <span class="token builtin class-name">:</span> Java学习 + 面试指南：javaguide.cn
</code></pre></div><h3>DSA</h3>
<p>DSA（Digital Signature Algorithm）算法是一种基于离散对数的困难性的非对称加密算法，它需要选择一个素数 q 和一个 q 的倍数 p 作为私钥的一部分，然后计算出一个模 p 的原根 g 和一个模 q 的整数 y 作为公钥的一部分。DSA 算法的安全性依赖于离散对数的难度，目前已经有 1024 位的 DSA 公钥被成功破解，因此建议使用 2048 位或以上的密钥长度。</p>
<p>DSA 算法的优点是数字签名速度快，适合生成数字证书；缺点是不能用于数据加密，且签名过程需要随机数。</p>
<p>DSA 算法签名过程：</p>
<ol>
<li>使用消息摘要算法对要发送的数据进行加密，生成一个信息摘要，也就是一个短的、唯一的、不可逆的数据表示。</li>
<li>发送方用自己的 DSA 私钥对信息摘要再进行加密，形成一个数字签名，也就是一个可以证明数据来源和完整性的数据附加。</li>
<li>将原始数据和数字签名一起通过互联网传送给接收方。</li>
<li>接收方用发送方的公钥对数字签名进行解密，得到信息摘要。同时，接收方也用消息摘要算法对收到的原始数据进行加密，得到另一个信息摘要。接收方将两个信息摘要进行比较，如果两者一致，则说明在传送过程中数据没有被篡改或损坏；否则，则说明数据已经失去了安全性和保密性。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/dsa-algorithm-signing-process.png" alt="DSA 算法签名过程" tabindex="0"><figcaption>DSA 算法签名过程</figcaption></figure>
<h2>总结</h2>
<p>这篇文章介绍了三种加密算法：哈希算法、对称加密算法和非对称加密算法。</p>
<ul>
<li>哈希算法是一种用数学方法对数据生成一个固定长度的唯一标识的技术，可以用来验证数据的完整性和一致性，常见的哈希算法有 MD、SHA、MAC 等。</li>
<li>对称加密算法是一种加密和解密使用同一个密钥的算法，可以用来保护数据的安全性和保密性，常见的对称加密算法有 DES、3DES、AES 等。</li>
<li>非对称加密算法是一种加密和解密使用不同的密钥的算法，可以用来实现数据的安全传输和身份认证，常见的非对称加密算法有 RSA、DSA、ECC 等。</li>
</ul>
<h2>参考</h2>
<ul>
<li>深入理解完美哈希 - 腾讯技术工程：<a href="https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/M8Wcj8sZ7UF1CMr887Puog</a></li>
<li>写给开发人员的实用密码学（二）—— 哈希函数：<a href="https://thiscute.world/posts/practical-cryptography-basics-2-hash/" target="_blank" rel="noopener noreferrer">https://thiscute.world/posts/practical-cryptography-basics-2-hash/</a></li>
<li>奇妙的安全旅行之 DSA 算法：<a href="https://zhuanlan.zhihu.com/p/347025157" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/347025157</a></li>
<li>AES-GCM 加密简介：<a href="https://juejin.cn/post/6844904122676690951" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904122676690951</a></li>
<li>Java AES 256 GCM Encryption and Decryption Example | JCE Unlimited Strength：<a href="https://www.javainterviewpoint.com/java-aes-256-gcm-encryption-and-decryption/" target="_blank" rel="noopener noreferrer">https://www.javainterviewpoint.com/java-aes-256-gcm-encryption-and-decryption/</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="系统设计"/>
    <published>2023-06-27T12:05:39.000Z</published>
  </entry>
  <entry>
    <title type="text">Java NIO 核心知识总结</title>
    <id>https://javaguide.cn/learning/java/io/nio-basis.html</id>
    <link href="https://javaguide.cn/learning/java/io/nio-basis.html"/>
    <updated>2024-02-29T07:44:35.000Z</updated>
    <summary type="html"><![CDATA[<p>在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：<a href="https://javaguide.cn/java/io/io-model.html" target="_blank" rel="noopener noreferrer">Java IO 模型详解</a>。</p>
<h2>NIO 简介</h2>
<p>在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>]]></summary>
    <content type="html"><![CDATA[<p>在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：<a href="https://javaguide.cn/java/io/io-model.html" target="_blank" rel="noopener noreferrer">Java IO 模型详解</a>。</p>
<h2>NIO 简介</h2>
<p>在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。</p>
<p>为了解决这个问题，在 Java1.4 版本引入了一种新的 I/O 模型 — <strong>NIO</strong> （New IO，也称为 Non-blocking IO） 。NIO 弥补了同步阻塞 I/O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I/O，可以使用少量的线程来处理多个连接，大大提高了 I/O 效率和并发。</p>
<p>下图是 BIO、NIO 和 AIO 处理客户端请求的简单对比图（关于 AIO 的介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/java/io/io-model.html" target="_blank" rel="noopener noreferrer">Java IO 模型详解</a>，不是重点，了解即可）。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png" alt="BIO、NIO 和 AIO 对比" tabindex="0"><figcaption>BIO、NIO 和 AIO 对比</figcaption></figure>
<p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。</p>
<h2>NIO 核心组件</h2>
<p>NIO 主要包括以下三个核心组件：</p>
<ul>
<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li>
<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>
<li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li>
</ul>
<p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer-selector.png" alt="Buffer、Channel和Selector三者之间的关系" tabindex="0"><figcaption>Buffer、Channel和Selector三者之间的关系</figcaption></figure>
<p>下面详细介绍一下这三个组件。</p>
<h3>Buffer（缓冲区）</h3>
<p>在传统的 BIO 中，数据的读写是面向流的， 分为字节流和字符流。</p>
<p>在 Java 1.4 的 NIO 库中，所有数据都是用缓冲区处理的，这是新库和之前的 BIO 的一个重要区别，有点类似于 BIO 中的缓冲流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO 在读写数据时，都是通过缓冲区进行操作。</p>
<p><code>Buffer</code> 的子类如下图所示。其中，最常用的是 <code>ByteBuffer</code>，它可以用来存储和操作字节数据。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/buffer-subclasses.png" alt="Buffer 的子类" tabindex="0"><figcaption>Buffer 的子类</figcaption></figure>
<p>你可以将 Buffer 理解为一个数组，<code>IntBuffer</code>、<code>FloatBuffer</code>、<code>CharBuffer</code> 等分别对应 <code>int[]</code>、<code>float[]</code>、<code>char[]</code> 等。</p>
<p>为了更清晰地认识缓冲区，我们来简单看看<code>Buffer</code> 类中定义的四个成员变量：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span>
    <span class="token comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这四个成员变量的具体含义如下：</p>
<ol>
<li>容量（<code>capacity</code>）：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li>
<li>界限（<code>limit</code>）：<code>Buffer</code> 中可以读/写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li>
<li>位置（<code>position</code>）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li>
<li>标记（<code>mark</code>）：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>
</ol>
<p>并且，上述变量满足如下的关系：<strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong> 。</p>
<p>另外，Buffer 有读模式和写模式这两种模式，分别用于从 Buffer 中读取数据或者向 Buffer 中写入数据。Buffer 被创建之后默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/JavaNIOBuffer.png" alt="position 、limit 和 capacity 之前的关系" tabindex="0"><figcaption>position 、limit 和 capacity 之前的关系</figcaption></figure>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributes.png" alt="position 、limit 和 capacity 之前的关系" tabindex="0"><figcaption>position 、limit 和 capacity 之前的关系</figcaption></figure>
<p><code>Buffer</code> 对象不能通过 <code>new</code> 调用构造方法创建对象 ，只能通过静态方法实例化 <code>Buffer</code>。</p>
<p>这里以 <code>ByteBuffer</code>为例进行介绍：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 分配堆内存</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ByteBuffer</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分配直接内存</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ByteBuffer</span> <span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Buffer 最核心的两个方法：</p>
<ol>
<li><code>get</code> : 读取缓冲区的数据</li>
<li><code>put</code> ：向缓冲区写入数据</li>
</ol>
<p>除上述两个方法之外，其他的重要方法：</p>
<ul>
<li><code>flip</code> ：将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</li>
<li><code>clear</code>: 清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</li>
<li>……</li>
</ul>
<p>Buffer 中数据变化的过程：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CharBufferDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 分配一个容量为8的CharBuffer</span>
        <span class="token class-name">CharBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">CharBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 向buffer写入3个字符</span>
        buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"写入3个字符后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 调用flip()方法，准备读取buffer中的数据，将 position 置 0,limit 的置 3</span>
        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用flip()方法后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 读取字符</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 调用clear()方法，清空缓冲区，将 position 的值置为 0，将 limit 的值置为 capacity 的值</span>
        buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用clear()方法后的状态："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printState</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token comment">// 打印buffer的capacity、limit、position、mark的位置</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printState</span><span class="token punctuation">(</span><span class="token class-name">CharBuffer</span> buffer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"capacity: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", limit: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", position: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">", mark 开始读取的字符: "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出:</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code>初始状态：
capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">0</span>

写入3个字符后的状态：
capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">3</span>

准备读取buffer中的数据！

调用flip<span class="token punctuation">(</span><span class="token punctuation">)</span>方法后的状态：
capacity: <span class="token number">8</span>, limit: <span class="token number">3</span>, position: <span class="token number">0</span>

读取到的数据：abc

调用clear<span class="token punctuation">(</span><span class="token punctuation">)</span>方法后的状态：
capacity: <span class="token number">8</span>, limit: <span class="token number">8</span>, position: <span class="token number">0</span>
</code></pre></div><p>为了帮助理解，我绘制了一张图片展示 <code>capacity</code>、<code>limit</code>和<code>position</code>每一阶段的变化。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/NIOBufferClassAttributesDataChanges.png" alt="capacity、limit和position每一阶段的变化" tabindex="0"><figcaption>capacity、limit和position每一阶段的变化</figcaption></figure>
<h3>Channel（通道）</h3>
<p>Channel 是一个通道，它建立了与数据源（如文件、网络套接字等）之间的连接。我们可以利用它来读取和写入数据，就像打开了一条自来水管，让数据在 Channel 中自由流动。</p>
<p>BIO 中的流是单向的，分为各种 <code>InputStream</code>（输入流）和 <code>OutputStream</code>（输出流），数据只是在一个方向上传输。通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</p>
<p>Channel 与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-buffer.png" alt="Channel 和 Buffer之间的关系" tabindex="0"><figcaption>Channel 和 Buffer之间的关系</figcaption></figure>
<p>另外，因为 Channel 是全双工的，所以它可以比流更好地映射底层操作系统的 API。特别是在 UNIX 网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。</p>
<p><code>Channel</code> 的子类如下图所示。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-subclasses.png" alt="Channel 的子类" tabindex="0"><figcaption>Channel 的子类</figcaption></figure>
<p>其中，最常用的是以下几种类型的通道：</p>
<ul>
<li><code>FileChannel</code>：文件访问通道；</li>
<li><code>SocketChannel</code>、<code>ServerSocketChannel</code>：TCP 通信通道；</li>
<li><code>DatagramChannel</code>：UDP 通信通道；</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/channel-inheritance-relationship.png" alt="Channel继承关系图" tabindex="0"><figcaption>Channel继承关系图</figcaption></figure>
<p>Channel 最核心的两个方法：</p>
<ol>
<li><code>read</code> ：读取数据并写入到 Buffer 中。</li>
<li><code>write</code> ：将 Buffer 中的数据写入到 Channel 中。</li>
</ol>
<p>这里我们以 <code>FileChannel</code> 为例演示一下是读取文件数据的。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">RandomAccessFile</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"/Users/guide/Documents/test_read.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>Selector（选择器）</h3>
<p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I/O 操作。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/nio/selector-channel-selectionkey.png" alt="Selector 选择器工作示意图" tabindex="0"><figcaption>Selector 选择器工作示意图</figcaption></figure>
<p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p>
<p>Selector 可以监听以下四种事件类型：</p>
<ol>
<li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li>
<li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li>
<li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li>
<li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li>
</ol>
<p><code>Selector</code>是抽象类，可以通过调用此类的 <code>open()</code> 静态方法来创建 Selector 实例。Selector 可以同时监控多个 <code>SelectableChannel</code> 的 <code>IO</code> 状况，是非阻塞 <code>IO</code> 的核心。</p>
<p>一个 Selector 实例有三个 <code>SelectionKey</code> 集合：</p>
<ol>
<li>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</li>
<li>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li>
<li>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li>
</ol>
<p>简单演示一下如何遍历被选择的 <code>SelectionKey</code> 集合并进行处理：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> keyIterator <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ServerSocketChannel 接收了一个新连接</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isConnectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 表示一个新连接建立</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Channel 有准备好的数据，可以读取</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Channel 有空闲的 Buffer，可以写入数据</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Selector 还提供了一系列和 <code>select()</code> 相关的方法：</p>
<ul>
<li><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，该方法返回，并将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</li>
<li><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</li>
<li><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，该方法不会阻塞线程。</li>
<li><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</li>
<li>……</li>
</ul>
<p>使用 Selector 实现网络读写的简单示例：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SelectionKey</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">Selector</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">ServerSocketChannel</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioSelectorExample</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span>
      serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> readyChannels <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>readyChannels <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> selectedKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> keyIterator <span class="token operator">=</span> selectedKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理连接事件</span>
            <span class="token class-name">ServerSocketChannel</span> server <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span>
            client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理读事件</span>
            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> bytesRead <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到数据："</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token comment">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span>
              client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 客户端断开连接</span>
              client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 处理写事件</span>
            <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">"Hello, Client!"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            client<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span>
            client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在示例中，我们创建了一个简单的服务器，监听 8080 端口，使用 Selector 处理连接、读取和写入事件。当接收到客户端的数据时，服务器将读取数据并将其打印到控制台，然后向客户端回复 "Hello, Client!"。</p>
<h2>NIO 零拷贝</h2>
<p>零拷贝是提升 IO 操作性能的一个常用手段，像 ActiveMQ、Kafka 、RocketMQ、QMQ、Netty 等顶级开源项目都用到了零拷贝。</p>
<p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。零拷贝的常见实现技术有： <code>mmap+write</code>、<code>sendfile</code>和 <code>sendfile + DMA gather copy</code> 。</p>
<p>下图展示了各种零拷贝技术的对比图：</p>
<p>|                            | CPU 拷贝 | DMA 拷贝 | 系统调用   | 上下文切换 |<br>
|</p>
]]></content>
    <category term="Java"/>
    <published>2023-06-26T15:16:09.000Z</published>
  </entry>
  <entry>
    <title type="text">ArrayBlockingQueue 源码分析</title>
    <id>https://javaguide.cn/learning/java/collection/arrayblockingqueue-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/arrayblockingqueue-source-code.html"/>
    <updated>2024-03-09T05:52:21.000Z</updated>
    <summary type="html"><![CDATA[<h2>阻塞队列简介</h2>
<h3>阻塞队列的历史</h3>
<p>Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 <code>java.util.concurrent</code>，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。</p>
<p>为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>，它们是带有生产者-消费者模式实现的并发容器。其中，<code>ArrayBlockingQueue</code> 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 <code>LinkedBlockingQueue</code> 则由链表构成的队列，正是因为链表的特性，所以 <code>LinkedBlockingQueue</code> 在添加元素上并不会向 <code>ArrayBlockingQueue</code> 那样有着较多的约束，所以 <code>LinkedBlockingQueue</code> 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 <code>Integer.MAX_VALUE</code>，近乎于无限大)。</p>]]></summary>
    <content type="html"><![CDATA[<h2>阻塞队列简介</h2>
<h3>阻塞队列的历史</h3>
<p>Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 <code>java.util.concurrent</code>，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。</p>
<p>为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 <code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>，它们是带有生产者-消费者模式实现的并发容器。其中，<code>ArrayBlockingQueue</code> 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 <code>LinkedBlockingQueue</code> 则由链表构成的队列，正是因为链表的特性，所以 <code>LinkedBlockingQueue</code> 在添加元素上并不会向 <code>ArrayBlockingQueue</code> 那样有着较多的约束，所以 <code>LinkedBlockingQueue</code> 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 <code>Integer.MAX_VALUE</code>，近乎于无限大)。</p>
<p>随着 Java 的不断发展，JDK 后续的几个版本又对阻塞队列进行了不少的更新和完善:</p>
<ol>
<li>JDK1.6 版本:增加 <code>SynchronousQueue</code>，一个不存储元素的阻塞队列。</li>
<li>JDK1.7 版本:增加 <code>TransferQueue</code>，一个支持更多操作的阻塞队列。</li>
<li>JDK1.8 版本:增加 <code>DelayQueue</code>，一个支持延迟获取元素的阻塞队列。</li>
</ol>
<h3>阻塞队列的思想</h3>
<p>阻塞队列就是典型的生产者-消费者模型，它可以做到以下几点:</p>
<ol>
<li>当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。</li>
<li>当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。</li>
<li>当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。</li>
<li>当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。</li>
</ol>
<p>总结一下：阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 <code>put</code>、<code>take</code>、<code>offer</code>、<code>poll</code> 等 API 即可实现多线程之间的生产和消费。</p>
<p>这也使得阻塞队列在多线程开发中有着广泛的运用，最常见的例子无非是我们的线程池,从源码中我们就能看出当核心线程无法及时处理任务时，这些任务都会扔到 <code>workQueue</code> 中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                            <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                            <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
                            <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                            <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// ...}</span>
</code></pre></div><h2>ArrayBlockingQueue 常见方法及测试</h2>
<p>简单了解了阻塞队列的历史之后，我们就开始重点讨论本篇文章所要介绍的并发容器——<code>ArrayBlockingQueue</code>。为了后续更加深入的了解 <code>ArrayBlockingQueue</code>，我们不妨基于下面几个实例了解以下 <code>ArrayBlockingQueue</code> 的使用。</p>
<p>先看看第一个例子，我们这里会用两个线程分别模拟生产者和消费者，生产者生产完会使用 <code>put</code> 方法生产 10 个元素给消费者进行消费，当队列元素达到我们设置的上限 5 时，<code>put</code> 方法就会阻塞。<br>
同理消费者也会通过 <code>take</code> 方法消费元素，当队列为空时，<code>take</code> 方法就会阻塞消费者线程。这里笔者为了保证消费者能够在消费完 10 个元素后及时退出。便通过倒计时门闩，来控制消费者结束，生产者在这里只会生产 10 个元素。当消费者将 10 个元素消费完成之后，按下倒计时门闩，所有线程都会停止。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumerExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token comment">// 创建一个大小为 5 的 ArrayBlockingQueue</span>
        <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建生产者线程</span>
        <span class="token class-name">Thread</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 向队列中添加元素，如果队列已满则阻塞等待</span>
                    queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产者添加元素："</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建消费者线程</span>
        <span class="token class-name">Thread</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

                    <span class="token comment">// 从队列中取出元素，如果队列为空则阻塞等待</span>
                    <span class="token keyword">int</span> element <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者取出元素："</span> <span class="token operator">+</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token operator">++</span>count<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>

                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 启动线程</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 等待线程结束</span>
        producer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        producer<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>代码输出结果如下，可以看到只有生产者往队列中投放元素之后消费者才能消费，这也就意味着当队列中没有数据的时消费者就会阻塞，等待队列非空再继续消费。</p>
<div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>生产者添加元素：<span class="token number">1</span>
生产者添加元素：<span class="token number">2</span>
消费者取出元素：<span class="token number">1</span>
消费者取出元素：<span class="token number">2</span>
消费者取出元素：<span class="token number">3</span>
生产者添加元素：<span class="token number">3</span>
生产者添加元素：<span class="token number">4</span>
生产者添加元素：<span class="token number">5</span>
消费者取出元素：<span class="token number">4</span>
生产者添加元素：<span class="token number">6</span>
消费者取出元素：<span class="token number">5</span>
生产者添加元素：<span class="token number">7</span>
生产者添加元素：<span class="token number">8</span>
生产者添加元素：<span class="token number">9</span>
生产者添加元素：<span class="token number">10</span>
消费者取出元素：<span class="token number">6</span>
消费者取出元素：<span class="token number">7</span>
消费者取出元素：<span class="token number">8</span>
消费者取出元素：<span class="token number">9</span>
消费者取出元素：<span class="token number">10</span>
</code></pre></div><p>了解了 <code>put</code>、<code>take</code> 这两个会阻塞的存和取方法之后，我我们再来看看阻塞队列中非阻塞的入队和出队方法 <code>offer</code> 和 <code>poll</code>。</p>
<p>如下所示，我们设置了一个大小为 3 的阻塞队列，我们会尝试在队列用 offer 方法存放 4 个元素，然后再从队列中用 <code>poll</code> 尝试取 4 次。</p>
<div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OfferPollExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个大小为 3 的 ArrayBlockingQueue</span>
        ArrayBlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ArrayBlockingQueue</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 向队列中添加元素</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 尝试向队列中添加元素，但队列已满，返回 false</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 从队列中取出元素</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 尝试从队列中取出元素，但队列已空，返回 null</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>最终代码的输出结果如下，可以看到因为队列的大小为 3 的缘故，我们前 3 次存放到队列的结果为 true，第 4 次存放时，由于队列已满，所以存放结果返回 false。这也是为什么我们后续的 <code>poll</code> 方法只得到了 3 个元素的值。</p>
<div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">false</span>
A
B
C
null
</code></pre></div><p>了解了阻塞存取和非阻塞存取，我们再来看看阻塞队列的一个比较特殊的操作，某些场景下，我们希望能够一次性将阻塞队列的结果存到列表中再进行批量操作，我们就可以使用阻塞队列的 <code>drainTo</code> 方法，这个方法会一次性将队列中所有元素存放到列表，如果队列中有元素，且成功存到 list 中则 <code>drainTo</code> 会返回本次转移到 list 中的元素数，反之若队列为空，<code>drainTo</code> 则直接返回 0。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DrainToExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个大小为 5 的 ArrayBlockingQueue</span>
        <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 向队列中添加元素</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建一个 List，用于存储从队列中取出的元素</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 从队列中取出所有元素，并添加到 List 中</span>
        queue<span class="token punctuation">.</span><span class="token function">drainTo</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出 List 中的元素</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>代码输出结果如下</p>
<div class="language-cpp" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
</code></pre></div><h2>ArrayBlockingQueue 源码分析</h2>
<p>自此我们对阻塞队列的使用有了基本的印象，接下来我们就可以进一步了解一下 <code>ArrayBlockingQueue</code> 的工作机制了。</p>
<h3>整体设计</h3>
<p>在了解 <code>ArrayBlockingQueue</code> 的具体细节之前，我们先来看看 <code>ArrayBlockingQueue</code> 的类图。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/arrayblockingqueue-class-diagram.png" alt="ArrayBlockingQueue 类图" tabindex="0"><figcaption>ArrayBlockingQueue 类图</figcaption></figure>
<p>从图中我们可以看出，<code>ArrayBlockingQueue</code> 继承了阻塞队列 <code>BlockingQueue</code> 这个接口，不难猜出通过继承 <code>BlockingQueue</code> 这个接口之后，<code>ArrayBlockingQueue</code> 就拥有了阻塞队列那些常见的操作行为。</p>
<p>同时， <code>ArrayBlockingQueue</code> 还继承了 <code>AbstractQueue</code> 这个抽象类，这个继承了 <code>AbstractCollection</code> 和 <code>Queue</code> 的抽象类，从抽象类的特定和语义我们也可以猜出，这个继承关系使得 <code>ArrayBlockingQueue</code> 拥有了队列的常见操作。</p>
<p>所以我们是否可以得出这样一个结论，通过继承 <code>AbstractQueue</code> 获得队列所有的操作模板，其实现的入队和出队操作的整体框架。然后 <code>ArrayBlockingQueue</code> 通过继承 <code>BlockingQueue</code> 获取到阻塞队列的常见操作并将这些操作实现，填充到 <code>AbstractQueue</code> 模板方法的细节中，由此 <code>ArrayBlockingQueue</code> 成为一个完整的阻塞队列。</p>
<p>为了印证这一点，我们到源码中一探究竟。首先我们先来看看 <code>AbstractQueue</code>，从类的继承关系我们可以大致得出，它通过 <code>AbstractCollection</code> 获得了集合的常见操作方法，然后通过 <code>Queue</code> 接口获得了队列的特性。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于集合的操作无非是增删改查，所以我们不妨从添加方法入手，从源码中我们可以看到，它实现了 <code>AbstractCollection</code> 的 <code>add</code> 方法，其内部逻辑如下:</p>
<ol>
<li>调用继承 <code>Queue</code> 接口的来的 <code>offer</code> 方法，如果 <code>offer</code> 成功则返回 <code>true</code>。</li>
<li>如果 <code>offer</code> 失败，即代表当前元素入队失败直接抛异常。</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 <code>AbstractQueue</code> 中并没有对 <code>Queue</code> 的 <code>offer</code> 的实现，很明显这样做的目的是定义好了 <code>add</code> 的核心逻辑，将 <code>offer</code> 的细节交由其子类即我们的 <code>ArrayBlockingQueue</code> 实现。</p>
<p>到此，我们对于抽象类 <code>AbstractQueue</code> 的分析就结束了，我们继续看看 <code>ArrayBlockingQueue</code> 中另一个重要的继承接口 <code>BlockingQueue</code>。</p>
<p>点开 <code>BlockingQueue</code> 之后，我们可以看到这个接口同样继承了 <code>Queue</code> 接口，这就意味着它也具备了队列所拥有的所有行为。同时，它还定义了自己所需要实现的方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

     <span class="token comment">//元素入队成功返回true，反之则会抛出异常IllegalStateException</span>
    <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//元素入队成功返回true，反之返回false</span>
    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//元素入队成功则直接返回，如果队列已满元素不可入队则将线程阻塞，因为阻塞期间可能会被打断，所以这里方法签名抛出了InterruptedException</span>
    <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

   <span class="token comment">//和上一个方法一样,只不过队列满时只会阻塞单位为unit，时间为timeout的时长，如果在等待时长内没有入队成功则直接返回false。</span>
    <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

    <span class="token comment">//从队头取出一个元素，如果队列为空则阻塞等待，因为会阻塞线程的缘故，所以该方法可能会被打断，所以签名定义了InterruptedException</span>
    <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

      <span class="token comment">//取出队头的元素并返回，如果当前队列为空则阻塞等待timeout且单位为unit的时长，如果这个时间段没有元素则直接返回null。</span>
    <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>

      <span class="token comment">//获取队列剩余元素个数</span>
    <span class="token keyword">int</span> <span class="token function">remainingCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//删除我们指定的对象，如果成功返回true，反之返回false。</span>
    <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//判断队列中是否包含指定元素</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token comment">//将队列中的元素全部存到指定的集合中</span>
    <span class="token keyword">int</span> <span class="token function">drainTo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//转移maxElements个元素到集合中</span>
    <span class="token keyword">int</span> <span class="token function">drainTo</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> maxElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>了解了 <code>BlockingQueue</code> 的常见操作后，我们就知道了 <code>ArrayBlockingQueue</code> 通过继承 <code>BlockingQueue</code> 的方法并实现后，填充到 <code>AbstractQueue</code> 的方法上，由此我们便知道了上文中 <code>AbstractQueue</code> 的 <code>add</code> 方法的 <code>offer</code> 方法是哪里是实现的了。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//AbstractQueue的offer来自下层的ArrayBlockingQueue从BlockingQueue继承并实现的offer方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>初始化</h3>
<p>了解 <code>ArrayBlockingQueue</code> 的细节前，我们不妨先看看其构造函数，了解一下其初始化过程。从源码中我们可以看出 <code>ArrayBlockingQueue</code> 有 3 个构造方法，而最核心的构造方法就是下方这一个。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// capacity 表示队列初始容量，fair 表示 锁的公平性</span>
<span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//如果设置的队列大小小于0，则直接抛出IllegalArgumentException</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//初始化一个数组用于存放队列的元素</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//创建阻塞队列流程控制的锁</span>
  lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//用lock锁创建两个条件控制队列生产和消费</span>
  notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个构造方法里面有两个比较核心的成员变量 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满） ，需要我们格外留意，它们是实现生产者和消费者有序工作的关键所在，这一点笔者会在后续的源码解析中详细说明，这里我们只需初步了解一下阻塞队列的构造即可。</p>
<p>另外两个构造方法都是基于上述的构造方法，默认情况下，我们会使用下面这个构造方法，该构造方法就意味着 <code>ArrayBlockingQueue</code> 用的是非公平锁，即各个生产者或者消费者线程收到通知后，对于锁的争抢是随机的。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>还有一个不怎么常用的构造方法，在初始化容量和锁的非公平性之后，它还提供了一个 <code>Collection</code> 参数，从源码中不难看出这个构造方法是将外部传入的集合的元素在初始化时直接存放到阻塞队列中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">,</span>
                              <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//初始化容量和锁的公平性</span>
  <span class="token keyword">this</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> fair<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
  <span class="token comment">//上锁并将c中的元素存放到ArrayBlockingQueue底层的数组中</span>
  lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">//遍历并添加元素到数组中</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
              items<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArrayIndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">//记录当前队列容量</span>
      count <span class="token operator">=</span> i<span class="token punctuation">;</span>
                      <span class="token comment">//更新下一次put或者offer或用add方法添加到队列底层数组的位置</span>
      putIndex <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token comment">//完成遍历后释放锁</span>
      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>阻塞式获取和新增元素</h3>
<p><code>ArrayBlockingQueue</code> 阻塞式获取和新增元素对应的就是生产者-消费者模型，虽然它也支持非阻塞式获取和新增元素（例如 <code>poll()</code> 和 <code>offer(E e)</code> 方法，后文会介绍到），但一般不会使用。</p>
<p><code>ArrayBlockingQueue</code> 阻塞式获取和新增元素的方法为：</p>
<ul>
<li><code>put(E e)</code>：将元素插入队列中，如果队列已满，则该方法会一直阻塞，直到队列有空间可用或者线程被中断。</li>
<li><code>take()</code> ：获取并移除队列头部的元素，如果队列为空，则该方法会一直阻塞，直到队列非空或者线程被中断。</li>
</ul>
<p>这两个方法实现的关键就是在于两个条件对象 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满），这个我们在上文的构造方法中有提到。</p>
<p>接下来笔者就通过两张图让大家了解一下这两个条件是如何在阻塞队列中运用的。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-take.png" alt="ArrayBlockingQueue 非空条件" tabindex="0"><figcaption>ArrayBlockingQueue 非空条件</figcaption></figure>
<p>假设我们的代码消费者先启动，当它发现队列中没有数据，那么非空条件就会将这个线程挂起，即等待条件非空时挂起。然后 CPU 执行权到达生产者，生产者发现队列中可以存放数据，于是将数据存放进去，通知此时条件非空，此时消费者就会被唤醒到队列中使用 <code>take</code> 等方法获取值了。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notFull-put.png" alt="ArrayBlockingQueue 非满条件" tabindex="0"><figcaption>ArrayBlockingQueue 非满条件</figcaption></figure>
<p>随后的执行中，生产者生产速度远远大于消费者消费速度，于是生产者将队列塞满后再次尝试将数据存入队列，发现队列已满，于是阻塞队列就将当前线程挂起，等待非满。然后消费者拿着 CPU 执行权进行消费，于是队列可以存放新数据了，发出一个非满的通知，此时挂起的生产者就会等待 CPU 执行权到来时再次尝试将数据存到队列中。</p>
<p>简单了解阻塞队列的基于两个条件的交互流程之后，我们不妨看看 <code>put</code> 和 <code>take</code> 方法的源码。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">//确保插入的元素不为null</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//加锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">//这里使用lockInterruptibly()方法而不是lock()方法是为了能够响应中断操作，如果在等待获取锁的过程中被打断则该方法会抛出InterruptedException异常。</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果count等数组长度则说明队列已满，当前线程将被挂起放到AQS队列中，等待队列非满时插入（非满条件）。</span>
       <span class="token comment">//在等待期间，锁会被释放，其他线程可以继续对队列进行操作。</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">//如果队列可以存放元素，则调用enqueue将元素入队</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">//释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>put</code>方法内部调用了 <code>enqueue</code> 方法来实现元素入队，我们继续深入查看一下 <code>enqueue</code> 方法的实现细节：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">E</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//获取队列底层的数组</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token comment">//将putindex位置的值设置为我们传入的x</span>
    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token comment">//更新putindex，如果putindex等于数组长度，则更新为0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//队列长度+1</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">//通知队列非空，那些因为获取元素而阻塞的线程可以继续工作了</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从源码中可以看到入队操作的逻辑就是在数组中追加一个新元素，整体执行步骤为:</p>
<ol>
<li>获取 <code>ArrayBlockingQueue</code> 底层的数组 <code>items</code>。</li>
<li>将元素存到 <code>putIndex</code> 位置。</li>
<li>更新 <code>putIndex</code> 到下一个位置，如果 <code>putIndex</code> 等于队列长度，则说明 <code>putIndex</code> 已经到达数组末尾了，下一次插入则需要 0 开始。(<code>ArrayBlockingQueue</code> 用到了循环队列的思想，即从头到尾循环复用一个数组)</li>
<li>更新 <code>count</code> 的值，表示当前队列长度+1。</li>
<li>调用 <code>notEmpty.signal()</code> 通知队列非空，消费者可以从队列中获取值了。</li>
</ol>
<p>自此我们了解了 <code>put</code> 方法的流程，为了更加完整的了解 <code>ArrayBlockingQueue</code> 关于生产者-消费者模型的设计，我们继续看看阻塞获取队列元素的 <code>take</code> 方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
       <span class="token comment">//获取锁</span>
     <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
     lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
             <span class="token comment">//如果队列中元素个数为0，则将当前线程打断并存入AQS队列中，等待队列非空时获取并移除元素（非空条件）</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
             notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果队列不为空则调用dequeue获取元素</span>
         <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
          <span class="token comment">//释放锁</span>
         lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>理解了 <code>put</code> 方法再看<code>take</code> 方法就很简单了，其核心逻辑和<code>put</code> 方法正好是相反的，比如<code>put</code> 方法在队列满的时候等待队列非满时插入元素（非满条件），而<code>take</code> 方法等待队列非空时获取并移除元素（非空条件）。</p>
<p><code>take</code>方法内部调用了 <code>dequeue</code> 方法来实现元素出队，其核心逻辑和 <code>enqueue</code> 方法也是相反的。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//获取阻塞队列底层的数组</span>
  <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
  <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
  <span class="token comment">//从队列中获取takeIndex位置的元素</span>
  <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//将takeIndex置空</span>
  items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">//takeIndex向后挪动，如果等于数组长度则更新为0</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
      takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token comment">//队列长度减1</span>
  count<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//通知那些被打断的线程当前队列状态非满，可以继续存放元素</span>
  notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于<code>dequeue</code> 方法（出队）和上面介绍的 <code>enqueue</code> 方法（入队）的步骤大致类似，这里就不重复介绍了。</p>
<p>为了帮助理解，我专门画了一张图来展示 <code>notEmpty</code>(非空) 和 <code>notFull</code> （非满）这两个条件对象是如何控制 <code>ArrayBlockingQueue</code> 的存和取的。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/ArrayBlockingQueue-notEmpty-notFull.png" alt="ArrayBlockingQueue 非空非满" tabindex="0"><figcaption>ArrayBlockingQueue 非空非满</figcaption></figure>
<ul>
<li><strong>消费者</strong>：当消费者从队列中 <code>take</code> 或者 <code>poll</code> 等操作取出一个元素之后，就会通知队列非满，此时那些等待非满的生产者就会被唤醒等待获取 CPU 时间片进行入队操作。</li>
<li><strong>生产者</strong>：当生产者将元素存到队列中后，就会触发通知队列非空，此时消费者就会被唤醒等待 CPU 时间片尝试获取元素。如此往复，两个条件对象就构成一个环路，控制着多线程之间的存和取。</li>
</ul>
<h3>非阻塞式获取和新增元素</h3>
<p><code>ArrayBlockingQueue</code> 非阻塞式获取和新增元素的方法为：</p>
<ul>
<li><code>offer(E e)</code>：将元素插入队列尾部。如果队列已满，则该方法会直接返回 false，不会等待并阻塞线程。</li>
<li><code>poll()</code>：获取并移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。</li>
<li><code>add(E e)</code>：将元素插入队列尾部。如果队列已满则会抛出 <code>IllegalStateException</code> 异常，底层基于 <code>offer(E e)</code> 方法。</li>
<li><code>remove()</code>：移除队列头部的元素，如果队列为空则会抛出 <code>NoSuchElementException</code> 异常，底层基于 <code>poll()</code>。</li>
<li><code>peek()</code>：获取但不移除队列头部的元素，如果队列为空，则该方法会直接返回 null，不会等待并阻塞线程。</li>
</ul>
<p>先来看看 <code>offer</code> 方法，逻辑和 <code>put</code> 差不多，唯一的区别就是入队失败时不会阻塞当前线程，而是直接返回 <code>false</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//确保插入的元素不为null</span>
        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取锁</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
             <span class="token comment">//队列已满直接返回false</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">//反之将元素入队并直接返回true</span>
                <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">//释放锁</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><code>poll</code> 方法同理，获取元素失败也是直接返回空，并不会阻塞获取元素的线程。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        <span class="token comment">//上锁</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果队列为空直接返回null，反之出队返回元素值</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><code>add</code> 方法其实就是对于 <code>offer</code> 做了一层封装，如下代码所示，可以看到 <code>add</code> 会调用没有规定时间的 <code>offer</code>，如果入队失败则直接抛异常。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//调用offer方法如果失败直接抛出异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><code>remove</code> 方法同理，调用 <code>poll</code>，如果返回 <code>null</code> 则说明队列没有元素，直接抛出异常。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">E</span> x <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><code>peek()</code> 方法的逻辑也很简单，内部调用了 <code>itemAt</code> 方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//加锁</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">//当队列为空时返回 null</span>
            <span class="token keyword">return</span> <span class="token function">itemAt</span><span class="token punctuation">(</span>takeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token comment">//释放锁</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token comment">//返回队列中指定位置的元素</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
<span class="token keyword">final</span> <span class="token class-name">E</span> <span class="token function">itemAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>指定超时时间内阻塞式获取和新增元素</h3>
<p>在 <code>offer(E e)</code> 和 <code>poll()</code> 非阻塞获取和新增元素的基础上，设计者提供了带有等待时间的 <code>offer(E e, long timeout, TimeUnit unit)</code> 和 <code>poll(long timeout, TimeUnit unit)</code> ，用于在指定的超时时间内阻塞式地添加和获取元素。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">//队列已满，进入循环</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//时间到了队列还是满的，则直接返回false</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                 <span class="token comment">//阻塞nanos时间，等待非满</span>
                nanos <span class="token operator">=</span> notFull<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，带有超时时间的 <code>offer</code> 方法在队列已满的情况下，会等待用户所传的时间段，如果规定时间内还不能存放元素则直接返回 <code>false</code>。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> nanos <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment">//队列为空，循环等待，若时间到还是空的，则直接返回null</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                nanos <span class="token operator">=</span> notEmpty<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>同理，带有超时时间的 <code>poll</code> 也一样，队列为空则在规定时间内等待，若时间到了还是空的，则直接返回 null。</p>
<h3>判断元素是否存在</h3>
<p><code>ArrayBlockingQueue</code> 提供了 <code>contains(Object o)</code> 来判断指定元素是否存在于队列中。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//若目标元素为空，则直接返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">//获取当前队列的元素数组</span>
    <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token comment">//加锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果队列非空</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token keyword">int</span> putIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex<span class="token punctuation">;</span>
            <span class="token comment">//从队列头部开始遍历</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> takeIndex<span class="token punctuation">;</span>
            <span class="token keyword">do</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>i <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
                    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> putIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">//释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>ArrayBlockingQueue 获取和新增元素的方法对比</h2>
<p>为了帮助理解 <code>ArrayBlockingQueue</code> ，我们再来对比一下上面提到的这些获取和新增元素的方法。</p>
<p>新增元素：</p>
<p>| 方法                                      | 队列满时处理方式                                         | 方法返回值 |<br>
|</p>
]]></content>
    <category term="Java"/>
    <published>2023-06-21T05:03:13.000Z</published>
  </entry>
  <entry>
    <title type="text">《后端面试高频系统设计&amp;场景题》</title>
    <id>https://javaguide.cn/learning/zhuanlan/back-end-interview-high-frequency-system-design-and-scenario-questions.html</id>
    <link href="https://javaguide.cn/learning/zhuanlan/back-end-interview-high-frequency-system-design-and-scenario-questions.html"/>
    <updated>2024-04-09T16:20:28.000Z</updated>
    <summary type="html"><![CDATA[<h2>介绍</h2>
<p><strong>《后端面试高频系统设计&amp;场景题》</strong> 是我的<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>的一个内部小册，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。</p>
<p>近年来，随着国内的技术面试越来越卷，越来越多的公司开始在面试中考察系统设计和场景问题，以此来更全面的考察求职者，不论是校招还是社招。不过，正常面试全是场景题的情况还是极少的，面试官一般会在面试中穿插一两个系统设计和场景题来考察你。</p>]]></summary>
    <content type="html"><![CDATA[<h2>介绍</h2>
<p><strong>《后端面试高频系统设计&amp;场景题》</strong> 是我的<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>的一个内部小册，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。</p>
<p>近年来，随着国内的技术面试越来越卷，越来越多的公司开始在面试中考察系统设计和场景问题，以此来更全面的考察求职者，不论是校招还是社招。不过，正常面试全是场景题的情况还是极少的，面试官一般会在面试中穿插一两个系统设计和场景题来考察你。</p>
<p>于是，我总结了这份《后端面试高频系统设计&amp;场景题》，包含了常见的系统设计案例比如短链系统、秒杀系统以及高频的场景题比如海量数据去重、第三方授权登录。</p>
<p>即使不是准备面试，我也强烈推荐你认真阅读这一系列文章，这对于提升自己系统设计思维和解决实际问题的能力还是非常有帮助的。并且，涉及到的很多案例都可以用到自己的项目上比如抽奖系统设计、第三方授权登录、Redis 实现延时任务的正确方式。</p>
<p>《后端面试高频系统设计&amp;场景题》本身是属于《Java 面试指北》的一部分，后面由于内容篇幅较多，因此被单独提了出来。</p>
<h2>内容概览</h2>
<figure><img src="https://oss.javaguide.cn/xingqiu/back-end-interview-high-frequency-system-design-and-scenario-questions-fengmian.png" alt="《后端面试高频系统设计&amp;场景题》" tabindex="0"><figcaption>《后端面试高频系统设计&amp;场景题》</figcaption></figure>
<h2>星球其他资源</h2>
<p><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>除了提供了 <strong>《Java 面试指北》</strong> 、 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《手写 RPC 框架》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册，还有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20220211231206733.png" alt="知识星球专栏概览" tabindex="0"><figcaption>知识星球专栏概览</figcaption></figure>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20220723120918434.png" alt="星球 PDF 面试手册" tabindex="0"><figcaption>星球 PDF 面试手册</figcaption></figure>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiufuwu.png" alt="星球服务" tabindex="0"></a><figcaption>星球服务</figcaption></figure>
<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 知识星球详细介绍</a>。</p>
<h2>星球限时优惠</h2>
<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg" alt="知识星球30元优惠卷" tabindex="0"><figcaption>知识星球30元优惠卷</figcaption></figure>
<p>进入星球之后，记得查看 <strong><a href="https://t.zsxq.com/0d18KSarv" target="_blank" rel="noopener noreferrer">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href="https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1" target="_blank" rel="noopener noreferrer">星球优质主题汇总</a></strong> 。</p>
<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>
<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>
]]></content>
    <category term="知识星球"/>
    <published>2023-06-15T08:04:34.000Z</published>
  </entry>
  <entry>
    <title type="text">CopyOnWriteArrayList 源码分析</title>
    <id>https://javaguide.cn/learning/java/collection/copyonwritearraylist-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/copyonwritearraylist-source-code.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<h2>CopyOnWriteArrayList 简介</h2>
<p>在 JDK1.5 之前，如果想要使用并发安全的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <code>synchronized</code>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。</p>
<p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。关于<code>java.util.concurrent</code> 包下常见并发容器的总结，可以看我写的这篇文章：<a href="https://javaguide.cn/java/concurrent/java-concurrent-collections.html" target="_blank" rel="noopener noreferrer">Java 常见并发容器总结</a> 。</p>]]></summary>
    <content type="html"><![CDATA[<h2>CopyOnWriteArrayList 简介</h2>
<p>在 JDK1.5 之前，如果想要使用并发安全的 <code>List</code> 只能选择 <code>Vector</code>。而 <code>Vector</code> 是一种老旧的集合，已经被淘汰。<code>Vector</code> 对于增删改查等方法基本都加了 <code>synchronized</code>，这种方式虽然能够保证同步，但这相当于对整个 <code>Vector</code> 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。</p>
<p>JDK1.5 引入了 <code>Java.util.concurrent</code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 <code>List</code> 实现就是 <code>CopyOnWriteArrayList</code> 。关于<code>java.util.concurrent</code> 包下常见并发容器的总结，可以看我写的这篇文章：<a href="https://javaguide.cn/java/concurrent/java-concurrent-collections.html" target="_blank" rel="noopener noreferrer">Java 常见并发容器总结</a> 。</p>
<h3>CopyOnWriteArrayList 到底有什么厉害之处？</h3>
<p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 <code>List</code> 的内部数据，毕竟对于读取操作来说是安全的。</p>
<p>这种思路与 <code>ReentrantReadWriteLock</code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。<code>CopyOnWriteArrayList</code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，<code>CopyOnWriteArrayList</code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。</p>
<p><code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，从 <code>CopyOnWriteArrayList</code> 的名字就能看出了。</p>
<h3>Copy-On-Write 的思想是什么？</h3>
<p><code>CopyOnWriteArrayList</code>名字中的“Copy-On-Write”即写时复制，简称 COW。</p>
<p>下面是维基百科对 Copy-On-Write 的介绍，介绍的挺不错：</p>
<blockquote>
<p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
</blockquote>
<p>这里再以 <code>CopyOnWriteArrayList</code>为例介绍：当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） <code>CopyOnWriteArrayList</code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p>
<p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。</p>
<p>不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：</p>
<ol>
<li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li>
<li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li>
<li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li>
<li>……</li>
</ol>
<h2>CopyOnWriteArrayList 源码分析</h2>
<p>这里以 JDK1.8 为例，分析一下 <code>CopyOnWriteArrayList</code> 的底层核心源码。</p>
<p><code>CopyOnWriteArrayList</code> 的类定义如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
<span class="token keyword">extends</span> <span class="token class-name">Object</span>
<span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span>
<span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>CopyOnWriteArrayList</code> 实现了以下接口：</p>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code> ：这是一个标志接口，表明实现这个接口的 <code>List</code> 集合是支持 <strong>快速随机访问</strong> 的。</li>
<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/copyonwritearraylist-class-diagram.png" alt="CopyOnWriteArrayList 类图" tabindex="0"><figcaption>CopyOnWriteArrayList 类图</figcaption></figure>
<h3>初始化</h3>
<p><code>CopyOnWriteArrayList</code> 中有一个无参构造函数和两个有参构造函数。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建一个空的 CopyOnWriteArrayList</span>
<span class="token keyword">public</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 按照集合的迭代器返回的顺序创建一个包含指定集合元素的 CopyOnWriteArrayList</span>
<span class="token keyword">public</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        elements <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        elements <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
            elements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">setArray</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建一个包含指定数组的副本的列表</span>
<span class="token keyword">public</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> toCopyIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>toCopyIn<span class="token punctuation">,</span> toCopyIn<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>插入元素</h3>
<p><code>CopyOnWriteArrayList</code> 的 <code>add()</code>方法有三个版本：</p>
<ul>
<li><code>add(E e)</code>：在 <code>CopyOnWriteArrayList</code> 的尾部插入元素。</li>
<li><code>add(int index, E element)</code>：在 <code>CopyOnWriteArrayList</code> 的指定位置插入元素。</li>
<li><code>addIfAbsent(E e)</code>：如果指定元素不存在，那么添加该元素。如果成功添加元素则返回 true。</li>
</ul>
<p>这里以<code>add(E e)</code>为例进行介绍：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">// 加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取原来的数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 原来数组的长度</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 元素放在新数组末尾</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token comment">// array指向新数组</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的源码可以看出：</p>
<ul>
<li><code>add</code>方法内部用到了 <code>ReentrantLock</code> 加锁，保证了同步，避免了多线程写的时候会复制出多个副本出来。锁被修饰保证了锁的内存地址肯定不会被修改，并且，释放锁的逻辑放在 <code>finally</code> 中，可以保证锁能被释放。</li>
<li><code>CopyOnWriteArrayList</code> 通过复制底层数组的方式实现写操作，即先创建一个新的数组来容纳新添加的元素，然后在新数组中进行写操作，最后将新数组赋值给底层数组的引用，替换掉旧的数组。这也就证明了我们前面说的：<code>CopyOnWriteArrayList</code> 线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略。</li>
<li>每次写操作都需要通过 <code>Arrays.copyOf</code> 复制底层数组，时间复杂度是 O(n) 的，且会占用额外的内存空间。因此，<code>CopyOnWriteArrayList</code> 适用于读多写少的场景，在写操作不频繁且内存资源充足的情况下，可以提升系统的性能表现。</li>
<li><code>CopyOnWriteArrayList</code> 中并没有类似于 <code>ArrayList</code> 的 <code>grow()</code> 方法扩容的操作。</li>
</ul>
<blockquote>
<p><code>Arrays.copyOf</code> 方法的时间复杂度是 O(n)，其中 n 表示需要复制的数组长度。因为这个方法的实现原理是先创建一个新的数组，然后将源数组中的数据复制到新数组中，最后返回新数组。这个方法会复制整个数组，因此其时间复杂度与数组长度成正比，即 O(n)。值得注意的是，由于底层调用了系统级别的拷贝指令，因此在实际应用中这个方法的性能表现比较优秀，但是也需要注意控制复制的数据量，避免出现内存占用过高的情况。</p>
</blockquote>
<h3>读取元素</h3>
<p><code>CopyOnWriteArrayList</code> 的读取操作是基于内部数组 <code>array</code> 并没有发生实际的修改，因此在读取操作时不需要进行同步控制和锁操作，可以保证数据的安全性。这种机制下，多个线程可以同时读取列表中的元素。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 底层数组，只能通过getArray和setArray方法访问</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> array<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过，<code>get</code>方法是弱一致性的，在某些情况下可能读到旧的元素值。</p>
<p><code>get(int index)</code>方法是分两步进行的：</p>
<ol>
<li>通过<code>getArray()</code>获取当前数组的引用；</li>
<li>直接从数组中获取下标为 index 的元素。</li>
</ol>
<p>这个过程并没有加锁，所以在并发环境下可能出现如下情况：</p>
<ol>
<li>线程 1 调用<code>get(int index)</code>方法获取值，内部通过<code>getArray()</code>方法获取到了 array 属性值；</li>
<li>线程 2 调用<code>CopyOnWriteArrayList</code>的<code>add</code>、<code>set</code>、<code>remove</code> 等修改方法时，内部通过<code>setArray</code>方法修改了<code>array</code>属性的值；</li>
<li>线程 1 还是从旧的 <code>array</code> 数组中取值。</li>
</ol>
<h3>获取列表中元素的个数</h3>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>CopyOnWriteArrayList</code>中的<code>array</code>数组每次复制都刚好能够容纳下所有元素，并不像<code>ArrayList</code>那样会预留一定的空间。因此，<code>CopyOnWriteArrayList</code>中并没有<code>size</code>属性<code>CopyOnWriteArrayList</code>的底层数组的长度就是元素个数，因此<code>size()</code>方法只要返回数组长度就可以了。</p>
<h3>删除元素</h3>
<p><code>CopyOnWriteArrayList</code>删除元素相关的方法一共有 4 个：</p>
<ol>
<li><code>remove(int index)</code>：移除此列表中指定位置上的元素。将任何后续元素向左移动（从它们的索引中减去 1）。</li>
<li><code>boolean remove(Object o)</code>：删除此列表中首次出现的指定元素，如果不存在该元素则返回 false。</li>
<li><code>boolean removeAll(Collection&lt;?&gt; c)</code>：从此列表中删除指定集合中包含的所有元素。</li>
<li><code>void clear()</code>：移除此列表中的所有元素。</li>
</ol>
<p>这里以<code>remove(int index)</code>为例进行介绍：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取可重入锁</span>
    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment">// 加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
         <span class="token comment">//获取当前array数组</span>
        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取当前array长度</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">//获取指定索引的元素(旧值)</span>
        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断删除的是否是最后一个元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
             <span class="token comment">// 如果删除的是最后一个元素，直接复制该元素前的所有元素到新的数组</span>
            <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// 分段复制，将index前的元素和index+1后的元素复制到新数组</span>
            <span class="token comment">// 新数组长度为旧数组长度-1</span>
            <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//将新数组赋值给array引用</span>
            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
         <span class="token comment">// 解锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>判断元素是否存在</h3>
<p><code>CopyOnWriteArrayList</code>提供了两个用于判断指定元素是否在列表中的方法：</p>
<ul>
<li><code>contains(Object o)</code>：判断是否包含指定元素。</li>
<li><code>containsAll(Collection&lt;?&gt; c)</code>：判断是否保证指定集合的全部元素。</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 判断是否包含指定元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取当前array数组</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用index尝试查找指定元素，如果返回值大于等于0，则返回true，否则返回false</span>
    <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 判断是否保证指定集合的全部元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取当前array数组</span>
    <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//获取数组长度</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">//遍历指定集合</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Object</span> e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//循环调用indexOf方法判断，只要有一个没有包含就直接返回false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">indexOf</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//最后表示全部包含或者制定集合为空集合，那么返回true</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>CopyOnWriteArrayList 常用方法测试</h2>
<p>代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建一个 CopyOnWriteArrayList 对象</span>
<span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 向列表中添加元素</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C++"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始列表："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 get 方法获取指定位置的元素</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表第二个元素为："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 remove 方法删除指定元素</span>
<span class="token keyword">boolean</span> result <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"C++"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"删除结果："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表删除元素后为："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 set 方法更新指定位置的元素</span>
list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Golang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表更新后为："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 add 方法在指定位置插入元素</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"PHP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表插入元素后为："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 size 方法获取列表大小</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表大小为："</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 removeAll 方法删除指定集合中所有出现的元素</span>
result <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">,</span> <span class="token string">"Golang"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"批量删除结果："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表批量删除元素后为："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 clear 方法清空列表中所有元素</span>
list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"列表清空后为："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出：</p>
<div class="language-plain" data-ext="plain" data-title="plain"><pre class="language-plain"><code>列表更新后为：[Java, Golang]
列表插入元素后为：[PHP, Java, Golang]
列表大小为：3
批量删除结果：true
列表批量删除元素后为：[PHP]
列表清空后为：[]
</code></pre></div><figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-06-08T12:34:44.000Z</published>
  </entry>
  <entry>
    <title type="text">LinkedList 源码分析</title>
    <id>https://javaguide.cn/learning/java/collection/linkedlist-source-code.html</id>
    <link href="https://javaguide.cn/learning/java/collection/linkedlist-source-code.html"/>
    <updated>2024-02-12T23:58:51.000Z</updated>
    <summary type="html"><![CDATA[<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiu.png" alt="JavaGuide官方知识星球" tabindex="0"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>
<h2>LinkedList 简介</h2>
<p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。关于 <code>LinkedList</code> 和<code>ArrayList</code>的详细对比，我们 <a href="/learning/java/collection/java-collection-questions-01.html" target="_blank">Java 集合常见面试题总结(上)</a>有详细介绍到。</p>]]></summary>
    <content type="html"><![CDATA[<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiu.png" alt="JavaGuide官方知识星球" tabindex="0"></a><figcaption>JavaGuide官方知识星球</figcaption></figure>
<h2>LinkedList 简介</h2>
<p><code>LinkedList</code> 是一个基于双向链表实现的集合类，经常被拿来和 <code>ArrayList</code> 做比较。关于 <code>LinkedList</code> 和<code>ArrayList</code>的详细对比，我们 <a href="/learning/java/collection/java-collection-questions-01.html" target="_blank">Java 集合常见面试题总结(上)</a>有详细介绍到。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png" alt="双向链表" tabindex="0"><figcaption>双向链表</figcaption></figure>
<p>不过，我们在项目中一般是不会使用到 <code>LinkedList</code> 的，需要用到 <code>LinkedList</code> 的场景几乎都可以使用 <code>ArrayList</code> 来代替，并且，性能通常会更好！就连 <code>LinkedList</code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 <code>LinkedList</code> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>另外，不要下意识地认为 <code>LinkedList</code> 作为链表就最适合元素增删的场景。我在上面也说了，<code>LinkedList</code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。</p>
<h3>LinkedList 插入和删除元素的时间复杂度？</h3>
<ul>
<li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
<li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li>
<li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h3>LinkedList 为什么不能实现 RandomAccess 接口？</h3>
<p><code>RandomAccess</code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 <code>LinkedList</code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 <code>RandomAccess</code> 接口。</p>
<h2>LinkedList 源码分析</h2>
<p>这里以 JDK1.8 为例，分析一下 <code>LinkedList</code> 的底层核心源码。</p>
<p><code>LinkedList</code> 的类定义如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">AbstractSequentialList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span>
<span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</p>
<p>阅读过 <code>ArrayList</code> 的源码我们就知道，<code>ArrayList</code> 同样继承了 <code>AbstractList</code> ， 所以 <code>LinkedList</code> 会有大部分方法和 <code>ArrayList</code> 相似。</p>
<p><code>LinkedList</code> 实现了以下接口：</p>
<ul>
<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。需要注意，<code>Deque</code> 的发音为 "deck" [dɛk]，这个大部分人都会读错。</li>
<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist--class-diagram.png" alt="LinkedList 类图" tabindex="0"><figcaption>LinkedList 类图</figcaption></figure>
<p><code>LinkedList</code> 中的元素是通过 <code>Node</code> 定义的：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">E</span> item<span class="token punctuation">;</span><span class="token comment">// 节点值</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向的下一个节点（后继节点）</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span> <span class="token comment">// 指向的前一个节点（前驱结点）</span>

    <span class="token comment">// 初始化参数顺序分别是：前驱结点、本身节点值、后继节点</span>
    <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>初始化</h3>
<p><code>LinkedList</code> 中有一个无参构造函数和一个有参构造函数。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建一个空的链表对象</span>
<span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象</span>
<span class="token keyword">public</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>插入元素</h3>
<p><code>LinkedList</code> 除了实现了 <code>List</code> 接口相关方法，还实现了 <code>Deque</code> 接口的很多方法，所以我们有很多种方式插入元素。</p>
<p>我们这里以 <code>List</code> 接口中相关的插入方法为例进行源码讲解，对应的是<code>add()</code> 方法。</p>
<p><code>add()</code> 方法有两个版本：</p>
<ul>
<li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li>
<li><code>add(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 在链表尾部插入元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在链表指定位置插入元素</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下标越界检查</span>
    <span class="token function">checkPositionIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断 index 是不是链表尾部位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> size<span class="token punctuation">)</span>
        <span class="token comment">// 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可</span>
        <span class="token function">linkLast</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 如果不是则调用 linkBefore 方法将其插入指定元素之前</span>
        <span class="token function">linkBefore</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将元素节点插入到链表尾部</span>
<span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将最后一个元素赋值（引用传递）给节点 l</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将 last 引用指向新节点</span>
    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment">// 判断尾节点是否为空</span>
    <span class="token comment">// 如果 l 是null 意味着这是第一次添加元素</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token comment">// 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next</span>
        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在指定元素之前插入元素</span>
<span class="token keyword">void</span> <span class="token function">linkBefore</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> succ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assert succ != null;断言 succ不为 null</span>
    <span class="token comment">// 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> succ<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token comment">// 初始化节点，并指明前驱和后继节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> e<span class="token punctuation">,</span> succ<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将 succ 节点前驱引用 prev 指向新节点</span>
    succ<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token comment">// succ 节点前驱的后继引用指向新节点</span>
        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3>获取元素</h3>
<p><code>LinkedList</code>获取元素相关的方法一共有 3 个：</p>
<ol>
<li><code>getFirst()</code>：获取链表的第一个元素。</li>
<li><code>getLast()</code>：获取链表的最后一个元素。</li>
<li><code>get(int index)</code>：获取链表指定位置的元素。</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 获取链表的第一个元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取链表的最后一个元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取链表指定位置的元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 下标越界检查，如果越界就抛异常</span>
  <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 返回链表中对应下标的元素</span>
  <span class="token keyword">return</span> <span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的核心在于 <code>node(int index)</code> 这个方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 返回指定下标的非空节点</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 断言下标未越界</span>
    <span class="token comment">// assert isElementIndex(index);</span>
    <span class="token comment">// 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token comment">// 遍历，循环向后查找，直至 i == index</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>get(int index)</code> 或 <code>remove(int index)</code> 等方法内部都调用了该方法来获取对应的节点。</p>
<p>从这个方法的源码可以看出，该方法通过比较索引值与链表 size 的一半大小来确定从链表头还是尾开始遍历。如果索引值小于 size 的一半，就从链表头开始遍历，反之从链表尾开始遍历。这样可以在较短的时间内找到目标节点，充分利用了双向链表的特性来提高效率。</p>
<h3>删除元素</h3>
<p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p>
<ol>
<li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li>
<li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li>
<li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li>
<li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li>
<li><code>void clear()</code>：移除此链表中的所有元素。</li>
</ol>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 删除并返回链表的第一个元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除并返回链表的最后一个元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">unlinkLast</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除链表中首次出现的指定元素，如果不存在该元素则返回 false</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>item <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果不为 null ,遍历链表找到要删除的节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">unlink</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 删除链表指定位置的元素</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下标越界检查，如果越界就抛异常</span>
    <span class="token function">checkElementIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token function">node</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的核心在于 <code>unlink(Node&lt;E&gt; x)</code> 这个方法：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">E</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 断言 x 不为 null</span>
    <span class="token comment">// assert x != null;</span>
    <span class="token comment">// 获取当前节点（也就是待删除节点）的元素</span>
    <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> x<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    <span class="token comment">// 获取当前节点的下一个节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 获取当前节点的前一个节点</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>

    <span class="token comment">// 如果前一个节点为空，则说明当前节点是头节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 直接让链表头指向当前节点的下一个节点</span>
        first <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果前一个节点不为空</span>
        <span class="token comment">// 将前一个节点的 next 指针指向当前节点的下一个节点</span>
        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 将当前节点的 prev 指针置为 null，，方便 GC 回收</span>
        x<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果下一个节点为空，则说明当前节点是尾节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 直接让链表尾指向当前节点的前一个节点</span>
        last <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果下一个节点不为空</span>
        <span class="token comment">// 将下一个节点的 prev 指针指向当前节点的前一个节点</span>
        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
        <span class="token comment">// 将当前节点的 next 指针置为 null，方便 GC 回收</span>
        x<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将当前节点元素置为 null，方便 GC 回收</span>
    x<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>unlink()</code> 方法的逻辑如下：</p>
<ol>
<li>首先获取待删除节点 x 的前驱和后继节点；</li>
<li>判断待删除节点是否为头节点或尾节点：
<ul>
<li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li>
<li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li>
<li>如果 x 不是头节点也不是尾节点，执行下一步操作</li>
</ul>
</li>
<li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li>
<li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li>
<li>将待删除节点 x 的元素置空，修改链表长度。</li>
</ol>
<p>可以参考下图理解（图源：<a href="https://www.tianxiaobo.com/2018/01/31/LinkedList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-JDK-1-8/" target="_blank" rel="noopener noreferrer">LinkedList 源码分析(JDK 1.8)</a>）：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkedlist-unlink.jpg" alt="unlink 方法逻辑" tabindex="0"><figcaption>unlink 方法逻辑</figcaption></figure>
<h3>遍历链表</h3>
<p>推荐使用<code>for-each</code> 循环来遍历 <code>LinkedList</code> 中的元素， <code>for-each</code> 循环最终会转换成迭代器形式。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"pear"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> fruit <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>LinkedList</code> 的遍历的核心就是它的迭代器的实现。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 双向迭代器</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// 表示上一次调用 next() 或 previous() 方法时经过的节点；</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastReturned<span class="token punctuation">;</span>
    <span class="token comment">// 表示下一个要遍历的节点；</span>
    <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    <span class="token comment">// 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span>
    <span class="token comment">// 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span>
</code></pre></div><p>下面我们对迭代器 <code>ListItr</code> 中的核心方法进行详细介绍。</p>
<p>我们先来看下从头到尾方向的迭代：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 判断还有没有下一个节点</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历</span>
    <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取下一个节点</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查在迭代过程中链表是否被修改过</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将 lastReturned 指向当前节点</span>
    lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token comment">// 将 next 指向下一个节点</span>
    next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再来看一下从尾到头方向的迭代：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 判断是否还有前一个节点</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextIndex <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取前一个节点</span>
<span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查是否在迭代过程中链表被修改</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果没有前一个节点，则抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将 lastReturned 和 next 指针指向上一个节点</span>
    lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//  Collection 接口的 removeIf 方法底层依然是基于迭代器</span>
list<span class="token punctuation">.</span><span class="token function">removeIf</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token operator">::</span><span class="token function">isNull</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> fruit <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>迭代器对应的移除元素的方法如下：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 从列表中删除上次被返回的元素</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检查是否在迭代过程中链表被修改</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果上次返回的节点为空，则抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 获取当前节点的下一个节点</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 从链表中删除上次返回的节点</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 修改指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>
        next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token comment">// 将上次返回的节点引用置为 null，方便 GC 回收</span>
    lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>LinkedList 常用方法测试</h2>
<p>代码：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 创建 LinkedList 对象</span>
<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加元素到链表末尾</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"pear"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表内容："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在指定位置插入元素</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表内容："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取指定位置的元素</span>
<span class="token class-name">String</span> fruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"索引为 2 的元素："</span> <span class="token operator">+</span> fruit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 修改指定位置的元素</span>
list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"grape"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表内容："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 删除指定位置的元素</span>
list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表内容："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 删除第一个出现的指定元素</span>
list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表内容："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取链表的长度</span>
<span class="token keyword">int</span> size <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"链表长度："</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 清空链表</span>
list<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"清空后的链表："</span> <span class="token operator">+</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出：</p>
<div class="language-plain" data-ext="plain" data-title="plain"><pre class="language-plain"><code>索引为 2 的元素：banana
链表内容：[apple, orange, banana, grape]
链表内容：[orange, banana, grape]
链表内容：[orange, grape]
链表长度：2
清空后的链表：[]
</code></pre></div><figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-06-07T05:18:39.000Z</published>
  </entry>
  <entry>
    <title type="text">工作五年之后，对技术和业务的思考</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA</a></p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA</a></p>
</blockquote>
<p>苦海无边，回头无岸。</p>
<h2>01 前言</h2>
<p>晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？</p>
<p>初入职场，大部分程序员会觉得苦学技术，以后会顺风顺水升职加薪，这样的想法没有错，但是不算全面，五年后你会不会继续做技术写代码这是核心问题。</p>
<p>初入职场，会觉得努力加班可以不断提升能力，可以学到技术的公司就算薪水低点也可以接受，但是五年之后会认为加班都是在不断挤压自己的上升空间，薪水低是人生的天花板。</p>
<p>这里想说的关键问题就是：初入职场的认知和想法大部分不会再适用于五年后的认知。</p>
<p>工作五年之后面临的最大压力就是选择：职场天花板，技术能力天花板，薪水天花板，三十岁天花板。</p>
<p>如何面对这些问题，是大部分程序员都在思考和纠结的。做选择的唯一参考点就是：利益最大化，这里可以理解为职场更好的升职加薪，顺风顺水。</p>
<p>五年，变化最大不是工作经验，能力积累，而是心态，清楚的知道现实和理想之间是存在巨大的差距。</p>
<h2>02 学会适应变化，并积累能力</h2>
<p>回首自己的职场五年，最认可的一句话就是：学会适应变化，并积累能力。</p>
<p>变化的就是，五年的时间技术框架更新迭代，开发工具的变迁，公司环境队友的更换，甚至是不同城市的流浪，想着能把肉体和灵魂安放在一处，有句很经典的话就是：唯一不变的就是变化本身。</p>
<p>要积累的是：解决问题的能力，思考方式，拓宽认知。</p>
<p>这种很难直白的描述，属于个人认知的范畴，不同的人有不一样的看法，所以只能站在大众化的角度去思考。</p>
<p>首先聊聊技术，大部分小白级别的，都希望自己的技术能力不断提高，争取做到架构师级别，但是站在当前的互联网环境中，这种想法实现难度还是偏高，这里既不是打击也不是为了抬杠。</p>
<p>可以观察一下现状，技术团队大的 20-30 人，小的 10-15 人，能有一个架构师去专门管理底层框架都是少有现象。</p>
<p>这个问题的原因很多，首先架构师的成本过高，环境架构也不是需要经常升级，说的难听点可能框架比项目生命周期更高。</p>
<p>所以大部分公司的大部分业务，基于现有大部分成熟的开源框架都可以解决，这也就导致架构师这个角色通常由项目主管代替或者级别较高的开发直接负责，这就是现实情况。</p>
<p>这就导致技术框架的选择思路就是：只选对的。即这方面的人才多，开源解决方案多，以此降低技术方面对公司业务发展的影响。</p>
<p>那为什么还要不断学习和积累技术能力？如果没有这个能力，程序员岗位可能根本走不了五年之久，需要用技术深度积累不断解决工作中的各种问题，用技术的广度提升自己实现业务需求的认知边界，这是安放肉体的根本保障。</p>
<p>这就是导致很多五年以后的程序员压力陡然升高的原因，走向管理岗的另一个壁垒就是业务思维和认知。</p>
<h2>03 提高业务能力的积累</h2>
<p>程序员该不该用心研究业务，这个问题真的没有纠结的必要，只要不是纯技术型的公司，都需要面对业务。</p>
<p>不管技术、运营、产品、管理层，都是在面向业务工作。</p>
<p>从自己职场轨迹来看，五年变化最大就是解决业务问题的能力，职场之初面对很多业务场景都不知道如何下手，到几年之后设计业务的解决方案。</p>
<p>这是大部分程序员在职场前五年跳槽就能涨薪的根本原因，面对业务场景，基于积累的经验和现有的开源工具，能快速给出合理的解决思路和实现过程。</p>
<p>工作五年可能对技术底层的清晰程度都没有初入职场的小白清楚，但是写的程序却可以避开很多坑坑洼洼，对于业务的审视也是很细节全面。</p>
<p>解决业务能力的积累，对于技术视野的宽度需求更甚，比如职场初期对于海量数据的处理束手无策，但是在工作几年之后见识数据行业的技术栈，真的就是技术选型的视野问题。</p>
<p>什么是衡量技术能力的标准？站在一个共识的角度上看：系统的架构与代码设计能适应业务的不断变化和各种需求。</p>
<p>相对比与技术，业务的变化更加快速频繁，高级工程师或者架构师之所以薪资高，这些角色一方面能适应业务的迭代，并且在工作中具有一定前瞻性，会考虑业务变化的情况下代码复用逻辑，这样的能力是需要一定的技术视野和业务思维的沉淀。</p>
<p>所以职场中：业务能说的井井有条，代码能写的明明白白，得到机会的可能性更大。</p>
<h2>04 不同的阶段技术和业务的平衡和选择</h2>
<p>从理性的角度看技术和业务两个方面，能让大部分人职场走的平稳顺利，但是不同的阶段对两者的平衡和选择是不一样的。</p>
<p>在思考如何选择的时候，可以参考二八原则的逻辑，即在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80%尽管是多数，却是次要的，因此又称二八定律。</p>
<p>个人真的非常喜欢这个原则，大部分人都不是天才，所以很难三心二意同时做好几件事情，在同一时间段内应该集中精力做好一件事件。</p>
<p>但是单纯的二八原则模式可能不适应大部分职场初期的人，因为初期要学习很多内容，如何在职场生存：专业能力，职场关系，为人处世，产品设计等等。</p>
<p>当然这些东西不是都要用心刻意学习，但是合理安排二二六原则或其他组合是更明智的，首先是专业能力要重点练习，其次可以根据自己的兴趣合理选择一到两个方面去慢慢了解，例如产品，运营，运维，数据等，毕竟三五年以后会不会继续写代码很难说，多给自己留个机会总是有备无患。</p>
<p>在职场初期，基本都是从技术角度去思考问题，如何快速提升自己的编码能力，在公司能稳定是首要目标，因此大部分时间都是在做基础编码和学习规范，这时可能 90%的心思都是放在基础编码上，另外 10%会学习环境架构。</p>
<p>最多一到两年，就会开始独立负责模块需求开发，需要自己设计整个代码思路，这里业务就会进入视野，要懂得业务上下游关联关系，学会思考如何设计代码结构，才能在需求变动的情况下代码改动较少，这个时候可能就会放 20%的心思在业务方面，30%学习架构方式。</p>
<p>三到五年这个时间段，是解决问题能力提升最快的时候，因为这个阶段的程序员基本都是在开发核心业务链路，例如交易、支付、结算、智能商业等模块，需要对业务整体有较清晰的把握能力，不然就是给自己挖坑，这个阶段要对业务流付出大量心血思考。</p>
<p>越是核心的业务线，越是容易爆发各种问题，如果在日常工作中不花心思处理各种细节问题，半夜异常自动的消息和邮件总是容易让人憔悴。</p>
<p>所以努力学习技术是提升自己，培养自己的业务认知也同样重要，个人认为这二者的分量平分秋色，只是需要在合适的阶段做出合理的权重划分。</p>
<h2>05 学会在职场做选择和生存</h2>
<p>基于技术能力和业务思维，学会在职场做选择和生存，这些是职场前五年一路走来的最大体会。</p>
<p>不管是技术还是业务，这两个概念依旧是个很大的命题，不容易把握，所以学会理清这两个方面能力中的公共模块是关键。</p>
<p>不管技术还是业务，都不可能从一家公司完全复制到另一家公司，但是可以把一家公司的技术框架，业务解决方案学会，并且带到另一家公司，例如技术领域内的架构、设计、流程、数据管理，业务领域内的思考方式、产品逻辑、分析等，这些是核心能力并且是大部分公司人才招聘的要求，所以这些才是工作中需要重点积累的。</p>
<p>人的精力是有限的，而且面对三十这个天花板，各种事件也会接连而至，在职场中学会合理安排时间并不断提升核心能力，这样才能保证自己的竞争力。</p>
<p>职场就像苦海无边，回首望去可能也没有岸边停泊，但是要具有换船的能力或者有个小木筏也就大差不差了。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <author>
      <name>知了一笑</name>
    </author>
    <category term="技术文章精选集"/>
    <contributor>
      <name>知了一笑</name>
    </contributor>
    <published>2023-06-04T16:54:06.000Z</published>
    <rights>Copyright by 知了一笑</rights>
  </entry>
  <entry>
    <title type="text">使用建议</title>
    <id>https://javaguide.cn/learning/javaguide/use-suggestion.html</id>
    <link href="https://javaguide.cn/learning/javaguide/use-suggestion.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>对于不准备面试的同学来说</strong> ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。</p>
<p><strong>对于准备面试的同学来说</strong> ，本文档涵盖 Java 程序员所需要掌握的核心知识的常见面试问题总结。</p>
<p>大部分人看 JavaGuide 应该都是为了准备技术八股文。<strong>那如何才能更高效地准备技术八股文？</strong></p>]]></summary>
    <content type="html"><![CDATA[<p><strong>对于不准备面试的同学来说</strong> ，本文档倾向于给你提供一个比较详细的学习路径，目录清晰，让你对于 Java 整体的知识体系有一个清晰认识。你可以跟着视频、书籍或者官方文档学习完某个知识点之后，然后来这里找对应的总结，帮助你更好地掌握对应的知识点。甚至说，你在有编程基础的情况下，想要学习某个知识点的话，可以直接看我的总结，这样学习效率会非常高。</p>
<p><strong>对于准备面试的同学来说</strong> ，本文档涵盖 Java 程序员所需要掌握的核心知识的常见面试问题总结。</p>
<p>大部分人看 JavaGuide 应该都是为了准备技术八股文。<strong>那如何才能更高效地准备技术八股文？</strong></p>
<p>对于技术八股文来说，尽量不要死记硬背，这种方式非常枯燥且对自身能力提升有限！但是！想要一点不背是不太现实的，只是说要结合实际应用场景和实战来理解记忆。</p>
<p>我一直觉得面试八股文最好是和实际应用场景和实战相结合。很多同学现在的方向都错了，上来就是直接背八股文，硬生生学成了文科，那当然无趣了。</p>
<p>举个例子：你的项目中需要用到 Redis 来做缓存，你对照着官网简单了解并实践了简单使用 Redis 之后，你去看了 Redis 对应的八股文。你发现 Redis 可以用来做限流、分布式锁，于是你去在项目中实践了一下并掌握了对应的八股文。紧接着，你又发现 Redis 内存不够用的情况下，还能使用 Redis Cluster 来解决，于是你就又去实践了一下并掌握了对应的八股文。</p>
<p>而且， <strong>面试中有水平的面试官都是根据你的项目经历来顺带着问一些技术八股文</strong> 。</p>
<p>举个例子：你的项目用到了消息队列，那面试官可能就会问你：为什么使用消息队列？项目中什么模块用到了消息队列？如何保证消息不丢失？如何保证消息的顺序性?（结合你使用的具体的消息队列来准备）……。</p>
<p><strong>一定要记住你的主要目标是理解和记关键词，而不是像背课文一样一字一句地记下来！</strong></p>
<p>另外，记录博客或者用自己的理解把对应的知识点讲给别人听也是一个不错的选择。</p>
<p>最后，准备技术面试的同学一定要定期复习（自测的方式非常好），不然确实会遗忘的。</p>
]]></content>
    <category term="走近项目"/>
    <published>2023-05-22T02:13:07.000Z</published>
  </entry>
  <entry>
    <title type="text">十年大厂成长之路</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w</a></p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w</a></p>
</blockquote>
<p>最近这段时间，有好几个年轻的同学和我聊到自己的迷茫。其中有关于技术成长的、有关于晋升的、有关于择业的。我很高兴他们愿意听我这个“过来人”分享自己的经验。</p>
<p>我自己毕业后进入大厂，在大厂工作 12 年，我说的内容都来自于我自己或者身边人的真实情况。尤其，我会把 <strong>【我自己走过的弯路】</strong> 和 <strong>【我看到过的优秀技术人的特质】</strong> 相结合来给出建议。</p>
<p>这些内容我觉得具有普遍的指导意义，所以决定做个整理分享出来。我相信，无论你在大厂还是小厂，如果你相信这些建议，或早或晚他们会帮助到你。</p>
<p>我自己工作 12 年，走了些弯路，所以我就来讲讲，“在一个技术人 10 年的发展过程中，应该注意些什么”。我们把内容分为两块：</p>
<ol>
<li><strong>十年技术路怎么走</strong></li>
<li><strong>一些重要选择</strong></li>
</ol>
<h2>01 十年技术路怎么走</h2>
<h3>【1-2 年】=&gt; 从“菜鸟”到“职业”</h3>
<p>应届生刚进入到工作时，会有各种不适应。比如写好的代码会被反复打回、和团队老司机讨论技术问题会有一堆问号、不敢提问和质疑、碰到问题一个人使劲死磕等等。</p>
<p><strong>简单来说就是，即使日以继夜地埋头苦干，最后也无法顺利的开展工作。</strong></p>
<p>这个阶段最重要的几个点：</p>
<p><strong>【多看多模仿】</strong>：比如写代码的时候，不要就像在学校完成书本作业那样只关心功能是否正确，还要关心模块的设计、异常的处理、代码的可读性等等。在你还没有了解这些内容的精髓之前，也要照猫画虎地模仿起来，慢慢地你就会越来越明白真实世界的代码是怎么写的，以及为什么要这么写。</p>
<p>做技术方案的时候也是同理，技术文档的要求你也许并不理解，但你可以先参考已有文档写起来。</p>
<p><strong>【脸皮厚一点】</strong>：不懂就问，你是新人大家都是理解的。你做的各种方案也可以多找老司机们 review，不要怕被看笑话。</p>
<p><strong>【关注工作方式】</strong>：比如发现需求在计划时间完不成就要尽快报风险、及时做好工作内容的汇报（例如周报）、开会后确定会议结论和 todo 项、承诺时间就要尽力完成、严格遵循公司的要求（例如发布规范、权限规范等）</p>
<p>一般来说，工作 2 年后，你就应该成为一个职业人。老板可以相信任何工作交到你的手里，不会出现“意外”（例如一个重要需求明天要上线了，突然被告知上不了）。</p>
<h3>【3-4 年】=&gt; 从“职业”到“尖兵”</h3>
<p>工作两年后，对业务以及现有系统的了解已经到达了一定的程度，技术同学会开始承担更有难度的技术挑战。</p>
<p>例如需要将性能提升到某一个水位、例如需要对某一个重要模块进行重构、例如有个重要的项目需要协同 N 个团队一起完成。</p>
<p>可见，上述的这些技术问题，难度都已经远远超过一个普通的需求。解决这些问题需要有一定的技术能力，同时也需要具备更高的协同能力。</p>
<p>这个阶段最重要的几个点：</p>
<p><strong>【技术能力提升】</strong>：无论是公司内还是公司外的技术内容，都要多做主动的学习。基本上这个阶段的技术难题都集中在【性能】【稳定性】和【扩展性】上，而这些内容在业界都是有成型的方法论的。</p>
<p><strong>【主人翁精神】</strong>：技术难题除了技术方案设计及落地外，背后还有一系列的其他工作。例如上线后对效果的观测、重点项目对于上下游改造和风险的了解程度、对于整个技改后续的计划（二期、三期的优化思路）等。</p>
<p>在工作四年后，基本上你成为了团队的一、二号技术位。很多技术难题即使不是你来落地，也是由你来决定方案。你会做调研、会做方案对比、会考虑整个技改的生命周期。</p>
<h3>【5-7 年】=&gt; 从“尖兵”到“专家”</h3>
<p>技术尖兵重点在于解决某一个具体的技术难题或者重点项目。而下一步的发展方向，就是能够承担起来一整个“业务板块”，也就是“领域技术专家”。</p>
<p>想要承担一整个“业务板块”需要 <strong>【对业务领域有深刻的理解，同时基于这些理解来规划技术的发展方向】</strong> 。</p>
<p>拿支付做个例子。简单的支付功能其实很容易完成，只要处理好和双联（网联和银联）的接口调用（成功、失败、异常）即可。但在很多背景下，支付没有那么简单。</p>
<p>例如，支付是一个用户敏感型操作，非常强调用户体验，如何能兼顾体验和接口的不稳定？支付接口还需要承担费用，同步和异步的接口费用不同，如何能够降本？支付接口往往还有限额等。这一系列问题的背后涉及到很多技术的设计，包括异步化、补偿设计、资金流设计、最终一致性设计等等。</p>
<p>这个阶段最重要的几个点：</p>
<p><strong>【深入理解行业及趋势】</strong>：密切关注行业的各种变化（新鲜的玩法、政策的变动、竞对的策略、科技等外在因素的影响等等），和业务同学加强沟通。</p>
<p><strong>【深入了解行业解决方案】</strong>：充分对标已有的国内外技术方案，做深入学习和尝试，评估建设及运维成本，结合业务趋势制定计划。</p>
<h3>【8-10 年】=&gt; 从“专家”到“TL”</h3>
<p>其实很多时候，如果能做到专家，基本也是一个 TL 的角色了，但这并不代表正在执行 TL 的职责。</p>
<p>专家虽然已经可以做到“为业务发展而规划好技术发展”，但问题是要怎么落地呢？显然，靠一个人的力量是不可能完成建设的。所以，这里的 TL 更多强调的不是“领导”这个职位，而是 <strong>【通过聚合一个团队的力量来实施技术规划】</strong> 。</p>
<p>所以，这里的 TL 需要具备【团队技术培养】【合理分配资源】【确认工作优先级】【激励与奖惩】等各种能力。</p>
<p>这个阶段最重要的几个点：</p>
<p><strong>【学习管理学】</strong>：这里的管理学当然不是指 PUA，而是指如何在每个同学都有各自诉求的现实背景下，让个人目标和团队目标相结合，产生向前发展的动力。</p>
<p><strong>【始终扎根技术】</strong>：很多时候，工作重心偏向管理以后，就会荒废技术。但事实是，一个优秀的领导永远是一个优秀的技术人。参与一起讨论技术方案并给予指导、不断扩展自己的技术宽度、保持对技术的好奇心，这些是让一个技术领导持续拥有向心力的关键。</p>
<h2>02 一些重要选择</h2>
<p>下面来聊聊在十年间我们可能会碰到的一些重要选择。这些都是真实的血与泪的教训。</p>
<h3>我该不该转岗？</h3>
<p>大厂都有转岗的机制。转岗可以帮助员工寻找自己感兴趣的方向，也可以帮助新型团队招募有即战力的同学。</p>
<p>转岗看似只是在公司内部变动，但你需要谨慎决定。</p>
<p>本人转岗过多次。虽然还在同一家公司，但转岗等同于换工作。无论是领域沉淀、工作内容、信任关系、协作关系都是从零开始。</p>
<p>针对转岗我的建议是：**如果你是想要拓宽自己的技术广度，也就是抱着提升技术能力的想法，我觉得可以转岗。但如果你想要晋升，不建议你转岗。**晋升需要在一个领域的持续积淀和在一个团队信任感的持续建立。</p>
<p>当然，转岗可能还有其他原因，例如家庭原因、身体原因等，这个不展开讨论了。</p>
<h3>我该不该跳槽？</h3>
<p>跳槽和转岗一样，往往有很多因素造成，不能一概而论，我仅以几个场景来说：</p>
<p><strong>【晋升失败】</strong>：扪心自问，如果你觉得自己确实还不够格，那你就踏踏实实继续努力。如果你觉得评委有失偏颇，你可以尝试去外面面试一下，让市场来给你答案。</p>
<p><strong>【成长局限】</strong>：觉得自己做的事情没有挑战，无法成长。你可以和老板聊一下，有可能是因为你没有看到其中的挑战，也有可能老板没有意识到你的“野心”。</p>
<p><strong>【氛围不适】</strong>：一般来自于新入职或者领导更换，这种情况下不适是正常的。我的建议是，<strong>如果一个环境是“对事不对人”的，那就可以留下来</strong>，努力去适应，这种不适应只是做事方式不同导致的。但如果这个环境是“对人不对事”的话，走吧。</p>
<h3>跳槽该找怎样的工作？</h3>
<p>我们跳槽的时候往往会同时面试好几家公司。行情好的时候，往往可以收到多家 offer，那么我们要如何选择呢？</p>
<p>考虑一个 offer 往往有这几点：【公司品牌】【薪资待遇】【职级职称】【技术背景】。每个同学其实都有自己的诉求，所以无论做什么选择都没有对错之分。</p>
<p>我的一个建议是：<strong>你要关注新岗位的空间，这个空间是有希望满足你的期待的</strong>。</p>
<p>比如，你想成为架构师，那新岗位是否有足够的技术挑战来帮助你提升技术能力，而不仅仅是疲于奔命地应付需求？</p>
<p>比如，你想往技术管理发展，那新岗位是否有带人的机会？是否有足够的问题需要搭建团队来解决？</p>
<p>比如，你想扎根在某个领域持续发展（例如电商、游戏），那新岗位是不是延续这个领域，并且可以碰到更多这个领域的问题？</p>
<p>当然，如果薪资实在高到无法拒绝，以上参考可以忽略!</p>
<h2>结语</h2>
<p>以上就是我对互联网从业技术人员十年成长之路的心得，希望在你困惑和关键选择的时候可以帮助到你。如果我的只言片语能够在未来的某个时间帮助到你哪怕一点，那将是我莫大的荣幸。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <author>
      <name>CodingBetterLife</name>
    </author>
    <category term="技术文章精选集"/>
    <contributor>
      <name>CodingBetterLife</name>
    </contributor>
    <published>2023-05-15T09:49:43.000Z</published>
    <rights>Copyright by CodingBetterLife</rights>
  </entry>
  <entry>
    <title type="text">32条总结教你提升职场经验</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/work/32-tips-improving-career.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/work/32-tips-improving-career.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：阿里开发者的一篇职场经验的分享。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g</a></p>
</blockquote>
<h2>成长的捷径</h2>
<ul>
<li>入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线；</li>
<li>写一篇技术博客大概需要两周左右，但可能是最快的成长方式；</li>
<li>一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）；</li>
<li>多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你；</li>
<li>不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全；</li>
<li>不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤；</li>
<li>思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者；</li>
<li>好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：阿里开发者的一篇职场经验的分享。</p>
<p><strong>原文地址：</strong> <a href="https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g</a></p>
</blockquote>
<h2>成长的捷径</h2>
<ul>
<li>入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线；</li>
<li>写一篇技术博客大概需要两周左右，但可能是最快的成长方式；</li>
<li>一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）；</li>
<li>多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你；</li>
<li>不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全；</li>
<li>不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤；</li>
<li>思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者；</li>
<li>好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。</li>
</ul>
<h2>功夫在日常</h2>
<ul>
<li>每行代码要代表自己当下的最高水平，你觉得无所谓的小细节，有可能就是在晋升场上伤害你的暗箭；</li>
<li>双周报不是工作日志流水账，不要被时间推着走，最起码要知道下次双周报里会有什么（小目标驱动）；</li>
<li>觉得日常都是琐碎工作、不技术、给师兄打杂等，可以尝试对手头事情做一下分类，想象成每个分类都是个小格子，这些格子连起来的终点就是自己的目标，这样每天不再是机械的做需求，而是有规划的填格子、为目标努力，甚至会给自己加需求，因为自己看清楚了要去哪里；</li>
<li>日常的言行举止是能力的显微镜，大部分人可能意识不到，自己的强大和虚弱是那么的明显，不要无谓的试图掩盖，更不存在蒙混过关。</li>
</ul>
<blockquote>
<p>最后一条大概意思就是有时候我们会在意自己在聚光灯下（述职、晋升、周报、汇报等）的表现，以为大家会根据这个评价自己。实际上日常是怎么完成业务需求、帮助身边同学、创造价值的，才是大家评价自己的依据，而且每个人是什么样的特质，合作过三次的伙伴就可以精准评价，在聚光灯下的表演只能骗自己。</p>
</blockquote>
<h2>学会被管理</h2>
<blockquote>
<p>上级、主管是泛指，开发对口的 PD 主管等也在范围内。</p>
</blockquote>
<ul>
<li>
<p>不要传播负面情绪，不要总是抱怨；</p>
</li>
<li>
<p>对上级不卑不亢更容易获得尊重，但不要当众反驳对方观点，分歧私下沟通；</p>
</li>
<li>
<p>好好做向上管理，尤其是对齐预期，沟通绩效出现 Surprise 双方其实都有责任，但倒霉的是自己；</p>
</li>
<li>
<p>尽量站在主管角度想问题：</p>
</li>
<li>
<ul>
<li>这样能理解很多过去感觉匪夷所思的决策；</li>
<li>不要在意谁执行、功劳是谁的等，为团队分忧赢得主管信任的重要性远远高于这些；</li>
<li>不要把这个原则理解为唯上，这种最让人不齿。</li>
</ul>
</li>
</ul>
<h2>思维转换</h2>
<ul>
<li>定义问题是个高阶能力，尽早形成 发现问题-&gt;定义问题-&gt;解决问题-&gt;消灭问题 的思维闭环；</li>
<li>定事情价值导向，做事情结果导向，讲事情问题导向；</li>
<li>讲不清楚，大概率不是因为自己是实干型，而是没想清楚，在晋升场更加明显；</li>
<li>当一个人擅长解决某一场景的问题的时候，时间越久也许越离不开这个场景（被人贴上一个标签很难，撕掉一个标签更难）。</li>
</ul>
<h2>要栓住情绪</h2>
<ul>
<li>学会控制情绪，没人会认真听一个愤怒的人在说什么；</li>
<li>再委屈、再愤怒也要保持理智，不要让自己成为需要被哄着的那种人；</li>
<li>足够自信的人才会坦率的承认自己的问题，很多时候我们被激怒了，只是因为对方指出了自己藏在深处的自卑；</li>
<li>伤害我们最深的既不是别人的所作所为，也不是自己犯的错误，而是我们对错误的回应。</li>
</ul>
<h2>成为 Leader</h2>
<blockquote>
<p>Manager 有下属，Leader 有追随者，管理者不需要很多，但人人都可以是 Leader。</p>
</blockquote>
<ul>
<li>让你信服、愿意追随的人不是职务上的 Manager，而是在帮助自己的那个人，自己想服众的话道理一样；</li>
<li>不要轻易对人做负面评价，片面认知下的评价可能不准确，不经意的传播更是会给对方带来极大的困扰；</li>
<li>Leader 如果不认同公司的使命、愿景、价值观，会过的特别痛苦；</li>
<li>困难时候不要否定自己的队友，多给及时、正向的反馈；</li>
<li>船长最重要的事情不是造船，而是激发水手对大海的向往；</li>
<li>Leader 的天然职责是让团队活下去，唯一的途径是实现上级、老板、公司经营者的目标，越是艰难的时候越明显；</li>
<li>Leader 的重要职责是识别团队需要被做的事情，并坚定信念，使众人行，越是艰难的时候越要坚定；</li>
<li>Leader 应该让自己遇到的每个人都感觉自己很重要、被需要。</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="技术文章精选集"/>
    <published>2023-05-15T09:49:43.000Z</published>
  </entry>
  <entry>
    <title type="text">JVM线上问题排查和性能调优案例</title>
    <id>https://javaguide.cn/learning/java/jvm/jvm-in-action.html</id>
    <link href="https://javaguide.cn/learning/java/jvm/jvm-in-action.html"/>
    <updated>2023-12-28T05:55:34.000Z</updated>
    <summary type="html"><![CDATA[<p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。</p>
<p>这篇文章，我会分享一些我看到的相关的案例。</p>
<p>下面是正文。</p>
<p><a href="https://juejin.cn/post/7205141492264976445" target="_blank" rel="noopener noreferrer">一次线上 OOM 问题分析 - 艾小仙 - 2023</a></p>
<ul>
<li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li>
<li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li>
<li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li>
<li><strong>资料</strong>：<a href="https://heapdump.cn/article/3489050" target="_blank" rel="noopener noreferrer">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</a>。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。</p>
<p>这篇文章，我会分享一些我看到的相关的案例。</p>
<p>下面是正文。</p>
<p><a href="https://juejin.cn/post/7205141492264976445" target="_blank" rel="noopener noreferrer">一次线上 OOM 问题分析 - 艾小仙 - 2023</a></p>
<ul>
<li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li>
<li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li>
<li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li>
<li><strong>资料</strong>：<a href="https://heapdump.cn/article/3489050" target="_blank" rel="noopener noreferrer">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</a>。</li>
</ul>
<p><a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html" target="_blank" rel="noopener noreferrer">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023</a></p>
<ul>
<li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li>
<li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li>
<li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。</li>
<li><strong>建议</strong>：正常情况下，<code>-Xmn</code>参数（控制 Young 区的大小）总是应当小于<code>-Xmx</code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li>
<li><strong>资料</strong>：<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html" target="_blank" rel="noopener noreferrer">最重要的 JVM 参数总结 - JavaGuide - 2023</a></li>
</ul>
<p><a href="https://juejin.cn/post/7078624931826794503" target="_blank" rel="noopener noreferrer">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></p>
<ul>
<li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li>
<li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li>
<li><strong>建议</strong>：远离 Hibernate。</li>
<li><strong>资料</strong>：<a href="https://liam.page/2020/07/17/memory-stat-in-TOP/" target="_blank" rel="noopener noreferrer">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</a></li>
</ul>
<p><a href="https://www.heapdump.cn/article/1661497" target="_blank" rel="noopener noreferrer">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021</a></p>
<ul>
<li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li>
<li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。</li>
<li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li>
</ul>
<p><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat" target="_blank" rel="noopener noreferrer">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></p>
<p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p>
<p><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ" target="_blank" rel="noopener noreferrer">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></p>
<ul>
<li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li>
<li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li>
</ul>
<p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html" target="_blank" rel="noopener noreferrer">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020</a></p>
<p>这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。</p>
<p><a href="https://juejin.cn/post/7311623433817571365" target="_blank" rel="noopener noreferrer">给祖传系统做了点 GC 调优，暂停时间降低了 90% - 京东云技术团队 - 2023</a></p>
<p>这篇文章提到了一个在规则引擎系统中遇到的 GC（垃圾回收）问题，主要表现为系统在启动后发生了一次较长的 Young GC（年轻代垃圾回收）导致性能下降。经过分析，问题的核心在于动态对象年龄判定机制，它导致了过早的对象晋升，引起了长时间的垃圾回收。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2023-05-10T08:36:34.000Z</published>
  </entry>
  <entry>
    <title type="text">分布式ID设计指南</title>
    <id>https://javaguide.cn/learning/distributed-system/distributed-id-design.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/distributed-id-design.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：<a href="https://mp.weixin.qq.com/s/bFDLb6U6EgI-DvCdLTq_QA" target="_blank" rel="noopener noreferrer">分布式 ID 生成服务的技术原理和项目实战</a> 。</p>
</div>
<p>网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。</p>]]></summary>
    <content type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：<a href="https://mp.weixin.qq.com/s/bFDLb6U6EgI-DvCdLTq_QA" target="_blank" rel="noopener noreferrer">分布式 ID 生成服务的技术原理和项目实战</a> 。</p>
</div>
<p>网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。</p>
<p>本文结合一些使用场景，进一步探讨业务场景中对 ID 有哪些具体的要求。</p>
<h2>场景一：订单系统</h2>
<p>我们在商场买东西一码付二维码，下单生成的订单号，使用到的优惠券码，联合商品兑换券码，这些是在网上购物经常使用到的单号，那么为什么有些单号那么长，有些只有几位数？有些单号一看就知道年月日的信息，有些却看不出任何意义？下面展开分析下订单系统中不同场景的 id 服务的具体实现。</p>
<h3>1、一码付</h3>
<p>我们常见的一码付，指的是一个二维码可以使用支付宝或者微信进行扫码支付。</p>
<p>二维码的本质是一个字符串。聚合码的本质就是一个链接地址。用户使用支付宝微信直接扫一个码付钱，不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码，这极大减少了用户扫码支付的时间。</p>
<p>实现原理是当客户用 APP 扫码后，网站后台就会判断客户的扫码环境。（微信、支付宝、QQ 钱包、京东支付、云闪付等）。</p>
<p>判断扫码环境的原理就是根据打开链接浏览器的 HTTP header。任何浏览器打开 http 链接时，请求的 header 都会有 User-Agent(UA、用户代理)信息。</p>
<p>UA 是一个特殊字符串头，服务器依次可以识别出客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等很多信息。</p>
<p>各渠道对应支付产品的名称不一样，一定要仔细看各支付产品的 API 介绍。</p>
<ol>
<li>微信支付：JSAPI 支付支付</li>
<li>支付宝：手机网站支付</li>
<li>QQ 钱包：公众号支付</li>
</ol>
<p>其本质均为在 APP 内置浏览器中实现 HTML5 支付。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png" alt="文库会员支付示例" tabindex="0"><figcaption>文库会员支付示例</figcaption></figure>
<p>文库的研发同学在这个思路上，做了优化迭代。动态生成一码付的二维码预先绑定用户所选的商品信息和价格，根据用户所选的商品动态更新。这样不仅支持一码多平台调起支付，而且不用用户选择商品输入金额，即可完成订单支付的功能，很丝滑。用户在真正扫码后，服务端才通过前端获取用户 UID，结合二维码绑定的商品信息，真正的生成订单，发送支付信息到第三方（qq、微信、支付宝），第三方生成支付订单推给用户设备，从而调起支付。</p>
<p>区别于固定的一码付，在文库的应用中，使用到了动态二维码，二维码本质是一个短网址，ID 服务提供短网址的唯一标志参数。唯一的短网址映射的 ID 绑定了商品的订单信息，技术和业务的深度结合，缩短了支付流程，提升用户的支付体验。</p>
<h3>2、订单号</h3>
<p>订单号在实际的业务过程中作为一个订单的唯一标识码存在，一般实现以下业务场景：</p>
<ol>
<li>用户订单遇到问题，需要找客服进行协助；</li>
<li>对订单进行操作，如线下收款，订单核销；</li>
<li>下单，改单，成单，退单，售后等系统内部的订单流程处理和跟进。</li>
</ol>
<p>很多时候搜索订单相关信息的时候都是以订单 ID 作为唯一标识符，这是由于订单号的生成规则的唯一性决定的。从技术角度看，除了 ID 服务必要的特性之外，在订单号的设计上需要体现几个特性：</p>
<p><strong>（1）信息安全</strong></p>
<p>编号不能透露公司的运营情况，比如日销、公司流水号等信息，以及商业信息和用户手机号，身份证等隐私信息。并且不能有明显的整体规律（可以有局部规律），任意修改一个字符就能查询到另一个订单信息，这也是不允许的。</p>
<p>类比于我们高考时候的考生编号的生成规则，一定不能是连号的，否则只需要根据顺序往下查询就能搜索到别的考生的成绩，这是绝对不可允许。</p>
<p><strong>（2）部分可读</strong></p>
<p>位数要便于操作，因此要求订单号的位数适中，且局部有规律。这样可以方便在订单异常，或者退货时客服查询。</p>
<p>过长的订单号或易读性差的订单号会导致客服输入困难且易错率较高，影响用户体验的售后体验。因此在实际的业务场景中，订单号的设计通常都会适当携带一些允许公开的对使用场景有帮助的信息，如时间，星期，类型等等，这个主要根据所涉及的编号对应的使用场景来。</p>
<p>而且像时间、星期这些自增长的属于作为订单号的设计的一部分元素，有助于解决业务累积而导致的订单号重复的问题。</p>
<p><strong>（3）查询效率</strong></p>
<p>常见的电商平台订单号大多是纯数字组成，兼具可读性的同时，int 类型相对 varchar 类型的查询效率更高，对在线业务更加友好。</p>
<h3>3、优惠券和兑换券</h3>
<p>优惠券、兑换券是运营推广最常用的促销工具之一，合理使用它们，可以让买家得到实惠，商家提升商品销量。常见场景有：</p>
<ol>
<li>在文库购买【文库 VIP+QQ 音乐年卡】联合商品，支付成功后会得到 QQ 音乐年卡的兑换码，可以去 QQ 音乐 App 兑换音乐会员年卡；</li>
<li>疫情期间，部分地方政府发放的消费券；</li>
<li>瓶装饮料经常会出现输入优惠编码兑换奖品。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-coupon.png" alt="优惠编码兑换奖品" tabindex="0"><figcaption>优惠编码兑换奖品</figcaption></figure>
<p>从技术角度看，有些场景适合 ID 即时生成，比如电商平台购物领取的优惠券，只需要在用户领取时分配优惠券信息即可。有些线上线下结合的场景，比如疫情优惠券，瓶盖开奖，京东卡，超市卡这种，则需要预先生成，预先生成的券码具备以下特性：</p>
<p>1.预先生成，在活动正式开始前提供出来进行活动预热；</p>
<p>2.优惠券体量大，以万为单位，通常在 10 万级别以上；</p>
<p>3.不可破解、仿制券码；</p>
<p>4.支持用后核销；</p>
<p>5.优惠券、兑换券属于广撒网的策略，所以利用率低，也就不适合使用数据库进行存储 <strong>（占空间，有效的数据又少）</strong>。</p>
<p>设计思路上，需要设计一种有效的兑换码生成策略，支持预先生成，支持校验，内容简洁，生成的兑换码都具有唯一性，那么这种策略就是一种特殊的编解码策略，按照约定的编解码规则支撑上述需求。</p>
<p>既然是一种编解码规则，那么需要约定编码空间(也就是用户看到的组成兑换码的字符)，编码空间由字符 a-z,A-Z,数字 0-9 组成，为了增强兑换码的可识别度，剔除大写字母 O 以及 I,可用字符如下所示，共 60 个字符：</p>
<p>abcdefghijklmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXZY0123456789</p>
<p>之前说过，兑换码要求近可能简洁，那么设计时就需要考虑兑换码的字符数，假设上限为 12 位，而字符空间有 60 位，那么可以表示的空间范围为 60^12=130606940160000000000000(也就是可以 12 位的兑换码可以生成天量,应该够运营同学挥霍了)，转换成 2 进制：</p>
<p>1001000100000000101110011001101101110011000000000000000000000(61 位)</p>
<p><strong>兑换码组成成分分析</strong></p>
<p>兑换码可以预先生成，并且不需要额外的存储空间保存这些信息，每一个优惠方案都有独立的一组兑换码(指运营同学组织的每一场运营活动都有不同的兑换码,不能混合使用, 例如双 11 兑换码不能使用在双 12 活动上)，每个兑换码有自己的编号，防止重复，为了保证兑换码的有效性，对兑换码的数据需要进行校验，当前兑换码的数据组成如下所示：</p>
<p>优惠方案 ID + 兑换码序列号 i + 校验码</p>
<p><strong>编码方案</strong></p>
<ol>
<li>兑换码序列号 i，代表当前兑换码是当前活动中第 i 个兑换码，兑换码序列号的空间范围决定了优惠活动可以发行的兑换码数目，当前采用 30 位 bit 位表示，可表示范围：1073741824（10 亿个券码）。</li>
<li>优惠方案 ID, 代表当前优惠方案的 ID 号，优惠方案的空间范围决定了可以组织的优惠活动次数，当前采用 15 位表示，可以表示范围：32768（考虑到运营活动的频率，以及 ID 的初始值 10000，15 位足够，365 天每天有运营活动，可以使用 54 年）。</li>
<li>校验码，校验兑换码是否有效，主要为了快捷的校验兑换码信息的是否正确，其次可以起到填充数据的目的，增强数据的散列性，使用 13 位表示校验位，其中分为两部分，前 6 位和后 7 位。</li>
</ol>
<p>深耕业务还会有区分通用券和单独券的情况，分别具备以下特点，技术实现需要因地制宜地思考。</p>
<ol>
<li>通用券：多个玩家都可以输入兑换，然后有总量限制，期限限制。</li>
<li>单独券：运营同学可以在后台设置兑换码的奖励物品、期限、个数，然后由后台生成兑换码的列表，兑换之后核销。</li>
</ol>
<h2>场景二：Tracing</h2>
<h3>1、日志跟踪</h3>
<p>在分布式服务架构下，一个 Web 请求从网关流入，有可能会调用多个服务对请求进行处理，拿到最终结果。这个过程中每个服务之间的通信又是单独的网络请求，无论请求经过的哪个服务出了故障或者处理过慢都会对前端造成影响。</p>
<p>处理一个 Web 请求要调用的多个服务，为了能更方便的查询哪个环节的服务出现了问题，现在常用的解决方案是为整个系统引入分布式链路跟踪。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-tracing.png" alt="在分布式链路跟踪" tabindex="0"><figcaption>在分布式链路跟踪</figcaption></figure>
<p>在分布式链路跟踪中有两个重要的概念：跟踪（trace）和 跨度（ span)。trace 是请求在分布式系统中的整个链路视图，span 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。</p>
<p>在整个请求的调用链中，请求会一直携带 traceid 往下游服务传递，每个服务内部也会生成自己的 spanid 用于生成自己的内部调用视图，并和 traceid 一起传递给下游服务。</p>
<h3>2、TraceId 生成规则</h3>
<p>这种场景下，生成的 ID 除了要求唯一之外，还要求生成的效率高、吞吐量大。traceid 需要具备接入层的服务器实例自主生成的能力，如果每个 trace 中的 ID 都需要请求公共的 ID 服务生成，纯纯的浪费网络带宽资源。且会阻塞用户请求向下游传递，响应耗时上升，增加了没必要的风险。所以需要服务器实例最好可以自行计算 tracid，spanid，避免依赖外部服务。</p>
<p>产生规则：服务器 IP + ID 产生的时间 + 自增序列 + 当前进程号 ，比如：</p>
<p>0ad1348f1403169275002100356696</p>
<p>前 8 位 0ad1348f 即产生 TraceId 的机器的 IP，这是一个十六进制的数字，每两位代表 IP 中的一段，我们把这个数字，按每两位转成 10 进制即可得到常见的 IP 地址表示方式 10.209.52.143，您也可以根据这个规律来查找到请求经过的第一个服务器。</p>
<p>后面的 13 位 1403169275002 是产生 TraceId 的时间。之后的 4 位 1003 是一个自增的序列，从 1000 涨到 9000，到达 9000 后回到 1000 再开始往上涨。最后的 5 位 56696 是当前的进程 ID，为了防止单机多进程出现 TraceId 冲突的情况，所以在 TraceId 末尾添加了当前的进程 ID。</p>
<h3>3、SpanId 生成规则</h3>
<p>span 是层的意思，比如在第一个实例算是第一层， 请求代理或者分流到下一个实例处理，就是第二层，以此类推。通过层，SpanId 代表本次调用在整个调用链路树中的位置。</p>
<p>假设一个 服务器实例 A 接收了一次用户请求，代表是整个调用的根节点，那么 A 层处理这次请求产生的非服务调用日志记录 spanid 的值都是 0，A 层需要通过 RPC 依次调用 B、C、D 三个服务器实例，那么在 A 的日志中，SpanId 分别是 0.1，0.2 和 0.3，在 B、C、D 中，SpanId 也分别是 0.1，0.2 和 0.3；如果 C 系统在处理请求的时候又调用了 E，F 两个服务器实例，那么 C 系统中对应的 spanid 是 0.2.1 和 0.2.2，E、F 两个系统对应的日志也是 0.2.1 和 0.2.2。</p>
<p>根据上面的描述可以知道，如果把一次调用中所有的 SpanId 收集起来，可以组成一棵完整的链路树。</p>
<p><strong>spanid 的生成本质：在跨层传递透传的同时，控制大小版本号的自增来实现的。</strong></p>
<h2>场景三：短网址</h2>
<p>短网址主要功能包括网址缩短与还原两大功能。相对于长网址，短网址可以更方便地在电子邮件，社交网络，微博和手机上传播，例如原来很长的网址通过短网址服务即可生成相应的短网址，避免折行或超出字符限制。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-short-url.png" alt="短网址作用" tabindex="0"><figcaption>短网址作用</figcaption></figure>
<p>常用的 ID 生成服务比如：MySQL ID 自增、 Redis 键自增、号段模式，生成的 ID 都是一串数字。短网址服务把客户的长网址转换成短网址，</p>
<p>实际是在 <a href="http://dwz.cn" target="_blank" rel="noopener noreferrer">dwz.cn</a> 域名后面拼接新产生的数字类型 ID，直接用数字 ID，网址长度也有些长，服务可以通过数字 ID 转更高进制的方式压缩长度。这种算法在短网址的技术实现上越来越多了起来，它可以进一步压缩网址长度。转进制的压缩算法在生活中有广泛的应用场景，举例：</p>
<ul>
<li>客户的长网址：<a href="https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner" target="_blank" rel="noopener noreferrer">https://wenku.baidu.com/ndbusiness/browse/wenkuvipcashier?cashier_code=PCoperatebanner</a></li>
<li>ID 映射的短网址：<a href="https://dwz.cn/2047601319t66" target="_blank" rel="noopener noreferrer">https://dwz.cn/2047601319t66</a> (演示使用，可能无法正确打开)</li>
<li>转进制后的短网址：<a href="https://dwz.cn/2ezwDJ0" target="_blank" rel="noopener noreferrer">https://dwz.cn/2ezwDJ0</a> (演示使用，可能无法正确打开)</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-05-05T02:23:30.000Z</published>
  </entry>
  <entry>
    <title type="text">Spring Cloud Gateway常见问题总结</title>
    <id>https://javaguide.cn/learning/distributed-system/spring-cloud-gateway-questions.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/spring-cloud-gateway-questions.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文重构完善自<a href="https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw" target="_blank" rel="noopener noreferrer">6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构</a>这篇文章。</p>
</blockquote>
<h2>什么是 Spring Cloud Gateway？</h2>
<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文重构完善自<a href="https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw" target="_blank" rel="noopener noreferrer">6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构</a>这篇文章。</p>
</blockquote>
<h2>什么是 Spring Cloud Gateway？</h2>
<p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 <strong>Zuul</strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。</p>
<p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway- demo.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。</p>
<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>
<ul>
<li>GitHub 地址： <a href="https://github.com/spring-cloud/spring-cloud-gateway" target="_blank" rel="noopener noreferrer">https://github.com/spring-cloud/spring-cloud-gateway</a></li>
<li>官网： <a href="https://spring.io/projects/spring-cloud-gateway" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-cloud-gateway</a></li>
</ul>
<h2>Spring Cloud Gateway 的工作流程？</h2>
<p>Spring Cloud Gateway 的工作流程如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-workflow.png" alt="Spring Cloud Gateway 的工作流程" tabindex="0"><figcaption>Spring Cloud Gateway 的工作流程</figcaption></figure>
<p>这是 Spring 官方博客中的一张图，原文地址：<a href="https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter" target="_blank" rel="noopener noreferrer">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a>。</p>
<p>具体的流程分析：</p>
<ol>
<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>
<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。</li>
<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>
<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。</li>
<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>
</ol>
<p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p>
<h2>Spring Cloud Gateway 的断言是什么？</h2>
<p>断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。</p>
<p>在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。</p>
<p>断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 <code>api/thirdparty</code>，就匹配到了第一个路由 <code>route_thirdparty</code>。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-example.png" alt="断言配置示例" tabindex="0"><figcaption>断言配置示例</figcaption></figure>
<p>常见的路由断言规则如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png" alt="Spring Cloud GateWay 路由断言规则" tabindex="0"><figcaption>Spring Cloud GateWay 路由断言规则</figcaption></figure>
<h2>Spring Cloud Gateway 的路由和断言是什么关系？</h2>
<p>Route 路由和 Predicate 断言的对应关系如下：：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-route.png" alt="路由和断言的对应关系" tabindex="0"><figcaption>路由和断言的对应关系</figcaption></figure>
<ul>
<li><strong>一对多</strong>：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。</li>
<li><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</li>
<li><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。</li>
</ul>
<h2>Spring Cloud Gateway 如何实现动态路由？</h2>
<p>在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。</p>
<p>Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。</p>
<p>实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 注册中心来做。 Spring Cloud Gateway 可以从注册中心获取服务的元数据（例如服务名称、路径等），然后根据这些信息自动生成路由规则。这样，当你添加、移除或更新服务实例时，网关会自动感知并相应地调整路由规则，无需手动维护路由配置。</p>
<p>其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config</a> 。</p>
<h2>Spring Cloud Gateway 的过滤器有哪些？</h2>
<p>过滤器 Filter 按照请求和响应可以分为两种：</p>
<ul>
<li><strong>Pre 类型</strong>：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</li>
<li><strong>Post 类型</strong>：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。</li>
</ul>
<p>另外一种分类是按照过滤器 Filter 作用的范围进行划分：</p>
<ul>
<li><strong>GatewayFilter</strong>：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</li>
<li><strong>GlobalFilter</strong>：全局过滤器，应用在所有路由上的过滤器。</li>
</ul>
<h3>局部过滤器</h3>
<p>常见的局部过滤器如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。</p>
<div class="language-yaml" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过滤器</span>
  <span class="token punctuation">-</span> RewritePath=/api/(<span class="token punctuation">?</span>&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span> <span class="token comment"># 将跳转路径中包含的 “api” 替换成空</span>
</code></pre></div><p>当然我们也可以自定义过滤器，本篇不做展开。</p>
<h3>全局过滤器</h3>
<p>常见的全局过滤器如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>全局过滤器最常见的用法是进行负载均衡。配置如下所示：</p>
<div class="language-yaml" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> route_member <span class="token comment"># 第三方微服务路由规则</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//passjava<span class="token punctuation">-</span>member <span class="token comment"># 负载均衡，将请求转发到注册中心注册的 passjava-member 服务</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment"># 断言</span>
            <span class="token punctuation">-</span> Path=/api/member/<span class="token important">**</span> <span class="token comment"># 如果前端请求路径包含 api/member，则应用这条路由规则</span>
          <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过滤器</span>
            <span class="token punctuation">-</span> RewritePath=/api/(<span class="token punctuation">?</span>&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span> <span class="token comment"># 将跳转路径中包含的api替换成空</span>
</code></pre></div><p>这里有个关键字 <code>lb</code>，用到了全局过滤器 <code>LoadBalancerClientFilter</code>，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。</p>
<h2>Spring Cloud Gateway 支持限流吗？</h2>
<p>Spring Cloud Gateway 自带了限流过滤器，对应的接口是 <code>RateLimiter</code>，<code>RateLimiter</code> 接口只有一个实现类 <code>RedisRateLimiter</code> （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。</p>
<p>从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。</p>
<h2>Spring Cloud Gateway 如何自定义全局异常处理？</h2>
<p>在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 <code>@RestControllerAdvice</code>和 <code>@ExceptionHandler</code>就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。</p>
<p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现<code>ErrorWebExceptionHandler</code>并重写其中的<code>handle</code>方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@RequiredArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalErrorWebExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">ErrorWebExceptionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> objectMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2>参考</h2>
<ul>
<li>Spring Cloud Gateway 官方文档：<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/" target="_blank" rel="noopener noreferrer">https://cloud.spring.io/spring-cloud-gateway/reference/html/</a></li>
<li>Creating a custom Spring Cloud Gateway Filter：<a href="https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter" target="_blank" rel="noopener noreferrer">https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter</a></li>
<li>全局异常处理: <a href="https://zhuanlan.zhihu.com/p/347028665" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/347028665</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-05-04T10:53:24.000Z</published>
  </entry>
  <entry>
    <title type="text">Disruptor常见问题总结</title>
    <id>https://javaguide.cn/learning/high-performance/message-queue/disruptor-questions.html</id>
    <link href="https://javaguide.cn/learning/high-performance/message-queue/disruptor-questions.html"/>
    <updated>2024-02-23T08:44:05.000Z</updated>
    <summary type="html"><![CDATA[<p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。</p>
<p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：<a href="https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A" target="_blank" rel="noopener noreferrer">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。</p>
<p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：<a href="https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A" target="_blank" rel="noopener noreferrer">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。</p>
<h2>Disruptor 是什么？</h2>
<p>Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。</p>
<p>根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 <a href="https://martinfowler.com/articles/lmax.html" target="_blank" rel="noopener noreferrer">The LMAX Architecture</a> 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。</p>
<p>LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke's Choice Awards(Duke 选择大奖)。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<blockquote>
<p>“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！</p>
</blockquote>
<p>我专门找到了 Oracle 官方当年颁布获得 Duke's Choice Awards 项目的那篇文章（文章地址：<a href="https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award%EF%BC%89" target="_blank" rel="noopener noreferrer">https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award）</a> 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。</p>
<figure><img src="https://oss.javaguide.cn/javaguide/image-20211015152323898.png" alt="2011 年的 Oracle 官方的 Duke's Choice Awards" tabindex="0"><figcaption>2011 年的 Oracle 官方的 Duke's Choice Awards</figcaption></figure>
<p>Disruptor 提供的功能优点类似于 Kafka、RocketMQ 这类分布式队列，不过，其作为范围是 JVM(内存)。</p>
<ul>
<li>Github 地址：<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener noreferrer">https://github.com/LMAX-Exchange/disruptor</a></li>
<li>官方教程： <a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html" target="_blank" rel="noopener noreferrer">https://lmax-exchange.github.io/disruptor/user-guide/index.html</a></li>
</ul>
<p>关于如何在 Spring Boot 项目中使用 Disruptor，可以看这篇文章：<a href="https://mp.weixin.qq.com/s/0iG5brK3bYF0BgSjX4jRiA" target="_blank" rel="noopener noreferrer">Spring Boot + Disruptor 实战入门</a> 。</p>
<h2>为什么要用 Disruptor？</h2>
<p>Disruptor 主要解决了 JDK 内置线程安全队列的性能和内存安全问题。</p>
<p><strong>JDK 中常见的线程安全的队列如下</strong>：</p>
<p>| 队列名字                | 锁                      | 是否有界 |<br>
|</p>
]]></content>
    <category term="高性能"/>
    <published>2023-05-04T10:53:24.000Z</published>
  </entry>
  <entry>
    <title type="text">NAT 协议详解（网络层）</title>
    <id>https://javaguide.cn/learning/cs-basics/network/nat.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/nat.html"/>
    <updated>2024-03-09T07:59:49.000Z</updated>
    <summary type="html"><![CDATA[<h2>应用场景</h2>
<p><strong>NAT 协议（Network Address Translation）</strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p>
<p>这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。</p>]]></summary>
    <content type="html"><![CDATA[<h2>应用场景</h2>
<p><strong>NAT 协议（Network Address Translation）</strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p>
<p>这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。</p>
<p>SOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。</p>
<h2>细节</h2>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo.png" alt="NAT 协议" tabindex="0"><figcaption>NAT 协议</figcaption></figure>
<p>假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为<code>10.0.0/24</code>。LAN 侧接口的 IP 地址为<code>10.0.0.4</code>，并且该子网内有至少三台主机，分别是<code>10.0.0.1</code>，<code>10.0.0.2</code>和<code>10.0.0.3</code>。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为<code>138.76.29.7</code>。</p>
<p>首先，针对以上信息，我们有如下事实需要说明：</p>
<ol>
<li>路由器的右侧子网的网络号为<code>10.0.0/24</code>，主机号为<code>10.0.0/8</code>，三台主机地址，以及路由器的 LAN 侧接口地址，均由 DHCP 协议规定。而且，该 DHCP 运行在路由器内部（路由器自维护一个小 DHCP 服务器），从而为子网内提供 DHCP 服务。</li>
<li>路由器的 WAN 侧接口地址同样由 DHCP 协议规定，但该地址是路由器从 ISP（网络服务提供商）处获得，也就是该 DHCP 通常运行在路由器所在区域的 DHCP 服务器上。</li>
</ol>
<p>现在，路由器内部还运行着 NAT 协议，从而为 LAN-WAN 间通信提供地址转换服务。为此，一个很重要的结构是 <strong>NAT 转换表</strong>。为了说明 NAT 的运行细节，假设有以下请求发生：</p>
<ol>
<li>主机<code>10.0.0.1</code>向 IP 地址为<code>128.119.40.186</code>的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机<code>10.0.0.1</code>将随机指派一个端口，如<code>3345</code>，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是<code>128.119.40.186</code>，但会先到达<code>10.0.0.4</code>）。</li>
<li><code>10.0.0.4</code>即路由器的 LAN 接口收到<code>10.0.0.1</code>的请求。路由器将为该请求指派一个新的源端口号，如<code>5001</code>，并将请求报文发送给 WAN 接口<code>138.76.29.7</code>。同时，在 NAT 转换表中记录一条转换记录<strong>138.76.29.7:5001——10.0.0.1:3345</strong>。</li>
<li>请求报文到达 WAN 接口，继续向目的主机<code>128.119.40.186</code>发送。</li>
</ol>
<p>之后，将会有如下响应发生：</p>
<ol>
<li>主机<code>128.119.40.186</code>收到请求，构造响应报文，并将其发送给目的地<code>138.76.29.7:5001</code>。</li>
<li>响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现<code>138.76.29.7:5001</code>在转换表中有记录，从而将其目的地址和目的端口转换成为<code>10.0.0.1:3345</code>，再发送到<code>10.0.0.4</code>上。</li>
<li>被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地<code>10.0.0.1</code>。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo2.png" alt="LAN-WAN 间通信提供地址转换" tabindex="0"><figcaption>LAN-WAN 间通信提供地址转换</figcaption></figure>
<p>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/2009" target="_blank" rel="noopener noreferrer">issue#2009</a>）：上图第四步的 Dest 值应该为 <code>10.0.0.1:3345</code> 而不是~~<code>138.76.29.7:5001</code>~~，这里笔误了。</p>
<h2>划重点</h2>
<p>针对以上过程，有以下几个重点需要强调：</p>
<ol>
<li>当请求报文到达路由器，并被指定了新端口号时，由于端口号有 16 位，因此，通常来说，一个路由器管理的 LAN 中的最大主机数 （ 的地址空间），但通常 SOHO 子网内不会有如此多的主机数量。</li>
<li>对于目的服务器来说，从来不知道“到底是哪个主机给我发送的请求”，它只知道是来自<code>138.76.29.7:5001</code>的路由器转发的请求。因此，可以说，**路由器在 WAN 和 LAN 之间起到了屏蔽作用，**所有内部主机发送到外部的报文，都具有同一个 IP 地址（不同的端口号），所有外部发送到内部的报文，也都只有一个目的地（不同端口号），是经过了 NAT 转换后，外部报文才得以正确地送达内部主机。</li>
<li>在报文穿过路由器，发生 NAT 转换时，如果 LAN 主机 IP 已经在 NAT 转换表中注册过了，则不需要路由器新指派端口，而是直接按照转换记录穿过路由器。同理，外部报文发送至内部时也如此。</li>
</ol>
<p>总结 NAT 协议的特点，有以下几点：</p>
<ol>
<li>NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。</li>
<li>LAN 主机 IP 地址的变更，无需通告 WAN。</li>
<li>WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。</li>
<li>LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。</li>
</ol>
<p>然而，NAT 协议由于其独特性，存在着一些争议。比如，可能你已经注意到了，<b>NAT 协议在 LAN 以外，标识一个内部主机时，使用的是端口号，因为 IP 地址都是相同的。</b>这种将端口号作为主机寻址的行为，可能会引发一些误会。此外，路由器作为网络层的设备，修改了传输层的分组内容（修改了源 IP 地址和端口号），同样是不规范的行为。但是，尽管如此，NAT 协议作为 IPv4 时代的产物，极大地方便了一些本来棘手的问题，一直被沿用至今。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="计算机基础"/>
    <published>2023-04-30T08:44:12.000Z</published>
  </entry>
  <entry>
    <title type="text">程序员简历编写指南(重要)</title>
    <id>https://javaguide.cn/learning/interview-preparation/resume-guide.html</id>
    <link href="https://javaguide.cn/learning/interview-preparation/resume-guide.html"/>
    <updated>2024-03-08T09:06:57.000Z</updated>
    <summary type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">友情提示</p>
<p>本文节选自 <strong><a href="/learning/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。</p>
</div>
<h2>前言</h2>
<p>一份好的简历可以在整个申请面试以及面试过程中起到非常重要的作用。</p>]]></summary>
    <content type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">友情提示</p>
<p>本文节选自 <strong><a href="/learning/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ……）、优质面经等内容。</p>
</div>
<h2>前言</h2>
<p>一份好的简历可以在整个申请面试以及面试过程中起到非常重要的作用。</p>
<p><strong>为什么说简历很重要呢？</strong> 我们可以从下面几点来说：</p>
<p><strong>1、简历就像是我们的一个门面一样，它在很大程度上决定了是否能够获得面试机会。</strong></p>
<ul>
<li>假如你是网申，你的简历必然会经过 HR 的筛选，一张简历 HR 可能也就花费 10 秒钟左右看一下，然后决定你能否进入面试。</li>
<li>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</li>
</ul>
<p>另外，就算你通过了第一轮的筛选获得面试机会，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<p><strong>2、简历上的内容很大程度上决定了面试官提问的侧重点。</strong></p>
<ul>
<li>一般情况下你的简历上注明你会的东西才会被问到（Java 基础、集合、并发、MySQL、Redis 、Spring、Spring Boot 这些算是每个人必问的），比如写了你熟练使用 Redis,那面试官就很大概率会问你 Redis 的一些问题，再比如你写了你在项目中使用了消息队列，那面试官大概率问很多消息队列相关的问题。</li>
<li>技能熟练度在很大程度上也决定了面试官提问的深度。</li>
</ul>
<p>在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。一般情况下，技术能力和学习能力比较厉害的，写出来的简历也比较棒！</p>
<h2>简历模板</h2>
<p>简历的样式真的非常非常重要！！！如果你的简历样式丑到没朋友的话，面试官真的没有看下去的欲望。一天处理上百份的简历的痛苦，你不懂！</p>
<p>我这里的话，推荐大家使用 Markdown 语法写简历，然后再将 Markdown 格式转换为 PDF 格式后进行简历投递。如果你对 Markdown 语法不太了解的话，可以花半个小时简单看一下 Markdown 语法说明: <a href="http://www.markdown.cn/" target="_blank" rel="noopener noreferrer">http://www.markdown.cn/</a>。</p>
<p>下面是我收集的一些还不错的简历模板：</p>
<ul>
<li>适合中文的简历模板收集（推荐，开源免费）：<a href="https://github.com/dyweb/awesome-resume-for-chinese" target="_blank" rel="noopener noreferrer">https://github.com/dyweb/awesome-resume-for-chinese</a></li>
<li>木及简历（推荐，部分免费） ： <a href="https://www.mujicv.com/" target="_blank" rel="noopener noreferrer">https://www.mujicv.com/</a></li>
<li>简单简历（推荐，部分免费）：<a href="https://easycv.cn/" target="_blank" rel="noopener noreferrer">https://easycv.cn/</a></li>
<li>极简简历（免费）： <a href="https://www.polebrief.com/index" target="_blank" rel="noopener noreferrer">https://www.polebrief.com/index</a></li>
<li>Markdown 简历排版工具（开源免费）：<a href="https://resume.mdnice.com/" target="_blank" rel="noopener noreferrer">https://resume.mdnice.com/</a></li>
<li>站长简历（收费，支持 AI 生成）：<a href="https://jianli.chinaz.com/" target="_blank" rel="noopener noreferrer">https://jianli.chinaz.com/</a></li>
<li>typora+markdown+css 自定义简历模板 ：<a href="https://github.com/Snailclimb/typora-markdown-resume" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/typora-markdown-resume</a></li>
<li>超级简历（部分收费） ： <a href="https://www.wondercv.com/" target="_blank" rel="noopener noreferrer">https://www.wondercv.com/</a></li>
</ul>
<p>上面这些简历模板大多是只有 1 页内容，很难展现足够的信息量。如果你不是顶级大牛（比如 ACM 大赛获奖）的话，我建议还是尽可能多写一点可以突出你自己能力的内容（校招生 2 页之内，社招生 3 页之内，记得精炼语言，不要过多废话）。</p>
<p>再总结几点 <strong>简历排版的注意事项</strong>：</p>
<ul>
<li>尽量简洁，不要太花里胡哨。</li>
<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>
<li>中文和数字英文之间加上空格的话看起来会舒服一点。</li>
</ul>
<p>另外，知识星球里还有真实的简历模板可供参考，地址：<a href="https://t.zsxq.com/12ypxGNzU" target="_blank" rel="noopener noreferrer">https://t.zsxq.com/12ypxGNzU</a> （需加入<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>获取）。</p>
<figure><img src="https://oss.javaguide.cn/javamianshizhibei/image-20230918073550606.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2>简历内容</h2>
<h3>个人信息</h3>
<ul>
<li>最基本的 ：姓名（身份证上的那个）、年龄、电话、籍贯、联系方式、邮箱地址</li>
<li>潜在加分项 ： Github 地址、博客地址（如果技术博客和 Github 上没有什么内容的话，就不要写了）</li>
</ul>
<p>示例：</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/20210428212337599.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>简历要不要放照片呢？</strong> 很多人写简历的时候都有这个问题。</p>
<p>其实放不放都行，影响不大，完全不用在意这个问题。除非，你投递的岗位明确要求要放照片。 不过，如果要放的话，不要放生活照，还是应该放正规一些的照片比如证件照。</p>
<h3>求职意向</h3>
<p>你想要应聘什么岗位，希望在什么城市。另外，你也可以将求职意向放到个人信息这块写。</p>
<p>示例：</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/20210428212410288.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3>教育经历</h3>
<p>教育经历也不可或缺。通过教育经历的介绍，你要确保能让面试官就可以知道你的学历、专业、毕业学校以及毕业的日期。</p>
<p>示例：</p>
<blockquote>
<p>北京理工大学 硕士，软件工程 2019.09 - 2022.01<br>
湖南大学 学士，应用化学 2015.09 ~ 2019.06</p>
</blockquote>
<h3>专业技能</h3>
<p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般 HR 可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。</p>
<p>下面是一份最新的 Java 后端开发技能清单，你可以根据自身情况以及岗位招聘要求做动态调整，核心思想就是尽可能满足岗位招聘的所有技能要求。</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/jinengmuban.png" alt="Java 后端技能模板" tabindex="0"><figcaption>Java 后端技能模板</figcaption></figure>
<p>我这里再单独放一个我看过的某位同学的技能介绍，我们来找找问题。</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/up-a58d644340f8ce5cd32f9963f003abe4233.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>上图中的技能介绍存在的问题：</p>
<ul>
<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>
<li>技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！</li>
<li>对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。</li>
</ul>
<h3>实习经历/工作经历（重要）</h3>
<p>工作经历针对社招，实习经历针对校招。</p>
<p>工作经历建议采用时间倒序的方式来介绍。实习经历和工作经历都需要简单突出介绍自己在职期间主要做了什么。</p>
<p>示例：</p>
<blockquote>
<p><strong>XXX 公司 （201X 年 X 月 ~ 201X 年 X 月 ）</strong></p>
<ul>
<li><strong>职位</strong>：Java 后端开发工程师</li>
<li><strong>工作内容</strong>：主要负责 XXX</li>
</ul>
</blockquote>
<h3>项目经历（重要）</h3>
<p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。</p>
<p>很多求职者的项目经历介绍都会面临过于啰嗦、过于简单、没突出亮点等问题。</p>
<p>项目经历介绍模板如下：</p>
<blockquote>
<p>项目名称（字号要大一些）</p>
<p>2017-05~2018-06 淘宝 Java 后端开发工程师</p>
<ul>
<li><strong>项目描述</strong> : 简单描述项目是做什么的。</li>
<li><strong>技术栈</strong> ：用了什么技术（如 Spring Boot + MySQL + Redis + Mybatis-plus + Spring Security + Oauth2）</li>
<li><strong>工作内容/个人职责</strong> : 简单描述自己做了什么，解决了什么问题，带来了什么实质性的改善。突出自己的能力，不要过于平淡的叙述。</li>
<li><strong>个人收获（可选）</strong> : 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用。通常是可以不用写个人收获的，因为你在个人职责介绍中写的东西已经表明了自己的主要收获。</li>
<li><strong>项目成果（可选）</strong> :简单描述这个项目取得了什么成绩。</li>
</ul>
</blockquote>
<p><strong>1、项目经历应该突出自己做了什么，简单概括项目基本情况。</strong></p>
<p>项目介绍尽量压缩在两行之内，不需要介绍太多，但也不要随便几个字就介绍完了。</p>
<p>另外，个人收获和项目成果都是可选的，如果选择写的话，也不要花费太多篇幅，记住你的重点是介绍工作内容/个人职责。</p>
<p><strong>2、技术架构直接写技术名词就行，不要再介绍技术是干嘛的了，没意义，属于无效介绍。</strong></p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/interview-preparation/46c92fbc5160e65dd85c451143177144.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>3、尽量减少纯业务的个人职责介绍，对于面试不太友好。尽量再多挖掘一些亮点（6~8 条个人职责介绍差不多了，做好筛选），最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目优化了某个模块的性能。</strong></p>
<p>即使不是你做的功能模块或者解决的问题，你只要搞懂吃透了就能拿来自己用，适当润色即可！</p>
<p>像性能优化方向上的亮点面试之前也比较容易准备，但也不要都是性能优化相关的，这种也算是一个极端。</p>
<p>另外，技术优化取得的成果尽量要量化一下：</p>
<ul>
<li>使用 xxx 技术解决了 xxx 问题，系统 QPS 从 xxx 提高到了 xxx。</li>
<li>使用 xxx 技术了优化了 xxx 接口，系统 QPS 从 xxx 提高到了 xxx。</li>
<li>使用 xxx 技术解决了 xxx 问题，查询速度优化了 xxx，系统 QPS 达到 10w+。</li>
<li>使用 xxx 技术优化了 xxx 模块，响应时间从 2s 降低到 0.2s。</li>
<li>……</li>
</ul>
<p>个人职责介绍示例（这里只是举例，不要照搬，结合自己项目经历自己去写，不然面试的时候容易被问倒） ：</p>
<ul>
<li>基于 Spring Cloud Gateway + Spring Security OAuth2 + JWT 实现微服务统一认证授权和鉴权，使用 RBAC 权限模型实现动态权限控制。</li>
<li>参与项目订单模块的开发，负责订单创建、删除、查询等功能，基于 Spring 状态机实现订单状态流转。</li>
<li>商品和订单搜索场景引入 Elasticsearch，并且实现了相关商品推荐以及搜索提示功能。</li>
<li>整合 Canal + RabbitMQ 将 MySQL 增量数据（如商品、订单数据）同步到 Elasticsearch。</li>
<li>利用 RabbitMQ 官方提供的延迟队列插件实现延时任务场景比如订单超时自动取消、优惠券过期提醒、退款处理。</li>
<li>消息推送系统引入 RabbitMQ 实现异步处理、削峰填谷和服务解耦，最高推送速度 10w/s，单日最大消息量 2000 万。</li>
<li>使用 MAT 工具分析 dump 文件解决了广告服务新版本上线后导致大量的服务超时告警的问题。</li>
<li>排查并解决扣费模块由于扣费父任务和反作弊子任务使用同一个线程池导致的死锁问题。</li>
<li>基于 EasyExcel 实现广告投放数据的导入导出，通过 MyBatis 批处理插入数据，基于任务表实现异步。</li>
<li>负责用户统计模块的开发，使用 CompletableFuture 并行加载后台用户统计模块的数据信息，平均相应时间从 3.5s 降低到 1s。</li>
<li>基于 Sentinel 对核心场景(如用户登入注册、收货地址查询等)进行限流、降级，保护系统，提升用户体验。</li>
<li>热门数据（如首页、热门博客）使用 Redis+Caffeine 两级缓存，解决了缓存击穿和穿透问题，查询速度毫秒级，QPS 30w+。</li>
<li>使用 CompletableFuture 优化购物车查询模块，对获取用户信息、商品详情、优惠券信息等异步 RPC 调用进行编排，响应时间从 2s 降低为 0.2s。</li>
<li>搭建 EasyMock 服务，用于模拟第三方平台接口，方便了在网络隔离情况下的接口对接工作。</li>
<li>基于 SkyWalking + Elasticsearch 搭建分布式链路追踪系统实现全链路监控。</li>
</ul>
<p><strong>4、如果你觉得你的项目技术比较落后的话，可以自己私下进行改进。重要的是让项目比较有亮点，通过什么方式就无所谓了。</strong></p>
<p>项目经历这部分对于简历来说非常重要，<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>的面试准备篇有好几篇关于优化项目经历的文章，建议你仔细阅读一下，应该会对你有帮助。</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/4e11dbc842054e53ad6c5f0445023eb5~tplv-k3u1fbpfcp-zoom-1.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>5、避免个人职责介绍都是围绕一个技术点来写，非常不可取。</strong></p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/image-20230424222513028.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>6、避免模糊性描述，介绍要具体（技术+场景+效果），也要注意精简语言（避免堆砌技术词，省略不必要的描述）。</strong></p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/interview-preparation/project-experience-avoiding-ambiguity-descriptio.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3>荣誉奖项（可选）</h3>
<p>如果你有含金量比较高的竞赛（比如 ACM、阿里的天池大赛）的获奖经历的话，荣誉奖项这块内容一定要写一下！并且，你还可以将荣誉奖项这块内容适当往前放，放在一个更加显眼的位置。</p>
<h3>校园经历（可选）</h3>
<p>如果有比较亮眼的校园经历的话就简单写一下，没有就不写！</p>
<h3>个人评价</h3>
<p><strong>个人评价就是对自己的解读，一定要用简洁的语言突出自己的特点和优势，避免废话！</strong> 像勤奋、吃苦这些比较虚的东西就不要扯了，面试官看着这种个人评价就烦。</p>
<p>我们可以从下面几个角度来写个人评价：</p>
<ul>
<li>文档编写能力、学习能力、沟通能力、团队协作能力</li>
<li>对待工作的态度以及个人的责任心</li>
<li>能承受的工作压力以及对待困难的态度</li>
<li>对技术的追求、对代码质量的追求</li>
<li>分布式、高并发系统开发或维护经验</li>
</ul>
<p>列举 3 个实际的例子：</p>
<ul>
<li>学习能力较强，大三参加国家软件设计大赛的时候快速上手 Python 写了一个可配置化的爬虫系统。</li>
<li>具有团队协作精神，大三参加国家软件设计大赛的时候协调项目组内 5 名开发同学，并对编码遇到困难的同学提供帮助，最终顺利在 1 个月的时间完成项目的核心功能。</li>
<li>项目经验丰富，在校期间主导过多个企业级项目的开发。</li>
</ul>
<h2>STAR 法则和 FAB 法则</h2>
<h3>STAR 法则（Situation Task Action Result）</h3>
<p>相信大家一定听说过 STAR 法则。对于面试，你可以将这个法则用在自己的简历以及和面试官沟通交流的过程中。</p>
<p>STAR 法则由下面 4 个单词组成（STAR 法则的名字就是由它们的首字母组成）：</p>
<ul>
<li><strong>Situation：</strong> 情景。 事情是在什么情况下发生的？</li>
<li><strong>Task：</strong> 任务。你的任务是什么？</li>
<li><strong>Action：</strong> 行动。你做了什么？</li>
<li><strong>Result：</strong> 结果。最终的结果怎样？</li>
</ul>
<h3>FAB 法则（Feature Advantage Benefit）</h3>
<p>除了 STAR 法则，你还需要了解在销售行业经常用到的一个叫做 FAB 的法则。</p>
<p>FAB 法则由下面 3 个单词组成（FAB 法则的名字就是由它们的首字母组成）：</p>
<ul>
<li><strong>Feature：</strong> 你的特征/优势是什么？</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<p>简单来说，<strong>FAB 法则主要是让你的面试官知道你的优势和你能为公司带来的价值。</strong></p>
<h2>建议</h2>
<h3>避免页数过多</h3>
<p>精简表述，突出亮点。校招简历建议不要超过 2 页，社招简历建议不要超过 3 页。如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</p>
<p>看了几千份简历，有少部分同学的简历页数都接近 10 页了，让我头皮发麻。</p>
<figure><img src="https://oss.javaguide.cn/zhishixingqiu/image-20230508223646164.png" alt="简历页数过多" tabindex="0"><figcaption>简历页数过多</figcaption></figure>
<h3>避免语义模糊</h3>
<p>尽量避免主观表述，少一点语义模糊的形容词。表述要简洁明了，简历结构要清晰。</p>
<p>举例：</p>
<ul>
<li>不好的表述：我在团队中扮演了很重要的角色。</li>
<li>好的表述：我作为后端技术负责人，领导团队完成后端项目的设计与开发。</li>
</ul>
<h3>注意简历样式</h3>
<p>简历样式同样很重要，一定要注意！不必追求花里胡哨，但要尽量保证结构清晰且易于阅读。</p>
<h3>其他</h3>
<ul>
<li>一定要使用 PDF 格式投递，不要使用 Word 或者其他格式投递。这是最基本的！</li>
<li>不会的东西就不要写在简历上了。注意简历真实性，适当润色没有问题。</li>
<li>工作经历建议采用时间倒序的方式来介绍，实习经历建议将最有价值的放在最前面。</li>
<li>将自己的项目经历完美的展示出来非常重要，重点是突出自己做了什么（挖掘亮点），而不是介绍项目是做什么的。</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多（精选 2~3 即可），而在于有亮点。</li>
<li>准备面试的过程中应该将你写在简历上的东西作为重点，尤其是项目经历上和技能介绍上的。</li>
<li>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</li>
</ul>
<h2>简历修改</h2>
<p>到目前为止，我至少帮助 <strong>6000+</strong> 位球友提供了免费的简历修改服务。由于个人精力有限，修改简历仅限加入星球的读者，需要帮看简历的话，可以加入 <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html#%E7%AE%80%E5%8E%86%E4%BF%AE%E6%94%B9" target="_blank" rel="noopener noreferrer"><strong>JavaGuide 官方知识星球</strong></a>（点击链接查看详细介绍）。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/简历修改2.jpg" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiufuwu.png" alt="星球服务" tabindex="0"></a><figcaption>星球服务</figcaption></figure>
<p>这里再提供一份限时专属优惠卷：</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg" alt="知识星球30元优惠卷" tabindex="0"><figcaption>知识星球30元优惠卷</figcaption></figure>
]]></content>
    <category term="面试准备"/>
    <published>2023-04-28T13:38:12.000Z</published>
  </entry>
  <entry>
    <title type="text">分布式锁常见实现方案总结</title>
    <id>https://javaguide.cn/learning/distributed-system/distributed-lock-implementations.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/distributed-lock-implementations.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">这是一则或许对你有用的小广告</p>
<ul>
<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href="/learning/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>
<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 官方知识星球</a></strong>。</li>
</ul>
</div>]]></summary>
    <content type="html"><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">这是一则或许对你有用的小广告</p>
<ul>
<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href="/learning/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank">《Java 面试指北 》</a></strong> (质量非常高，专为面试打造，配合 JavaGuide 食用效果最佳)。</li>
<li><strong>知识星球</strong>：技术专栏/一对一提问/简历修改/求职指南/面试打卡/不定时福利，欢迎加入 <strong><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 官方知识星球</a></strong>。</li>
</ul>
</div>
<p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。</p>
<h2>基于 Redis 实现分布式锁</h2>
<h3>如何基于 Redis 实现一个最简易的分布式锁？</h3>
<p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p>
<p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SETNX lockKey uniqueValue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">&gt;</span> SETNX lockKey uniqueValue
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> DEL lockKey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre></div><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p>
<p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p>
<div class="language-lua" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token operator">//</span> 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre></div><figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-setnx.png" alt="Redis 实现简易分布式锁" tabindex="0"><figcaption>Redis 实现简易分布式锁</figcaption></figure>
<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p>
<h3>为什么要给锁设置一个过期时间？</h3>
<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p>
<div class="language-bash" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SET lockKey uniqueValue EX <span class="token number">3</span> NX
OK
</code></pre></div><ul>
<li><strong>lockKey</strong>：加锁的锁名；</li>
<li><strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li>
<li><strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>
<li><strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>
</ul>
<p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p>
<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p>
<p>你或许在想：<strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p>
<h3>如何实现锁的优雅续期？</h3>
<p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：<strong><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener noreferrer">Redisson</a></strong> 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：<a href="https://redis.io/topics/distlock" target="_blank" rel="noopener noreferrer">https://redis.io/topics/distlock</a> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/redis-distributed-lock.png" alt="Distributed locks with Redis" tabindex="0"><figcaption>Distributed locks with Redis</figcaption></figure>
<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p>
<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redisson-renew-expiration.png" alt="Redisson 看门狗自动续期" tabindex="0"><figcaption>Redisson 看门狗自动续期</figcaption></figure>
<p>看门狗名字的由来于 <code>getLockWatchdogTimeout()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a href="https://github.com/redisson/redisson/releases/tag/redisson-3.17.6" target="_blank" rel="noopener noreferrer">redisson-3.17.6</a>）。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//默认 30秒，支持修改</span>
<span class="token keyword">private</span> <span class="token keyword">long</span> lockWatchdogTimeout <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Config</span> <span class="token function">setLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token keyword">long</span> lockWatchdogTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lockWatchdogTimeout <span class="token operator">=</span> lockWatchdogTimeout<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> lockWatchdogTimeout<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//......</span>
        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                <span class="token comment">//......</span>
                <span class="token comment">// 异步续期，基于 Lua 脚本</span>
                <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>
                future<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 无法续期</span>
                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">return</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>

                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 递归调用实现续期</span>
                        <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 取消续期</span>
                        <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
         <span class="token comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>
<p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>
            <span class="token comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span>
            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>
                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>
                    <span class="token string">"return 1; "</span> <span class="token operator">+</span>
                    <span class="token string">"end; "</span> <span class="token operator">+</span>
                    <span class="token string">"return 0;"</span><span class="token punctuation">,</span>
            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p>
<p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1.获取指定的分布式锁对象</span>
<span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.执行业务</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 4.释放锁</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p>
<h3>如何实现可重入锁？</h3>
<p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>
<p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p>
<p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p>
<p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redisson-readme-locks.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3>Redis 如何解决集群情况下分布式锁的可靠性？</h3>
<p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p>
<p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/redis-master-slave-distributed-lock.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>针对这个问题，Redis 之父 antirez 设计了 <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener noreferrer">Redlock 算法</a> 来解决。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redis.io-realock.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>
<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>
<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>
<p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener noreferrer">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505097&amp;idx=1&amp;sn=5c03cb769c4458350f4d4a321ad51f5a&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p>
<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p>
<p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p>
<h2>基于 ZooKeeper 实现分布式锁</h2>
<p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择。</p>
<h3>如何基于 ZooKeeper 实现分布式锁？</h3>
<p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p>
<p>获取锁：</p>
<ol>
<li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li>
<li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li>
<li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li>
<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>
</ol>
<p>释放锁：</p>
<ol>
<li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li>
<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li>
<li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-zookeeper.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>
<p><code>Curator</code>主要实现了下面四种锁：</p>
<ul>
<li><code>InterProcessMutex</code>：分布式可重入排它锁</li>
<li><code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li>
<li><code>InterProcessReadWriteLock</code>：分布式读写锁</li>
<li><code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li>
</ul>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">ZKUtils</span><span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分布式可重入排它锁</span>
<span class="token class-name">InterProcessLock</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 分布式不可重入排它锁</span>
<span class="token class-name">InterProcessLock</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessSemaphoreMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 将多个锁作为一个整体</span>
<span class="token class-name">InterProcessMultiLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"不能获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 资源操作</span>
    resource<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"释放多个锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3>为什么要用临时顺序节点？</h3>
<p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p>
<p>我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p>
<p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p>
<p>假设不使用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p>
<h3>为什么要设置对前一个节点的监听？</h3>
<blockquote>
<p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
</blockquote>
<p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p>
<p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p>
<h3>如何实现可重入锁？</h3>
<p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍（源码地址：<a href="https://github.com/apache/curator/blob/master/curator-recipes/src/main/java/org/apache/curator/framework/recipes/locks/InterProcessMutex.java" target="_blank" rel="noopener noreferrer">InterProcessMutex.java</a>）。</p>
<p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 获取可重入互斥锁，直到获取成功为止</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Lost connection while trying to acquire lock: "</span> <span class="token operator">+</span> basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p>
<p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取当前请求锁的线程</span>
  <span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 拿对应的 lockData</span>
  <span class="token class-name">LockData</span> lockData <span class="token operator">=</span> threadData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 第一次获取锁的话，lockData 为 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前线程获取过一次锁之后</span>
    <span class="token comment">// 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.</span>
    lockData<span class="token punctuation">.</span>lockCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 尝试获取锁</span>
  <span class="token class-name">String</span> lockPath <span class="token operator">=</span> internals<span class="token punctuation">.</span><span class="token function">attemptLock</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> <span class="token function">getLockNodeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockPath <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">LockData</span> newLockData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中</span>
    threadData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> newLockData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p>
<div class="language-java" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">,</span> <span class="token class-name">LockData</span><span class="token punctuation">&gt;</span></span> threadData <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LockData</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 当前持有锁的线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> owningThread<span class="token punctuation">;</span>
    <span class="token comment">// 锁对应的子节点</span>
    <span class="token keyword">final</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">;</span>
    <span class="token comment">// 加锁的次数</span>
    <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> lockCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> owningThread<span class="token punctuation">,</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>owningThread <span class="token operator">=</span> owningThread<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p>
<p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>
<h2>总结</h2>
<p>在这篇文章中，我介绍了实现分布式锁的两种常见方式： Redis 和 ZooKeeper。至于具体选择 Redis 还是 ZooKeeper 来实现分布式锁，还是要看业务的具体需求。</p>
<ul>
<li>如果对性能要求比较高的话，建议使用 Redis 实现分布式锁（优先选择 Redisson 提供的现成的分布式锁，而不是自己实现）。</li>
<li>如果对可靠性要求比较高的话，建议使用 ZooKeeper 实现分布式锁（推荐基于 Curator 框架实现）。不过，现在很多项目都不会用到 ZooKeeper，如果单纯是因为分布式锁而引入 ZooKeeper 的话，那是不太可取的，不建议这样做，为了一个小小的功能增加了系统的复杂度。</li>
</ul>
<p>最后，再分享两篇我觉得写的还不错的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/JzCHpIOiFVmBoAko58ZuGw" target="_blank" rel="noopener noreferrer">分布式锁实现原理与最佳实践 - 阿里云开发者</a></li>
<li><a href="https://mp.weixin.qq.com/s/-N4x6EkxwAYDGdJhwvmZLw" target="_blank" rel="noopener noreferrer">聊聊分布式锁 - 字节跳动技术团队</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-04-28T11:27:56.000Z</published>
  </entry>
  <entry>
    <title type="text">降级&amp;熔断详解(付费)</title>
    <id>https://javaguide.cn/learning/high-availability/fallback-and-circuit-breaker.html</id>
    <link href="https://javaguide.cn/learning/high-availability/fallback-and-circuit-breaker.html"/>
    <updated>2024-04-09T16:20:28.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>降级&amp;熔断</strong> 相关的面试题为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>中。</p>]]></summary>
    <content type="html"><![CDATA[<p><strong>降级&amp;熔断</strong> 相关的面试题为我的<a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>中。</p>
<p><a href="/learning/zhuanlan/java-mian-shi-zhi-bei.html" target="_blank">《Java 面试指北》</a>（点击链接即可查看详细介绍）的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/image-20220304102536445.png" alt="《Java 面试指北》内容概览" tabindex="0"><figcaption>《Java 面试指北》内容概览</figcaption></figure>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">Java 面试知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是知识星球里的内容质量更高，提供的服务也更全面，非常适合准备 Java 面试和学习 Java 的同学。</p>
<p><strong>欢迎准备 Java 面试以及学习 Java 的同学加入我的 <a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">知识星球</a>，干货非常多，学习氛围也很不错！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</strong></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<figure><a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank"><img src="https://oss.javaguide.cn/xingqiu/xingqiufuwu.png" alt="星球服务" tabindex="0"></a><figcaption>星球服务</figcaption></figure>
<p><strong>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</strong></p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍：<a href="/learning/about-the-author/zhishixingqiu-two-years.html" target="_blank">JavaGuide 知识星球详细介绍</a> 。</p>
<p>这里再送一个 <strong>30</strong> 元的星球专属优惠券，数量有限（价格即将上调。老用户续费半价 ，微信扫码即可续费）！</p>
<figure><img src="https://oss.javaguide.cn/xingqiu/xingqiuyouhuijuan-30.jpg" alt="知识星球30元优惠卷" tabindex="0"><figcaption>知识星球30元优惠卷</figcaption></figure>
<p>进入星球之后，记得查看 <strong><a href="https://t.zsxq.com/0d18KSarv" target="_blank" rel="noopener noreferrer">星球使用指南</a></strong> （一定要看！！！） 和 <strong><a href="https://t.zsxq.com/12uSKgTIm" target="_blank" rel="noopener noreferrer">星球优质主题汇总</a></strong>，干货多多！</p>
<p><strong>无任何套路，无任何潜在收费项。用心做内容，不割韭菜！</strong></p>
<p>不过， <strong>一定要确定需要再进</strong> 。并且， <strong>三天之内觉得内容不满意可以全额退款</strong> 。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="高可用"/>
    <published>2023-04-28T09:56:30.000Z</published>
  </entry>
  <entry>
    <title type="text">HTTP vs HTTPS（应用层）</title>
    <id>https://javaguide.cn/learning/cs-basics/network/http-vs-https.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/http-vs-https.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<h2>HTTP 协议</h2>
<h3>HTTP 协议介绍</h3>
<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3>HTTP 协议通信过程</h3>]]></summary>
    <content type="html"><![CDATA[<h2>HTTP 协议</h2>
<h3>HTTP 协议介绍</h3>
<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3>HTTP 协议通信过程</h3>
<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 80 端口等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<h3>HTTP 协议优点</h3>
<p>扩展性强、速度快、跨平台支持性好。</p>
<h2>HTTPS 协议</h2>
<h3>HTTPS 协议介绍</h3>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<h3>HTTPS 协议优点</h3>
<p>保密性好、信任度高。</p>
<h2>HTTPS 的核心—SSL/TLS 协议</h2>
<p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>
<h3>SSL 和 TLS 的区别？</h3>
<p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p>
<h3>SSL/TLS 的工作原理</h3>
<h4>非对称加密</h4>
<p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<figure><figcaption></figcaption></figure>
<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<figure><figcaption>单向函数</figcaption></figure>
<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>
<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<h4>对称加密</h4>
<p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<figure><figcaption></figcaption></figure>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h4>公钥传输的信赖性</h4>
<p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<figure><figcaption></figcaption></figure>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<h4>数字签名</h4>
<p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<figure><figcaption></figcaption></figure>
<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<figure><figcaption></figcaption></figure>
<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href="https://www.bilibili.com/video/BV18N411X7ty/" target="_blank" rel="noopener noreferrer">数字签名及数字证书原理</a>这个视频，这是我看过最清晰的讲解。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/image-20220321121814946.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2>总结</h2>
<ul>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="计算机基础"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">HTTP 1.0 vs HTTP 1.1（应用层）</title>
    <id>https://javaguide.cn/learning/cs-basics/network/http1.0-vs-http1.1.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/http1.0-vs-http1.1.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p>
<ul>
<li>响应状态码</li>
<li>缓存处理</li>
<li>连接方式</li>
<li>Host 头处理</li>
<li>带宽优化</li>
</ul>
<h2>响应状态码</h2>
<p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p>
<ul>
<li>响应状态码</li>
<li>缓存处理</li>
<li>连接方式</li>
<li>Host 头处理</li>
<li>带宽优化</li>
</ul>
<h2>响应状态码</h2>
<p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<h2>缓存处理</h2>
<p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p>
<h3>HTTP/1.0</h3>
<p>HTTP/1.0 提供的缓存机制非常简单。服务器端使用<code>Expires</code>标签来标志（时间）一个响应体，在<code>Expires</code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个<code>Last-Modified</code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用<code>If-Modified-Since</code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的<code>If-Modified-Since</code>的值即为上一次获得该资源时，响应体中的<code>Last-Modified</code>的值。</p>
<p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p>
<p>如果服务器判断<code>If-Modified-Since</code>时间后，资源被修改过，则返回给客户端一个<code>200 OK</code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p>
<figure><figcaption>HTTP1.0cache1</figcaption></figure>
<figure><figcaption>HTTP1.0cache2</figcaption></figure>
<h3>HTTP/1.1</h3>
<p>HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code>，详见 MDN Web 文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener noreferrer">Cache-Control</a>.</p>
<h2>连接方式</h2>
<p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p>
<p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该 TCP 连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p>
<p>有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p>
<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>
<p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p>
<h2>Host 头处理</h2>
<p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是<a href="http://example1.org/home.html%EF%BC%8CHTTP/1.0" target="_blank" rel="noopener noreferrer">http://example1.org/home.html，HTTP/1.0</a> 的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>
<p>因此，HTTP/1.1 在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p>
<div class="language-plain" data-ext="plain" data-title="plain"><pre class="language-plain"><code>GET /home.html HTTP/1.1
Host: example1.org
</code></pre></div><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>
<h2>带宽优化</h2>
<h3>范围请求</h3>
<p>HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入<code>Range</code>头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略<code>Range</code>头部，也可以返回若干<code>Range</code>响应。</p>
<p>如果一个响应包含部分数据的话，那么将带有<code>206 (Partial Content)</code>状态码。该状态码的意义在于避免了 HTTP/1.0 代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。</p>
<p>在范围响应中，<code>Content-Range</code>头部标志指示出了该数据块的偏移量和数据块的长度。</p>
<h3>状态码 100</h3>
<p>HTTP/1.1 中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p>
<figure><figcaption>HTTP1.1continue1</figcaption></figure>
<figure><figcaption>HTTP1.1continue2</figcaption></figure>
<p>然而在 HTTP/1.0 中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值。</p>
<h3>压缩</h3>
<p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p>
<p>HTTP/1.1 则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。</p>
<p>HTTP/1.0 包含了<code>Content-Encoding</code>头部，对消息进行端到端编码。HTTP/1.1 加入了<code>Transfer-Encoding</code>头部，可以对消息进行逐跳传输编码。HTTP/1.1 还加入了<code>Accept-Encoding</code>头部，是客户端用来指示他能处理什么样的内容编码。</p>
<h2>总结</h2>
<ol>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host 头处理</strong> : HTTP/1.1 在请求头中加入了<code>Host</code>字段。</li>
</ol>
<h2>参考资料</h2>
<p><a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf" target="_blank" rel="noopener noreferrer">Key differences between HTTP/1.0 and HTTP/1.1</a></p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="计算机基础"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">OSI 和 TCP/IP 网络分层模型详解（基础）</title>
    <id>https://javaguide.cn/learning/cs-basics/network/osi-and-tcp-ip-model.html</id>
    <link href="https://javaguide.cn/learning/cs-basics/network/osi-and-tcp-ip-model.html"/>
    <updated>2024-01-13T06:48:32.000Z</updated>
    <summary type="html"><![CDATA[<h2>OSI 七层模型</h2>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" tabindex="0"><figcaption>OSI 七层模型</figcaption></figure>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>]]></summary>
    <content type="html"><![CDATA[<h2>OSI 七层模型</h2>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" tabindex="0"><figcaption>OSI 七层模型</figcaption></figure>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/osi七层模型2.png" alt="osi七层模型2" tabindex="0"><figcaption>osi七层模型2</figcaption></figure>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>
<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2>TCP/IP 四层模型</h2>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型" tabindex="0"><figcaption>TCP/IP 四层模型</figcaption></figure>
<h3>应用层（Application layer）</h3>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-five-layer-sample-diagram.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><strong>应用层常见协议</strong>：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层常见协议" tabindex="0"><figcaption>应用层常见协议</figcaption></figure>
<ul>
<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>
<li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li>
<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>
<li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li>
</ul>
<p>关于这些协议的详细介绍请看 <a href="/learning/cs-basics/network/application-layer-protocol.html" target="_blank">应用层常见协议总结（应用层）</a> 这篇文章。</p>
<h3>传输层（Transport layer）</h3>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>传输层常见协议</strong>：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层常见协议" tabindex="0"><figcaption>传输层常见协议</figcaption></figure>
<ul>
<li><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li>
<li><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li>
</ul>
<h3>网络层（Network layer）</h3>
<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️ 注意：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><strong>网络层常见协议</strong>：</p>
<figure><figcaption>网络层常见协议</figcaption></figure>
<ul>
<li><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li>
<li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li>
<li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>
<li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
<li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li>
</ul>
<h3>网络接口层（Network interface layer）</h3>
<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<p>网络接口层重要功能和协议如下图所示：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-interface-layer-protocol.png" alt="网络接口层重要功能和协议" tabindex="0"><figcaption>网络接口层重要功能和协议</figcaption></figure>
<h3>总结</h3>
<p>简单总结一下每一层包含的协议和核心技术:</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-protocol-overview.png" alt="TCP/IP 各层协议概览" tabindex="0"><figcaption>TCP/IP 各层协议概览</figcaption></figure>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议）</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</li>
<li>POP3/IMAP（邮件接收协议）</li>
<li>FTP（File Transfer Protocol，文件传输协议）</li>
<li>Telnet（远程登陆协议）</li>
<li>SSH（Secure Shell Protocol，安全的网络传输协议）</li>
<li>RTP（Real-time Transport Protocol，实时传输协议）</li>
<li>DNS（Domain Name System，域名管理系统）</li>
<li>……</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议
<ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议
<ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP（Internet Protocol，网际协议）</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT（Network Address Translation，网络地址转换协议）</li>
<li>OSPF（Open Shortest Path First，开放式最短路径优先）</li>
<li>RIP(Routing Information Protocol，路由信息协议）</li>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
<li>……</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA/CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
<li>……</li>
</ul>
<h2>网络分层的原因</h2>
<p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h2>参考</h2>
<ul>
<li>TCP/IP model vs OSI model：<a href="https://fiberbit.com.tw/tcpip-model-vs-osi-model/" target="_blank" rel="noopener noreferrer">https://fiberbit.com.tw/tcpip-model-vs-osi-model/</a></li>
<li>Data Encapsulation and the TCP/IP Protocol Stack：<a href="https://docs.oracle.com/cd/E19683-01/806-4075/ipov-32/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/cd/E19683-01/806-4075/ipov-32/index.html</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="计算机基础"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">CAP &amp; BASE理论详解</title>
    <id>https://javaguide.cn/learning/distributed-system/protocol/cap-and-base-theorem.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/protocol/cap-and-base-theorem.html"/>
    <updated>2023-10-26T22:44:02.000Z</updated>
    <summary type="html"><![CDATA[<p>经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！</p>
<p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。</p>
<p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。</p>
<h2>CAP 理论</h2>
<p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">CAP 理论/定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>]]></summary>
    <content type="html"><![CDATA[<p>经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！</p>
<p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。</p>
<p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。</p>
<h2>CAP 理论</h2>
<p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">CAP 理论/定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>
<p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。</p>
<h3>简介</h3>
<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>
<figure><img src="https://oss.javaguide.cn/2020-11/cap.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>
<p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p>
<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p><strong>什么是网络分区？</strong></p>
<p>分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p>
<figure><img src="https://oss.javaguide.cn/2020-11/partition-tolerance.png" alt="partition-tolerance" tabindex="0"><figcaption>partition-tolerance</figcaption></figure>
<h3>不是所谓的“3 选 2”</h3>
<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>
<blockquote>
<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>
<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>
</blockquote>
<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>
<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>
<p>另外，需要补充说明的一点是：<strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>
<h3>CAP 实际应用案例</h3>
<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>
<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p>
<figure><img src="https://oss.javaguide.cn/2020-11/dubbo-architecture.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>
<ol>
<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>
<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>
<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>
</ol>
<p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1906" target="_blank" rel="noopener noreferrer">issue#1906</a>）</strong>：</p>
<p>ZooKeeper 通过可线性化（Linearizable）写入、全局 FIFO 顺序访问等机制来保障数据一致性。多节点部署的情况下， ZooKeeper 集群处于 Quorum 模式。Quorum 模式下的 ZooKeeper 集群， 是一组 ZooKeeper 服务器节点组成的集合，其中大多数节点必须同意任何变更才能被视为有效。</p>
<p>由于 Quorum 模式下的读请求不会触发各个 ZooKeeper 节点之间的数据同步，因此在某些情况下还是可能会存在读取到旧数据的情况，导致不同的客户端视图上看到的结果不同，这可能是由于网络延迟、丢包、重传等原因造成的。ZooKeeper 为了解决这个问题，提供了 Watcher 机制和版本号机制来帮助客户端检测数据的变化和版本号的变更，以保证数据的一致性。</p>
<h3>总结</h3>
<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等</p>
<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”</p>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>
<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
<h3>推荐阅读</h3>
<ol>
<li><a href="https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4" target="_blank" rel="noopener noreferrer">CAP 定理简化</a> （英文，有趣的案例）</li>
<li><a href="https://juejin.im/post/6844903936718012430" target="_blank" rel="noopener noreferrer">神一样的 CAP 理论被应用在何方</a> （中文，列举了很多实际的例子）</li>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html" target="_blank" rel="noopener noreferrer">请停止呼叫数据库 CP 或 AP</a> （英文，带给你不一样的思考）</li>
</ol>
<h2>BASE 理论</h2>
<p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128" target="_blank" rel="noopener noreferrer">BASE 理论</a>起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p>
<h3>简介</h3>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h3>BASE 理论的核心思想</h3>
<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>
<p><strong>为什么这样说呢？</strong></p>
<p>CAP 理论这节我们也说过了：</p>
<blockquote>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
</blockquote>
<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h3>BASE 理论三要素</h3>
<figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY?x-oss-process=image/format,png" alt="BASE理论三要素" tabindex="0"><figcaption>BASE理论三要素</figcaption></figure>
<h4>基本可用</h4>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h4>软状态</h4>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4>最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li>
<li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li>
<li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<p>那实现最终一致性的具体方式是什么呢? <a href="http://gk.link/a/10rZM" target="_blank" rel="noopener noreferrer">《分布式协议与算法实战》</a> 中是这样介绍：</p>
<blockquote>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</blockquote>
<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>
<h3>总结</h3>
<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">Gossip 协议详解</title>
    <id>https://javaguide.cn/learning/distributed-system/protocol/gossip-protocl.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/protocol/gossip-protocl.html"/>
    <updated>2024-02-25T12:23:21.000Z</updated>
    <summary type="html"><![CDATA[<h2>背景</h2>
<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>
<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>
<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>
<h2>Gossip 协议介绍</h2>
<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>]]></summary>
    <content type="html"><![CDATA[<h2>背景</h2>
<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>
<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>
<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>
<h2>Gossip 协议介绍</h2>
<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>
<figure><figcaption></figcaption></figure>
<p><strong>Gossip 协议</strong> 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>
<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <a href="https://dl.acm.org/doi/10.1145/41840.41841" target="_blank" rel="noopener noreferrer">《Epidemic Algorithms for Replicated Database Maintenance》</a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。</p>
<p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p>
<p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p>
<p>下面我们来对 Gossip 协议的定义做一个总结：<strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p>
<h2>Gossip 协议应用</h2>
<p>NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>
<p>我们这里以 Redis Cluster 为例说明 Gossip 协议的实际应用。</p>
<p>我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-fcacc1eefca6e51354a5f1fc9f2919f51ec.png" alt="Redis 的官方集群解决方案" tabindex="0"><figcaption>Redis 的官方集群解决方案</figcaption></figure>
<p>Redis Cluster 是一个典型的分布式系统，分布式系统中的各个节点需要互相通信。既然要相互通信就要遵循一致的通信协议，Redis Cluster 中的各个节点基于 <strong>Gossip 协议</strong> 来进行通信共享信息，每个 Redis 节点都维护了一份集群的状态信息。</p>
<p>Redis Cluster 的节点之间会相互发送多种 Gossip 消息：</p>
<ul>
<li><strong>MEET</strong>：在 Redis Cluster 中的某个 Redis 节点上执行 <code>CLUSTER MEET ip port</code> 命令，可以向指定的 Redis 节点发送一条 MEET 信息，用于将其添加进 Redis Cluster 成为新的 Redis 节点。</li>
<li><strong>PING/PONG</strong>：Redis Cluster 中的节点都会定时地向其他节点发送 PING 消息，来交换各个节点状态信息，检查各个节点状态，包括在线状态、疑似下线状态 PFAIL 和已下线状态 FAIL。</li>
<li><strong>FAIL</strong>：Redis Cluster 中的节点 A 发现 B 节点 PFAIL ，并且在下线报告的有效期限内集群中半数以上的节点将 B 节点标记为 PFAIL，节点 A 就会向集群广播一条 FAIL 消息，通知其他节点将故障节点 B 标记为 FAIL 。</li>
<li>……</li>
</ul>
<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>
<figure><figcaption></figcaption></figure>
<p>有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。</p>
<p>关于 Redis Cluster 的详细介绍，可以查看这篇文章 <a href="https://javaguide.cn/database/redis/redis-cluster.html" target="_blank" rel="noopener noreferrer">Redis 集群详解(付费)</a> 。</p>
<h2>Gossip 协议消息传播模式</h2>
<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>
<h3>反熵(Anti-entropy)</h3>
<p>根据维基百科：</p>
<blockquote>
<p>熵的概念最早起源于<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6" target="_blank" rel="noopener noreferrer">物理学</a>，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</p>
</blockquote>
<p>在这里，你可以把反熵中的熵理解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。</p>
<p>具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>
<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>
<ul>
<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>
<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li>
<li>推拉就是同时修复自己副本和对方副本中的熵。</li>
</ul>
<p>伪代码如下：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-df16e98bf71e872a7e1f01ca31cee93d77b.png" alt="反熵伪代码" tabindex="0"><figcaption>反熵伪代码</figcaption></figure>
<p>在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是可以设计成一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p>
<figure><figcaption></figcaption></figure>
<ol>
<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>
<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>
<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>
<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>
</ol>
<p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 <strong>谣言传播(Rumor mongering)</strong> 。</p>
<h3>谣言传播(Rumor mongering)</h3>
<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>
<p>如下图所示（下图来自于<a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/" target="_blank" rel="noopener noreferrer">INTRODUCTION TO GOSSIP</a> 这篇文章）：</p>
<figure><figcaption>Gossip 传播示意图</figcaption></figure>
<p>伪代码如下：</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/csdn/20210605170707933.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p>
<h3>总结</h3>
<ul>
<li>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</li>
<li>我们一般会给反熵设计一个闭环。</li>
<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>
</ul>
<h2>Gossip 协议优势和缺陷</h2>
<p><strong>优势：</strong></p>
<p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p>
<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>
<p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>
<p><strong>缺陷</strong> :</p>
<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>
<p>2、由于拜占庭将军问题，不允许存在恶意节点。</p>
<p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>
<h2>总结</h2>
<ul>
<li>Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</li>
<li>Gossip 协议被 Redis、Apache Cassandra、Consul 等项目应用。</li>
<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>
</ul>
<h2>参考</h2>
<ul>
<li>一万字详解 Redis Cluster Gossip 协议：<a href="https://segmentfault.com/a/1190000038373546" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000038373546</a></li>
<li>《分布式协议与算法实战》</li>
<li>《Redis 设计与实现》</li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">Paxos 算法详解</title>
    <id>https://javaguide.cn/learning/distributed-system/protocol/paxos-algorithm.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/protocol/paxos-algorithm.html"/>
    <updated>2024-02-28T15:28:20.000Z</updated>
    <summary type="html"><![CDATA[<h2>背景</h2>
<p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener noreferrer">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>]]></summary>
    <content type="html"><![CDATA[<h2>背景</h2>
<p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener noreferrer">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>
<p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p>
<p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p>
<p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p>
<p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf" target="_blank" rel="noopener noreferrer">《The Part-Time Parliament》</a>。</p>
<p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener noreferrer">《Paxos Made Simple》</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p>
<p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p>
<figure><figcaption></figcaption></figure>
<blockquote>
<p>The Paxos algorithm, when presented in plain English, is very simple.</p>
</blockquote>
<p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p>
<p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p>
<h2>介绍</h2>
<p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>
<p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p>
<ul>
<li><strong>Basic Paxos 算法</strong>：描述的是多节点之间如何就某个值(提案 Value)达成共识。</li>
<li><strong>Multi-Paxos 思想</strong>：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。</li>
</ul>
<p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—<a href="https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html" target="_blank" rel="noopener noreferrer">Raft 算法</a> 。更具体点来说，Raft 是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p>
<p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong>、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。</p>
<p>针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong>、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p>
<p>区块链系统使用的共识算法需要解决的核心问题是 <strong>拜占庭将军问题</strong> ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p>
<p>下面我们来对 Paxos 算法的定义做一个总结：</p>
<ul>
<li>Paxos 算法是兰伯特在 <strong>1990</strong> 年提出了一种分布式系统共识算法。</li>
<li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。</li>
<li>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。</li>
</ul>
<h2>Basic Paxos 算法</h2>
<p>Basic Paxos 中存在 3 个重要的角色：</p>
<ol>
<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>
<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ol>
<figure><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/protocol/up-890fa3212e8bf72886a595a34654918486c.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p>
<h2>Multi Paxos 思想</h2>
<p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Multi Paxos 思想。</p>
<p>⚠️<strong>注意</strong>：Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。</p>
<p>由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解和实现上比较困难。</p>
<p>不过，也不需要担心，我们并不需要自己实现基于 Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法。</p>
<h2>参考</h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Paxos" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/Paxos</a></li>
<li>分布式系统中的一致性与共识算法：<a href="http://www.xuyasong.com/?p=1970" target="_blank" rel="noopener noreferrer">http://www.xuyasong.com/?p=1970</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">Raft 算法详解</title>
    <id>https://javaguide.cn/learning/distributed-system/protocol/raft-algorithm.html</id>
    <link href="https://javaguide.cn/learning/distributed-system/protocol/raft-algorithm.html"/>
    <updated>2024-02-25T12:23:21.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>本文由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">SnailClimb</a> 和 <a href="https://github.com/jun0315" target="_blank" rel="noopener noreferrer">Xieqijun</a> 共同完成。</p>
</blockquote>
<h2>1 背景</h2>
<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>本文由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">SnailClimb</a> 和 <a href="https://github.com/jun0315" target="_blank" rel="noopener noreferrer">Xieqijun</a> 共同完成。</p>
</blockquote>
<h2>1 背景</h2>
<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>
<p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p>
<p>幸运的是，分布式共识可以帮助应对这些挑战。</p>
<h3>1.1 拜占庭将军</h3>
<p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p>
<blockquote>
<p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p>
</blockquote>
<p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p>
<p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p>
<h3>1.2 共识算法</h3>
<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>
<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png" alt="rsm-architecture.png" tabindex="0"><figcaption>rsm-architecture.png</figcaption></figure>
<p><code>图-1 复制状态机架构</code></p>
<p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p>
<p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p>
<p>适用于实际系统的共识算法通常具有以下特性：</p>
<ul>
<li>
<p>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</p>
</li>
<li>
<p>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</p>
</li>
<li>
<p>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</p>
</li>
<li>
<p>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</p>
</li>
</ul>
<h2>2 基础</h2>
<h3>2.1 节点类型</h3>
<p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p>
<ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>
</ul>
<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/paxos-server-state.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><code>图-2：服务器的状态</code></p>
<h3>2.2 任期</h3>
<figure><img src="https://oss.javaguide.cn/github/javaguide/paxos-term.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><code>图-3：任期</code></p>
<p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p>
<p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p>
<h3>2.3 日志</h3>
<ul>
<li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li>
<li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li>
</ul>
<h2>3 领导人选举</h2>
<p>raft 使用心跳机制来触发 Leader 的选举。</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>
<ul>
<li>赢得选举</li>
<li>其他节点赢得选举</li>
<li>一轮选举结束，无人胜出</li>
</ul>
<p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p>
<p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p>
<ul>
<li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li>
<li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li>
</ul>
<p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>
<p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p>
<h2>4 日志复制</h2>
<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p>
<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>
<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>
<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称这个 entry 是 committed 的，并且向客户端返回执行结果。</p>
<p>raft 保证以下两个性质：</p>
<ul>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>
</ul>
<p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p>
<p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p>
<p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p>
<p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p>
<h2>5 安全性</h2>
<h3>5.1 选举限制</h3>
<p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p>
<p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p>
<p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p>
<h3>5.2 节点崩溃</h3>
<p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p>
<p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p>
<h3>5.3 时间与可用性</h3>
<p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p>
<p><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p>
<ul>
<li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li>
<li><code>electionTimeout</code>：选举超时时间；</li>
<li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li>
</ul>
<p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p>
<p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p>
<p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p>
<p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>
<h2>6 参考</h2>
<ul>
<li><a href="https://tanxinyu.work/raft/" target="_blank" rel="noopener noreferrer">https://tanxinyu.work/raft/</a></li>
<li><a href="https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md" target="_blank" rel="noopener noreferrer">https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md</a></li>
<li><a href="https://github.com/ongardie/dissertation/blob/master/stanford.pdf" target="_blank" rel="noopener noreferrer">https://github.com/ongardie/dissertation/blob/master/stanford.pdf</a></li>
<li><a href="https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html" target="_blank" rel="noopener noreferrer">https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html</a></li>
</ul>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="分布式"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
  <entry>
    <title type="text">滴滴和头条两年后端工作经验分享</title>
    <id>https://javaguide.cn/learning/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html</id>
    <link href="https://javaguide.cn/learning/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.html"/>
    <updated>2023-12-30T09:14:13.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：很实用的工作经验分享，看完之后十分受用！</p>
<p><strong>内容概览</strong>：</p>
<ul>
<li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</li>
<li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</li>
<li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</li>
<li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</li>
<li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</li>
<li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</li>
<li>平时积极总结沉淀，多跟别人交流，形成方法论。</li>
<li>……</li>
</ul>
<p><strong>原文地址</strong>：<a href="https://www.nowcoder.com/discuss/351805" target="_blank" rel="noopener noreferrer">https://www.nowcoder.com/discuss/351805</a></p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>推荐语</strong>：很实用的工作经验分享，看完之后十分受用！</p>
<p><strong>内容概览</strong>：</p>
<ul>
<li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</li>
<li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</li>
<li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</li>
<li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</li>
<li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</li>
<li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</li>
<li>平时积极总结沉淀，多跟别人交流，形成方法论。</li>
<li>……</li>
</ul>
<p><strong>原文地址</strong>：<a href="https://www.nowcoder.com/discuss/351805" target="_blank" rel="noopener noreferrer">https://www.nowcoder.com/discuss/351805</a></p>
</blockquote>
<p>先简单交代一下背景吧，某不知名 985 的本硕，17 年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。</p>
<h2>学会深入思考，总结沉淀</h2>
<p><strong>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。</strong></p>
<p><strong>先来说深入思考。</strong> 在程序员这个圈子里，常能听到一些言论：<em>“我这个工作一点技术含量都没有，每天就 CRUD，再写写 if-else，这 TM 能让我学到什么东西？”</em></p>
<p>抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高 level 的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。<strong>任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。</strong></p>
<p>举一个例子。某次有个同学跟我说，这周有个服务 OOM 了，查了一周发现有个地方 defer 写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查 bug 这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有 linux 的 OOM，k8s 的 OOM，go 的内存管理，defer 机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个 WHY 没问题吧...</p>
<p><strong>再来说下总结沉淀。</strong> 这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。</p>
<p>还是举一个例子。做后台服务，今天优化了 1G 内存，明天优化了 50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大 key 拆分、延迟处理、编码压缩、gc 调优还有各种语言相关的高性能实践...等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。</p>
<p>还有的同学说了，我就每天跟 PM 撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟 PM 讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让 Martin Fowler 整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄...</p>
<p>所以说：<strong>学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。</strong></p>
<h2>积极学习，保持技术热情</h2>
<p>最近两年在互联网圈里广泛传播的一种焦虑论叫做 35 岁程序员现象，大意是说程序员这个行业干到 35 岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是，这个问题里 35 岁程序员并不是绝对生理意义上的 35 岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35 岁和 25 岁差不多，而且没有了 25 岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。</p>
<p><strong>如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？</strong> 但是，<strong>学习这件事，其实是一个反人类的过程，这就需要我们强迫自己跳出自己的安逸区，主动学习，保持技术热情。</strong> 在滴滴时有一句话大概是，<strong>主动跳出自己的舒适区，感到挣扎与压力的时候，往往是黎明前的黑暗，那才是成长最快的时候。相反如果感觉自己每天都过得很安逸，工作只是在混时长，那可能真的是温水煮青蛙了。</strong></p>
<p>刚毕业的这段时间，往往空闲时间还比较多，正是努力学习技术的好时候。借助这段时间夯实基础，培养出良好的学习习惯，保持积极的学习态度，应该是受益终身的。至于如何高效率学习，网上有很多大牛写这样的帖子，到了公司后内网也能找到很多这样的分享，我就不多谈了。</p>
<p><strong><em>可以加入学习小组和技术社区，公司内和公司外的都可以，关注前沿技术。</em></strong></p>
<h2>主动承担，及时交流反馈</h2>
<p>前两条还是从个人的角度出发来说的，希望大家可以提升个人能力，保持核心竞争力，但从公司角度来讲，公司招聘员工入职，最重要的是让员工创造出业务价值，为公司服务。虽然对于校招生一般都会有一定的培养体系，但实际上公司确实没有帮助我们成长的义务。</p>
<p><strong>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。</strong></p>
<p>我当初刚入职的时候，基本就是 leader 给分配什么任务就把本职工作做好，然后就干自己的事了，几乎从来不主动去跟别人交流或者主动去思考些能帮助项目发展的点子。自以为把本职工作保质保量完成就行了，后来发现这么做其实是非常不够的，这只是最基本的要求。而有些同学的做法则是 leader 只需要同步一下最近要做什么方向，下面的一系列事情基本不需要 leader 操心了 ，这样的同学我是 leader 我也喜欢啊。入职后经常会听到的一个词叫 owner 意识，大概就是这个意思吧。</p>
<p>在这个过程中，另外很重要的一点就是及时向上沟通反馈。项目进展不顺利，遇到什么问题，及时跟 leader 同步，技术方案拿捏不准可以跟 leader 探讨，一些资源协调不了可以找 leader 帮忙，不要有太多顾忌，认为这些会太麻烦，leader 其实就是干这个事的。。如果项目进展比较顺利，确实也不需要 leader 介入，那也需要及时把项目的进度，取得的收益及时反馈，自己有什么想法也提出来探讨，问问 leader 对当前进展的建议，还有哪些地方需要改进，消除信息误差。做这些事一方面是合理利用 leader 的各种资源，另一方面也可以让 leader 了解到自己的工作量，对项目整体有所把控，毕竟 leader 也有 leader，也是要汇报的。可能算是大家比较反感的向上管理吧，有内味了，这个其实我也做得不好。但是最基本的一点，不要接了一个任务闷着头干活甚至与世隔绝了，一个月了也没跟 leader 同步过，想着憋个大招之类的，那基本凉凉。</p>
<p><strong>一定要主动，可以先从强迫自己在各种公开场合发言开始，有问题或想法及时 one-one。</strong></p>
<p>除了以上几点，还有一些小点我觉得也是比较重要的，列在下面：</p>
<h2>第一件事建立信任</h2>
<p>无论是校招还是社招，刚入职的第一件事是非常重要的，直接决定了 leader 和同事对自己的第一印象。入职后要做的第一件事一定要做好，最起码的要顺利完成而且不能出线上事故。这件事的目的就是为了建立信任，让团队觉得自己起码是靠谱的。如果这件事做得比较好，后面一路都会比较顺利。如果这件事就搞杂了，可能有的 leader 还会给第二次机会，再搞不好，后面就很难了，这一条对于社招来说更为重要。</p>
<p>而刚入职，公司技术栈不熟练，业务繁杂很难理清什么头绪，压力确实比较大。这时候一方面需要自己投入更多的精力，另一方面要多跟组内的同学交流，不懂就问。<strong>最有效率的学习方式，我觉得不是什么看书啊学习视频啊，而是直接去找对应的人聊，让别人讲一遍自己基本就全懂了，这效率比看文档看代码快多了，不仅省去了过滤无用信息的过程，还了解到了业务的演变历史。当然，这需要一定的沟通技巧，毕竟同事们也都很忙。</strong></p>
<p><strong>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。</strong></p>
<h2>超出预期</h2>
<p>超出预期这个词的外延范围很广，比如 leader 让去做个值周，解答用户群里大家的问题，结果不仅解答了大家的问题，还收集了这些问题进行分类，进而做了一个智能问答机器人解放了值周的人力，这可以算超出预期。比如 leader 让给运营做一个小工具，结果建设了一系列的工具甚至发展成了一个平台，成为了一个完整的项目，这也算超出预期。超出预期要求我们有把事情做大的能力，也就是想到了 leader 没想到的地方，并且创造了实际价值，拿到了业务收益。这个能力其实也比较重要，在工作中发现，有的人能把一个小盘子越做越大，而有的人恰好反之，那么那些有创新能力，经常超出预期的同学发展空间显然就更大一点。</p>
<p><strong>这块其实比较看个人能力，暂时没想到什么太好的捷径，多想一步吧。</strong></p>
<h2>体系化思考，系统化建设</h2>
<p>这句话是晋升时候总结出来的，大意就是做系统建设要有全局视野，不要局限于某一个小点，应该有良好的规划能力和清晰的演进蓝图。比如，今天加了一个监控，明天加一个报警，这些事不应该成为一个个孤岛，而是属于稳定性建设一期其中的一小步。这一期稳定性建设要做的工作是报警配置和监控梳理，包括机器监控、系统监控、业务监控、数据监控等，预期能拿到 XXX 的收益。这个工作还有后续的 roadmap，稳定性建设二期要做容量规划，接入压测，三期要做降级演练，多活容灾，四期要做...给人的感觉就是这个人思考非常全面，办事有体系有规划。</p>
<p><strong>平时积极总结沉淀，多跟别人交流，形成方法论。</strong></p>
<h2>提升自己的软素质能力</h2>
<p>这里的软素质能力其实想说的就是 PPT、沟通、表达、时间管理、设计、文档等方面的能力。说实话，我觉得我当时能晋升就是因为 PPT 做的好了一点...可能大家平时对这些能力都不怎么关注，以前我也不重视，觉得比较简单，用时候直接上就行了，但事实可能并不像想象得那样简单。比如晋升时候 PPT+演讲+答辩这个工作，其实有很多细节的思考在里面，内容如何选取，排版怎么设计，怎样引导听众的情绪，如何回答评委的问题等等。晋升时候我见过很多同学 PPT 内容编排杂乱无章，演讲过程也不流畅自然，虽然确实做了很多实际工作，但在表达上欠缺了很多，属于会做不会说，如果再遇到不了解实际情况的外部门评委，吃亏是可以预见的。</p>
<p><strong><em>公司内网一般都会有一些软素质培训课程，可以找一些场合刻意训练。</em></strong></p>
<p>以上都是这些分享还都算比较伟光正，但是社会吧也不全是那么美好的。。下面这些内容有负能量倾向，三观特别正的同学以及观感不适者建议跳过。</p>
<h2>拍马屁是真的香</h2>
<p>拍马屁这东西入职前我是很反感的，我最初想加入互联网公司的原因就是觉得互联网公司的人情世故没那么多，事实证明，我错了...入职前几天，部门群里大 leader 发了一条消息，后面几十条带着大拇指的消息立马跟上，学习了，点赞，真不错，优秀，那场面，说是红旗招展锣鼓喧天鞭炮齐鸣一点也不过分。除了惊叹大家超强的信息接收能力和处理速度外，更进一步我还发现，连拍马屁都是有队形的，一级部门 leader 发消息，几个二级部门 leader 跟上，后面各组长跟上，最后是大家的狂欢，让我一度怀疑拍马屁的速度就决定了职业生涯的发展前景（没错，现在我已经不怀疑了）。</p>
<p>坦诚地说，我到现在也没习惯在群里拍马屁，但也不反感了，可以说把这个事当成一乐了。倒不是说我没有那个口才和能力（事实上也不需要什么口才，大家都简单直接），在某些场合，为活跃气氛的需要，我也能小嘴儿抹了蜜，甚至能把古诗文彩虹屁给 leader 安排上。而是我发现我的直属 leader 也不怎么在群里拍马屁，所以我表面上不公开拍马屁其实属于暗地里事实上迎合了 leader 的喜好...</p>
<p>但是拍马屁这个事只要掌握好度，整体来说还是香的，最多是没用，至少不会有什么坏处嘛。大家能力都差不多，每一次在群里拍马屁的机会就是一次露脸的机会，按某个同事的说法，这就叫打造个人技术影响力...</p>
<p><strong>想舔就舔，不想舔也没必要酸别人，Respect Greatness。</strong></p>
<h2>永不缺席的撕逼甩锅实战</h2>
<p>有人的地方，就有江湖。虽然搞技术的大多城府也不深，但撕逼甩锅邀功抢活这些闹心的事儿基本也不会缺席，甚至我还见到过公开群发邮件撕逼的...这部分话题涉及到一些敏感信息就不多说了，而且我们低职级的遇到这些事儿的机会也不会太多。只是给大家提个醒，在工作的时候迟早都会吃到这方面的瓜，到时候留个心眼。</p>
<p><strong>稍微注意一下，咱不会去欺负别人，但也不能轻易让别人给欺负了。</strong></p>
<h2>不要被画饼蒙蔽了双眼</h2>
<p>说实话，我个人是比较反感灌鸡汤、打鸡血、谈梦想、讲奋斗这一类行为的，9102 年都快过完了，这一套***治还在大行其道，真不知道是该可笑还是可悲。当然，这些词本身并没有什么问题，但是这些东西应该是自驱的，而不应该成为外界的一种强 push。『我必须努力奋斗』这个句式我觉得是正常的，但是『你必须努力奋斗』这种话多少感觉有点诡异，努力奋斗所以让公司的股东们发家致富？尤其在钱没给够的情况下，这些行为无异于耍流氓。我们需要对 leader 的这些画饼操作保持清醒的认知，理性分析，作出决策。比如感觉钱没给够（或者职级太低，同理）的时候，可能有以下几种情况：</p>
<ol>
<li>leader 并没有注意到你薪资较低这一事实</li>
<li>leader 知道这个事实，但是不知道你有多强烈的涨薪需求</li>
<li>leader 知道你有涨薪的需求，但他觉得你能力还不够</li>
<li>leader 知道你有涨薪的需求，能力也够，但是他不想给你涨</li>
<li>leader 想给你涨，也向上反馈和争取了，但是没有资源</li>
</ol>
<p>这时候我们需要做的是向上反馈，跟 leader 沟通确认。如果是 1 和 2，那么通过沟通可以消除信息误差。如果是 3，需要分情况讨论。如果是 4 和 5，已经可以考虑撤退了。对于这些事儿，也没必要抱怨，抱怨解决不了任何问题。我们要做的就是努力提升好个人能力，保持个人竞争力，等一个合适的时机，跳槽就完事了。</p>
<p><strong>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。</strong></p>
<h2>学会包装</h2>
<p>这一条说白了就是，要会吹。忘了从哪儿看到的了，能说、会写、善做是对职场人的三大要求。能说是很重要的，能说才能要来项目，拉来资源，招来人。同样一件事，不同的人能说出来完全不一样的效果。比如我做了个小工具上线了，我就只能说出来基本事实，而让 leader 描述一下，这就成了，打造了 XXX 的工具抓手，改进了 XXX 的完整生态，形成了 XXX 的业务闭环。老哥，我服了，硬币全给你还不行嘛。据我的观察，每个互联网公司都有这么几个词，抓手、生态、闭环、拉齐、梳理、迭代、owner 意识等等等等，我们需要做的就是熟读并背诵全文，啊不，是牢记并熟练使用。</p>
<p>这是对事情的包装，对人的包装也是一样的，尤其是在晋升和面试这样的应试型场合，特点是流程短一锤子买卖，包装显得尤为重要。晋升和面试这里就不展开说了，这里面的道和术太多了。。下面的场景提炼自面试过程中和某公司面试官的谈话，大家可以感受一下：</p>
<ol>
<li>我们背后是一个四五百亿美金的市场...</li>
<li>我负责过每天千亿级别访问量的系统...</li>
<li>工作两年能达到这个程度挺不错的...</li>
<li>贵司技术氛围挺好的，业务发展前景也很广阔...</li>
<li>啊，彼此彼此...</li>
<li>嗯，久仰久仰...</li>
</ol>
<p>人生如戏，全靠演技</p>
<p><strong>可以多看 leader 的 PPT，多听老板的向上汇报和宣讲会。</strong></p>
<h2>选择和努力哪个更重要？</h2>
<p>这还用问么，当然是选择。在完美的选择面前，努力显得一文不值，我有个多年没联系的高中同学今年已经在时代广场敲钟了...但是这样的案例太少了，做出完美选择的随机成本太高，不确定性太大。对于大多数刚毕业的同学，对行业的判断力还不够成熟，对自身能力和创业难度把握得也不够精准，此时拉几个人去创业，显得风险太高。我觉得更为稳妥的一条路是，先加入规模稍大一点的公司，找一个好 leader，抱好大腿，提升自己的个人能力。好平台加上大腿，再加上个人努力，这个起飞速度已经可以了。等后面积累了一定人脉和资金，深刻理解了市场和需求，对自己有信心了，可以再去考虑创业的事。</p>
<h2>后记</h2>
<p>本来还想分享一些生活方面的故事，发现已经这么长了，那就先这样叭。上面写的一些总结和建议我自己做的也不是很好，还需要继续加油，和大家共勉。另外，其中某些观点，由于个人视角的局限性也不保证是普适和正确的，可能再工作几年这些观点也会发生改变，欢迎大家跟我交流~（甩锅成功）</p>
<p>最后祝大家都能找到心仪的工作，快乐工作，幸福生活，广阔天地，大有作为。</p>
<figure><img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" tabindex="0"><figcaption>JavaGuide 官方公众号</figcaption></figure>
]]></content>
    <category term="技术文章精选集"/>
    <published>2023-04-28T09:15:47.000Z</published>
  </entry>
</feed>